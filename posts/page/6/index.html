<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" Posts &middot;  Erlang &amp; Go" />
  	<meta property="og:site_name" content="Erlang &amp; Go" />
  	<meta property="og:url" content="https://jeidee.github.io/posts/" />
    
    
    <meta property="og:type" content="website" />
    

  <title>
     Posts &middot;  Erlang &amp; Go
  </title>

    <meta name="description" content="" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://jeidee.github.ioimages/favicon.ico">
	  <link rel="apple-touch-icon" href="https://jeidee.github.ioimages/apple-touch-icon.png" />
    
    <link rel="stylesheet" type="text/css" href="https://jeidee.github.iocss/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
      
          <link href="https://jeidee.github.ioindex.xml" rel="alternate" type="application/rss+xml" title="Erlang &amp; Go" />
      
      
        <link href="https://jeidee.github.io/posts/index.xml" rel="alternate" type="application/rss+xml" title="Posts &middot; Erlang &amp; Go" />
      
    
    <meta name="generator" content="Hugo 0.31.1" />

    <link rel="canonical" href="https://jeidee.github.io/posts/" />

    
<div id="particles-js"></div>
<script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
<script src="https://jeidee.github.iojs/particles.js"></script>   
</head>
<body class="nav-closed">

  


 <div class="site-wrapper">




	<header class="main-header tag-head no-cover">

    <nav class="main-nav overlay clearfix">
      
      
        
          <a class="menu-button icon-feed" href="https://jeidee.github.io/posts/index.xml">&nbsp;&nbsp;Subscribe</a>
        
      
    </nav>
    <div class="vertical">

        <div class="main-header-content inner">
            <h1 class="page-title">

              <a class="btn-bootstrap-2" href="#content">Erlang &amp; Go</a>
          </h1>
        </div>
</div>
    <a class="scroll-down icon-arrow-left" href="#content"><span class="hidden">Scroll Down</span></a>
</header>

<main id="content" class="content" role="main">
    

	<div class="extra-pagination inner">
    <nav class="pagination" role="navigation">
	
	    <a class="newer-posts" href="/posts/page/5/">&larr; Newer Posts</a>
	
	<span class="page-number">Page 6 of 20</span>
	
	    <a class="older-posts" href="/posts/page/7/">Older Posts &rarr;</a>
	
</nav>

	</div>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/08/26/go-containterlisteba5bc-ec82acec9aa9ed959c-concurrent-queue/">go containter/list를 사용한 Concurrent Queue</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <ul>
<li>참고자료

<ul>
<li><a href="https://gist.github.com/moraes/2141121">Stack and Queue in golang</a></li>
</ul></li>
</ul>

<p>container/list와 sync.Mutex를 사용한 쓰레드(고루틴)에 안전한 Queue는 다음과 같이 만들 수 있다.</p>

<pre><code>  
package queue

import (
      
&quot;container/list&quot;
      
&quot;sync&quot;
  
)

type Queue struct {
      
l *list.List
      
lock sync.Mutex
  
}

func NewQueue() *Queue {
      
return &amp;Queue{list.New(), sync.Mutex{}}
  
}

func (q *Queue) Push(i interface{}) {
      
q.lock.Lock()
      
defer q.lock.Unlock()

q.l.PushBack(i)
  
}

func (q *Queue) Pop() (interface{}, bool) {
      
q.lock.Lock()
      
defer q.lock.Unlock()

if q.l.Len() == 0 {
          
return nil, false
      
}

v := q.l.Front()
      
q.l.Remove(v)

return v.Value, true
  
}

func (q *Queue) Len() int {
      
q.lock.Lock()
      
defer q.lock.Unlock()

return q.l.Len()
  
}
  
</code></pre>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/queue/">#queue</a>,
            
        
        <time class="post-date" datetime="2015-08-26T00:00:00Z">
            26 Aug 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/08/25/erlang-ec8998ec9790ec849c-observereba5bc-ec82acec9aa9ed95b4-ec9b90eab2a9-eb85b8eb939c-eca091ec868d/">erlang 쉘에서 observer를 사용해 원격 노드 접속</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p>먼저 A와 B, 두 노드가 있고, A에서 B노드에 연결한다고 가정한다.</p>

<p>두 노드를 연결하기 위해서는 다음 조건을 우선 만족시켜야 한다.</p>

<p>1) short name을 사용하는 경우</p>

<ul>
<li><p>A와 B노드는 동일한 네트워크에 있고, 방화벽을 통하지 않는다.</p></li>

<li><p>방화벽을 통해 접속할 경우 B노드의 다음 TCP포트(아래 예에서는 47242)가 Inbound 오픈되어 있어야 한다.</p></li>
</ul>

<pre><code>  
B&gt; net_adm:names();
  
{ok, [{&quot;ejabberd&quot;, 47242}, &amp;#8230;]}
  
</code></pre>

<ul>
<li>A와 B노드의 erlang secretkey(cookie)는 동일해야 한다.</li>
</ul>

<pre><code>  
$ erl -sname A@node1 -setcookie secret
  
$ erl -sname B@node2 -setcookie secret

A&gt; erlang:get_cookie().
  
secret
  
</code></pre>

<p>2) long name을 사용하는 경우</p>

<ul>
<li>A와 B노드에는 FQDN이 설정되어 있고 A노드에서 DNS를 통해 B노드의 다음 포트로 접속이 가능해야 한다.</li>
</ul>

<pre><code>  
B@hello.world.com&gt; net_adm:names();
  
{ok, [{&quot;ejabberd&quot;, 47242}, &amp;#8230;]}
  
</code></pre>

<ul>
<li>A와 B노드의 erlang secretkey(cookie)는 동일해야 한다.</li>
</ul>

<p>위의 조건을 만족할 경우 다음과 같이 A노드에서 B노드에 연결가능한지 확인한다.</p>

<pre><code>  
A&gt; net_adm:ping('B@node2').
  
pong
  
A@hello.world&gt; net_adm:ping('B@foo.bar').
  
pong
  
</code></pre>

<p>정상적으로 pong이 수신될 경우 다음과 같이 observer를 시작한후 Nodes 메뉴에서 connect node를 하면 된다.</p>

<pre><code>  
A&gt; observer:start().
  
</code></pre>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/observer/">#observer</a>,
            
        
        <time class="post-date" datetime="2015-08-25T00:00:00Z">
            25 Aug 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/08/25/go-json-eb9494ecbd94eb8d94eba5bc-ec82acec9aa9ed95b4ec849c-tcp-ec8aa4ed8ab8eba6bcec9cbceba19c-ec8898ec8ba0ed959c-json-object-ecb298eba6aced9598/">go json 디코더를 사용해서 TCP 스트림으로 수신한 json object 처리하기</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p>우선 net.Conn 인스턴스(c.conn은 net.Conn 인스턴스)를 사용해서 json 디코더를 생성한다.</p>

<pre><code>  
d := json.NewDecoder(c.conn)
  
</code></pre>

<p>수신받은 데이터를 json 오브젝트로 디코딩한다.</p>

<pre><code>  
var packet map[string]interface{}
  
err := d.Decode(&amp;packet)
  
</code></pre>

<p>json 오브젝트를 특정 구조체 데이터로 캐스팅한다.</p>

<p>그 전에 송수신 하는 json 오브젝트에 id필드가 있다고 가정하며,</p>

<p>id필드 값에 따라 다른 구조체로 캐스팅하도록 한다.</p>

<pre><code>  
type ReqLoginPacket struct {
    
Id int \`json:&quot;id&quot;\`
    
UserId string \`json:&quot;user_id&quot;\`
  
}

pid := int(p[&quot;id&quot;].(float64))

switch pid {
    
case 1:
      
reqPacket := new(ReqLoginPacket)
      
MapToObject(packet, reqPacket)
    
&amp;#8230;
  
}
  
</code></pre>

<p>MapToObject/2 함수는 다음과 같다.</p>

<pre><code>  
func MapToObject(m map[string]interface{}, o interface{}) error {
    
v, err := json.Marshal(m)
    
if err != nil {
      
return err
    
}

err = json.Unmarshal(v, &amp;o)
    
if err != nil {
      
return err
    
}

return nil
  
}
  
</code></pre>

<p>위 코드의 문제점은 Marshal/Unmarshal 오버헤드가 크다는 점이다.</p>

<p>네트워크 스트림을 json으로 디코딩해 map 오브젝트로 만들고, 이 오브젝트를 다시 byte array로 마샬링한 후 특정 구조체 오브젝트로 언마샬하는 과정이 필요하기 때문에,</p>

<p>성능상 큰 손실이 발생할 수 밖에 없다.</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/json/">#json</a>,
            
                <a href="https://jeidee.github.iotags/json-serialization/">#json serialization</a>,
            
        
        <time class="post-date" datetime="2015-08-25T00:00:00Z">
            25 Aug 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/08/19/go-tcp-json-decoder-ec82acec9aa9ed9598eab8b0/">go tcp &#43; json decoder 사용하기</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p>다음 코드는 클라이언트에서 보낸 json 패킷을 디코딩하는 간단한 tcp 서버 예제코드이다.</p>

<pre><code>  
package main

import (
      
&quot;encoding/json&quot;
      
&quot;log&quot;
      
&quot;net&quot;
  
)

func main() {
      
ln, err := net.Listen(&quot;tcp&quot;, &quot;:9080&quot;)
      
if err != nil {
          
log.Fatal(err)
          
return
      
}
      
defer ln.Close()

for {
          
c, err := ln.Accept()
          
if err != nil {
              
log.Fatalln(&quot;Can't accept new client!&quot;, err)
              
return
          
}
          
defer c.Close()

go requestHandler(c)
      
}
  
}

type Packet struct {
      
Id int16 \`json:&quot;id&quot;\`
      
Data interface{} \`json:&quot;data&quot;\`
  
}

func requestHandler(c net.Conn) {
      
d := json.NewDecoder(c)

var packet Packet

for {
          
err := d.Decode(&amp;packet)
          
if err != nil {
              
log.Println(&quot;Invalid json format!\n&quot;, err)
              
c.Close()
              
return
          
}

log.Println(packet, err)
      
}
  
}
  
</code></pre>

<p>json 포맷이 아닌 데이터를 수신하면 해당 클라이언트의 연결을 닫는다.</p>

<p>클라이언트에서는 다음과 같이 완성된 json 문자열을 한 번에 보내거나,</p>

<p>각각 여러 조각으로 분리해서 보낼 수 있다.</p>

<pre><code>  
{&quot;id&quot;:1, &quot;data&quot;:{}}
  
{&quot;id&quot;:1,
   
&quot;data&quot;:{}}
  
</code></pre>

<p>서버는 d.Decode(&#8230;) 함수에서 클라이언트에서 보낸 데이터를 수신한 후,</p>

<p>수신된 데이터를 조합해 완성된 json 데이터를 생성(디코딩)한다.</p>

<p>d.Decode(&amp;packet) 함수에 주어진 packet 데이터 타입으로 json 데이터를 캐스팅할 수 없다면 packet에는 nil을 대입한다.</p>

<p>다음과 같이 map[string]interface{} 타입의 변수를 d.Decode(&#8230;) 함수의 매개변수로 넘겨줄 경우,</p>

<p>어떤 포맷의 json 데이터도 디코딩해서 가져올 수 있다.</p>

<pre><code>  
var v map[string]interface{}

err := d.Decode(&amp;v)
  
</code></pre>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/json/">#json</a>,
            
                <a href="https://jeidee.github.iotags/tcp/">#tcp</a>,
            
        
        <time class="post-date" datetime="2015-08-19T00:00:00Z">
            19 Aug 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/08/19/go-gtk-ec84a4ecb998/">go-gtk 설치</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p>golang을 사용해서 gui 프로그래밍을 하려면 go-gtk를 설치하면 된다.</p>

<p>go-gtk는 libgtk+ 2.0을 필요로 하는데,</p>

<p>ubuntu에서 libgtk+ 2.0은 다음과 같이 설치할 수 있다.</p>

<pre><code>  
$ sudo apt-get install libgtk2.0-dev
  
$ go get github.com/mattn/go-gtk/gtk
  
</code></pre>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/golang/">#golang</a>,
            
                <a href="https://jeidee.github.iotags/gtk/">#gtk</a>,
            
        
        <time class="post-date" datetime="2015-08-19T00:00:00Z">
            19 Aug 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/07/24/erlang-mumble-server-maunder/">erlang mumble server &amp;#8211; maunder</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p>erlang으로 구현된 mumble서버 중에 <a href="https://github.com/tcoram/maunder">maunder</a>라고 있다.</p>

<p>2년전 커밋이 마지막이다.</p>

<p>erlang 17버전에서 빌드하고 실행하면 application:start()할 때 오류가 발생한다.</p>

<p>원인은 erlang 17버전에서 public_key application이 asn1을 의존하기 때문인데,</p>

<p>maunder.erl 소스를 다음과 같이 수정하고 다시 빌드하면 문제가 해결된다.</p>

<pre><code>  
%% @spec start() -&gt; ok
  
%% @doc Start the maunder server.
  
start() -&gt;
      
ensure_started(sasl),
      
ensure_started(crypto),
      
ensure_started(asn1),
      
ensure\_started(public\_key),
      
ensure_started(ssl),
      
application:start(maunder).
  
</code></pre>

<p>기동시 eaddrinuse 관련 에러가 발생하는 경우,</p>

<p>maunder_app.erl의 DEF_PORT값(기본값은 8080)을 변경한 후 다시 빌드하면 된다.</p>

<p>매번 포트를 변경할 때마다 재빌드하는게 번거로울 경우 빌드후 생성되는 ebin/maunder.app에 listen_port 설정을 다음과 같이 추가하면 된다.</p>

<pre><code>                
{env,[{version,{1,&lt;&lt;&quot;maunder&quot;&gt;&gt;,&lt;&lt;&quot;linux&quot;&gt;&gt;,&lt;&lt;&quot;erlangish&quot;&gt;&gt;}},
                      
{listen_port,19980},
  
</code></pre>

<p>하지만 소스상의 문제인지 erlang이 버전업하면서 생긴 문제인지 maunder_app.erl의 get_app_env/2 함수가 제대로 동작하지 않는다.</p>

<p>정확하게 말해 application:get_application()의 값이 undefined로 반환되기 때문인데,</p>

<p>이 부분은 추후 파악되면 업데이트하기로 하겠다.</p>

<p>임시 방편으로 소스를 다음과 같이 수정하면 된다.</p>

<pre><code>  
get\_app\_env(Opt, Default) -&gt;
  
%% case application:get\_env(application:get\_application(), Opt) of
      
case application:get_env(maunder, Opt) of
  
</code></pre>

<p>매번 빌드할 때 마다 maunder.app.src의 내용으로 ebin/maunder.app 파일 내용이 교체되므로 주의가 필요하다.</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/maunder/">#maunder</a>,
            
                <a href="https://jeidee.github.iotags/mumble/">#mumble</a>,
            
        
        <time class="post-date" datetime="2015-07-24T00:00:00Z">
            24 Jul 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/07/23/ejabberd-ec9ab0ebb684ed88acec9790ec849c-fqdnec9d84-ec82acec9aa9ed95b4-long-node-nameec9d84-ec84a4eca095ed95a0-eb958c-cant-set-long-node-name-ec9790/">ejabberd 우분투에서 FQDN을 사용해 long node name을 설정할 때, Can&amp;#8217;t set long node name 에러 발생하는 경우</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p>제목과 같이 우분투에서 long node name을 사용해 ejabberd(erlang) 노드를 사용할 경우,</p>

<p>ejabberdctl의 status, debug등의 명령을 실행하면 다음과 같은 에러가 발생하는 경우가 있다.</p>

<pre><code>  
&quot;Can't set long node name!nPlease check your configurationn&quot;,[]}
  
</code></pre>

<p>예를 들어, 노드명을 ejabberd@hello.world.com 으로 사용할 경우 다음과 같이 hostname을 확인해 본다.</p>

<pre><code>  
$ sudo hostname
  
</code></pre>

<p>hostname이 hello.world.com으로 설정되어 있어야 한다.</p>

<p>만약, 제대로 설정되어 있지 않은 경우 다음과 같이 설정한다.</p>

<pre><code>  
$ sudo hostname hello.world.com
  
</code></pre>

<p>영구적으로 사용하고자 한다면 /etc/hostname의 값도 수정해야 한다.</p>

<pre><code>  
$ sudo vi /etc/hostname

&amp;#8230;

hello.world.com
  
</code></pre>

<p>그런 후 /var/lib/ejabberd/ 하위의 파일을 모두 삭제한 후 다시 ejaberd 노드를 시작해 주면 된다.</p>

<pre><code>  
$ rm -rf /var/lib/ejabberd/*
  
$ ejabberdctl start
  
</code></pre>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/erlang/">#erlang</a>,
            
        
        <time class="post-date" datetime="2015-07-23T00:00:00Z">
            23 Jul 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/25/ejabberdec9980-riak-ec97b0eb8f99/">ejabberd와 riak 연동</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<h2 id="ejabberd-설치">ejabberd 설치</h2>

<p>ejabberd에 riak를 활성화해서 설치하는 방법은 <a href="https://erlnote.wordpress.com/2015/01/31/ejabberd-riak-%ED%99%9C%EC%84%B1%ED%99%94-%EC%84%A4%EC%B9%98/">이전 포스트</a>를 참고해서 설치한 후, <a href="http://docs.ejabberd.im/admin/guide/configuration/#database-and-ldap-configuration">공식 문서</a>를 참고해서 설정한다.</p>

<h2 id="riak-설치">riak 설치</h2>

<p>riak 설치방법은 여러 방법이 있지만 ubuntu에서 간단히 다음 방법을 사용해 설치한다.</p>

<pre><code>  
wget http://s3.amazonaws.com/downloads.basho.com/riak/2.1/2.1.1/ubuntu/precise/riak\_2.1.1-1\_amd64.deb
  
sudo dpkg -i riak\_2.1.1-1\_amd64.deb
  
</code></pre>

<h3 id="riak-주요-파일-위치">riak 주요 파일 위치</h3>

<p>위와 같이 설치되면 다음의 디렉토리에 주요 파일들이 위치하게 된다.</p>

<p>1) 실행파일</p>

<p>/usr/sbin/riak</p>

<p>/usr/sbin/riak-admin</p>

<p>/usr/sbin/riak-debug</p>

<p>2) 설정파일</p>

<p>/etc/riak/riak.conf</p>

<p>3) 로그파일</p>

<p>/var/log/riak/console.log</p>

<p>/var/log/riak/crash.log</p>

<p>/var/log/riak/error.log</p>

<p>/var/log/riak/erlang.log</p>

<p>/var/log/riak/run_erl.log</p>

<h3 id="riak-실행-확인">riak 실행 확인</h3>

<p>설치가 완료되면 다음과 같이 riak를 시작한다.</p>

<pre><code>  
$ sudo riak start
  
</code></pre>

<p>정상적으로 실행되었고 에러가 없는지 확인한다.</p>

<pre><code>  
$ sudo riak ping
  
pong
  
</code></pre>

<p>pong이 출력되고 crash.log와 error.log에 로그가 없다면 정상 실행된 것이다.</p>

<pre><code>  
$ sudo vi /var/log/riak/crash.log
  
$ sudo vi /var/log/riak/error.log
  
</code></pre>

<h2 id="riak-ejabberd-연동-설정">riak ejabberd 연동 설정</h2>

<p>riak를 설치한 후 <a href="http://docs.ejabberd.im/admin/guide/configuration/#database-and-ldap-configuration">ejabberd의 riak 연동 문서</a>를 보고 다음과 같이 riak의 환경설정을 수정한다.</p>

<h3 id="ejabberd-yml-수정">ejabberd.yml 수정</h3>

<pre><code>  
default_db: riak
  
</code></pre>

<p>이 외에도 다음과 같이 riak 연결 설정을 할 수 있다.</p>

<ul>
<li>riak_server: String # 기본값은 localhost이므로 생략 가능</li>
<li>riak_port: Port # 기본값은 8087이며 생략 가능</li>
<li>riak_pool_size: N # 기본값은 10이며 생략 가능. ejabberd가 열게 되는 riak 연결 수</li>
<li>riak_start_interval: N # 기본값은 30초. Riak 연결이 실패하면 재시도 대기하는 시간</li>
</ul>

<h3 id="riak-conf-수정">riak.conf 수정</h3>

<pre><code>  
$ sudo vi /etc/riak/riak.conf

&amp;#8230;
  
storage_backend = leveldb

</code></pre>

<h3 id="vm-args-생성">vm.args 생성</h3>

<pre><code>  
$ sudo vi /etc/riak/vm.args

&amp;#8230;
  
-pz /lib/ejabberd/ebin
  
</code></pre>

<p>ejabberd/ebin 디렉토리는 ejabberd를 어디에 설치했는지에 따라 다르므로 각자의 환경에 맞게 수정한다.</p>

<h3 id="riak-재실행">riak 재실행</h3>

<pre><code>  
$ sudo riak restart
  
</code></pre>

<p>위와 같이 재실행하고 나면 riak가 정상실행되지 않고 crash된다.</p>

<p>console.log를 확인하면 다음과 같은 에러메세지와 함께 crash 로그를 확인할 수 있다.</p>

<pre><code>  
[error] &lt;0.186.0&gt; gen\_server riak\_core\_capability terminated with reason: no function cla use matching orddict:fetch(nonode@nohost, [{'riak@127.0.0.1',[{ {riak\_control,member\_info\_version},[v1,v0]},{ {riak \_core,bucket\_types},[true,&amp;#8230;]},&amp;#8230;]}]) line 72

</code></pre>

<p>우리가 만든 vm.args에 -pz 이외의 필요한 설정값들이 없기 때문이다.</p>

<p>위의 에러는 노드명이 지정되지 않아서 생긴 문제인데, vm.args파일을 다른 이름으로 변경한 후 다시 riak를 실행해 보자.</p>

<pre><code>  
$ sudo mv /etc/riak/vm.args /etc/riak/vm.args.bak
  
$ sudo riak start
  
</code></pre>

<p>그런 후 riak 프로세스를 살펴보면 다음과 같이 erlang vm의 시작 옵션에 -vm_args 옵션이 설정되어 있음을 확인할 수 있다.</p>

<pre><code>  
$ ps -ef | grep riak

&amp;#8230;
  
riak 9534 9531 22 09:48 pts/12 00:00:02 /usr/lib/riak/erts-5.10.3/bin/beam.smp -scl false -sfwi 500 -P 256000 -e 256000 -Q 65536 -A 64 -K true -W w -zdbbl 32768 &amp;#8212; -root /usr/lib/riak -progname riak &amp;#8212; -home /var/lib/riak &amp;#8212; -boot /usr/lib/riak/releases/2.1.0/riak -config /var/lib/riak/generated.configs/app.2015.06.25.09.48.44.config -setcookie riak -name riak@127.0.0.1 -smp enable -vm_args /var/lib/riak/generated.configs/vm.2015.06.25.09.48.44.args -pa /usr/lib/riak/lib/basho-patches &amp;#8212; console
  
</code></pre>

<p>/var/lib/riak에는 riak에서 생성한 데이터파일과 기타 설정 파일들이 위치하는데, generated.configs 디렉토리에 vm.2015.06.25.09.48.44.args 파일이 있음을 확인할 수 있다.</p>

<p>해당 파일을 열어보면 다음과 같은 내용을 확인할 수 있다.</p>

<pre><code>  
+scl false
  
+sfwi 500
  
+P 256000
  
+e 256000
  
-env ERL\_CRASH\_DUMP /var/log/riak/erl_crash.dump
  
-env ERL\_FULLSWEEP\_AFTER 0
  
+Q 65536
  
+A 64
  
-setcookie riak
  
-name riak@127.0.0.1
  
+K true
  
+W w
  
-smp enable
  
+zdbbl 32768
  
</code></pre>

<p>위 값들은 erlang vm의 시작옵션들이며 각각의 옵션이 의미하는 바는 <a href="http://erlang.org/doc/man/erl.html">Erl</a>문서를 참고하도록 한다.</p>

<p>위의 옵션들을 우리가 만든 vm.args.bak파일에 추가해 준다.(vm.args.bak에는 -pz 옵션만 설정되어 있다.)</p>

<p>vm.args.bak파일을 vm.args로 변경한 후 riak를 재실행해 준다.</p>

<p>riak를 재실행한 후 다음과 같은 에러가 console.log에 출력된다면 다음과 같이 cookie를 수정해 주도록 한다.</p>

<pre><code>  
[error] &lt;0.2424.0&gt; \*\* Connection attempt from disallowed node 'riak\_maint\_10788@127.0.0.1' \*\*
  
</code></pre>

<p>ejabberd 노드의 cookie를 다음과 같이 확인한 후,</p>

<pre><code>  
$ ejabberdctl debug

&gt; erlang:get_cookie().
  
'XGKYILEFXQKKCTWXBVFA'
  
</code></pre>

<p>vm.args의 -setcookie 옵션을 다음과 같이 변경해 준다.</p>

<pre><code>  
-setcookie XGKYILEFXQKKCTWXBVFA
  
</code></pre>

<p>그런 후 /var/lib/riak안에 생성된 파일들을 모두 제거한 후 다시 riak를 실행하면 된다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><p><a href="https://erlnote.wordpress.com/2015/01/31/ejabberd-riak-%ED%99%9C%EC%84%B1%ED%99%94-%EC%84%A4%EC%B9%98/">ejabberd riak 활성화 설치</a></p></li>

<li><p><a href="http://docs.ejabberd.im/admin/guide/configuration">ejabberd configuration guide</a></p></li>

<li><p><a href="http://docs.basho.com/riak/latest/ops/building/installing/debian-ubuntu/">riak installing guide</a></p></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/nosql/">#nosql</a>,
            
        
        <time class="post-date" datetime="2015-06-25T00:00:00Z">
            25 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/21/elixir-where-to-go-next-2121/">Elixir Where to go next (#21/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>더 배우고 싶은가? 그럼 계속 읽어보자.</p>

<h2 id="build-your-first-elixir-project">Build your first Elixir project</h2>

<p>우리의 첫 프로젝트를 시작하기 위해, elixir는 Mix라는 빌드 툴을 제공한다. 우리는 다음과 같이 간단하게 첫 프로젝트를 만들 수 있다.</p>

<pre><code>  
mix new path/to/new/project
  
</code></pre>

<p>위의 과정을 통해 우리는 슈퍼비전 트리, 설정, 테스트등을 갖는 elixir 응용프로그램을 만들 수 있다. 다음 가이드를 통해 우리는 분산된 노드에 분산된 key-value 저장소를 갖는 응용프로그램을 만드는 방법을 배울 수 있다.</p>

<ul>
<li><a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html">Mix and OTP</a></li>
</ul>

<h2 id="meta-programming">Meta-programming</h2>

<p>elixir는 메타 프로그래밍(코드를 생성하는 코드)을 지원하는 매우 확장성 있는 프로그래밍 언어이다. elixir는 매크로를 통해 메타-프로그래밍을 지원하며 여러 상황에서(특히 DSLs을 작성할 때) 매우 유용하게 사용할 수 있다. 우리는 다음 가이드를 통해 매크로를 사용한 기본 매커니즘을 설명하며 어떻게 매크로를 작성하고 그것들을 DSLs를 만들때 사용하는지 배울 수 있다.</p>

<ul>
<li><a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html">Meta-programming in Elixir</a></li>
</ul>

<h2 id="community-and-othe-resources">Community and othe resources</h2>

<p>이 외에도 elixir와 관련된 책과, 스크린캐스트 및 다른 여러 리소스를 찾을 수 있다. 또한 컨퍼런스, 오픈소스 프로젝트, 커뮤니티에서 생성한 학습 자료 등도 꽤 많다.</p>

<blockquote>
<p>역주 : 안타깝게도 현 시점(2015년 6월)에서 한글 자료는 전무하다.</p>
</blockquote>

<p>만약 elixir와 관련한 어려움이 있다면 irc.freenode.net의 #elixir-lang 채널을 방문하거나 <a href="http://groups.google.com/group/elixir-lang-talk">메일링 리스트</a>에 메세지를 보낼 수 있음을 기억하도록 한다. 그 곳에서 도움을 받을 수도 있고, <a href="http://elixir-lang.org/blog/">공식 블로그</a>나 <a href="http://groups.google.com/group/elixir-lang-core">공식 그룹</a>에서 최신 뉴스와 공지를 받아볼 수도 있다.</p>

<p>최신의 <a href="https://github.com/elixir-lang/elixir">elixir 소스코드</a>를 살펴볼 수 있다는 것과 <a href="http://elixir-lang.org/docs.html">elixir의 공식문서</a>를 살펴볼 수 있다는 것을 잊지말자.</p>

<h2 id="a-byte-of-erlang">A byte of Erlang</h2>

<p>elixir는 Erlang VM에서 동작하기 때문에, 이르거나 뒤늦은 차이는 있겠지만, elixir 개발자는 erlang 라이브러리와 인터페이스할 때가 오게된다. 아래에 Erlang과 관련된 좀 더 전문적인 내용을 포함하는 온라인 리소스의 링크가 있다.</p>

<ul>
<li><p><a href="http://elixir-lang.org/crash-course.html">Erlang 구문 : 집중 훈련</a>에서는 Erlang 구문의 간결한 소개를 제공한다. 각 코드 조각들은 elixir와 동등한 코드로 대응할 수 있다. 이 곳에서 Erlang의 기본 구문을 배울 수 있을 뿐만 아니라, 지금까지 배운 elixir의 내용을 리뷰할 수 있는 기회도 얻을 수 있다.</p></li>

<li><p>Erlang의 공식 웹 사이트에는 동시성(concurrent) 프로그래밍을 위한 Erlang의 기본 구문을 간략히 살펴볼 수 있는 <a href="http://www.erlang.org/course/concurrent_programming.html">튜토리얼</a>을 제공한다.</p></li>

<li><p><a href="http://learnyousomeerlang.com/">Learn You Some Erlang for Great Good!</a>사이트에서 Erlang의 뛰어난 소개를 볼 수 있다. 이 곳에서 Erlang의 설계 원리, 표준 라이브러리, 실제 사용례등의 많은 내용을 접해 볼 수 있다. 위에서 언급한 집중 코스를 한 번 읽어 봤다면, 이 책의 처음 몇 챕터는 쉽게 건너 뛸 수 있을 것이다. <a href="http://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency">동시성을 위한 히치하이커를 위한 안내</a> 챕터에 다다랐을때 비로소, 진짜 재밌는 시작을 할 수 있게 될 것이다.</p></li>
</ul>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/where-to-go-next.html">Elixir Where to go next</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-21T00:00:00Z">
            21 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/19/elixir-sigils-1821/">Elixir Sigils (#18/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>우리는 이미 elixir의 문자열과 문자 리스트를 배웠다. 하지만, 언어에 있어 텍스트의 표현을 위한 구조의 겉면만 다루었을 뿐이다. atom을 예로 들면, 대부분 :atom 형식으로 표현되는 식이다.</p>

<p>elixir의 목표 중 하나는 확장성이다: elixir를 사용하면 개발자가 어떤 도메인에도 꼭 맞도록 언어를 확장할 수 있다. 개발자나, 회사, 또는 커뮤티니들이 그들과 관련된 도메인안에서 언어를 확장할 수 있도록 만들어졌다는 말이다.</p>

<p>이번 챕터에서 우리는, 텍스트 처리에 사용하는 매커니즘 중 하나인 <a href="https://en.wikipedia.org/wiki/Sigil_(computer_programming)">sigil &#8211; $foo에서 $와 같은 기호</a>에 대해서 알아볼 것이다. sigil은 틸드(~) 문자로 시작하는 문자열이며 선택적으로 시작과 끝 구분자를 가질 수 있다.</p>

<h2 id="regular-expressions">Regular expressions</h2>

<p>대표적인 sigil로는 ~r이 있는데, 정규표현식을 만들때 사용한다.</p>

<pre><code>  
\# A regular expression that matches strings which contain &quot;foo&quot; or &quot;bar&quot;:
  
iex&gt; regex = ~r/foo|bar/
  
~r/foo|bar/
  
iex&gt; &quot;foo&quot; =~ regex
  
true
  
iex&gt; &quot;bat&quot; =~ regex
  
false
  
</code></pre>

<p>elixir는 perl과 호환되는 정규 표현식(regexes)을 지원하는데 <a href="http://www.pcre.org/">PCRE</a> 라이브러리로 구현되어 있다. 정규 표현식은 변경자(modifier) 역시 지원한다. 예를 들어, i 변경자는 정규 표현식이 대소문자 구분을 하도록 한다.</p>

<pre><code>  
iex&gt; &quot;HELLO&quot; =~ ~r/hello/
  
false
  
iex&gt; &quot;HELLO&quot; =~ ~r/hello/i
  
true
  
</code></pre>

<p>정규 표현식에서 지원되는 다른 변경자와 기능(operation)을 살펴보고 싶다면 <a href="http://elixir-lang.org/docs/stable/elixir/#!Regex.html">Regex</a> 모듈을 확인해 보면 된다.</p>

<p>지금까지, 모든 예제는 정규 표현식에 / 구분자를 사용했다. 그 외에도 sigil은 8개의 다른 구분자(delimiter)를 지원한다.</p>

<pre><code>  
~r/hello/
  
~r|hello|
  
~r&quot;hello&quot;
  
~r'hello'
  
~r(hello)
  
~r[hello]
  
~r{hello}
  
~r
  
</code></pre>

<p>다른 구분자를 제공하는 이면에는 다른 구분자들이 다른 sigil에 더욱 적합하기 때문이다. 예를 들어, 정규 표현식을 위해 소괄호를 사용한다면 regex에 포함되는 소괄호와 혼동될 것이다. 어쨌든, 다음 섹션에서 살펴보겠지만, 소괄호는 다른 sigil에서 유용하다.</p>

<h2 id="strings-char-lists-and-words-sigils">Strings, char lists and words sigils</h2>

<p>정규 표현식 이외에도, elixir는 세 개의 다른 sigil을 포함한다.</p>

<h3 id="strings">Strings</h3>

<p>~s sigil은 문자열을 만들때 사용되는데, &#8220;&#8221;을 사용하는 것과 같다. ~s sigil은 안에 &#8220;&#8221;(double quotes)와 &#8221;(single quotes)를 포함해야 할 때 유용하게 사용될 수 있다.</p>

<pre><code>  
iex&gt; ~s(this is a string with &quot;double&quot; quotes, not 'single' ones)
  
&quot;this is a string with \&quot;double\&quot; quotes, not 'single' ones&quot;
  
</code></pre>

<h3 id="char-lists">Char lists</h3>

<p>~c sigil은 문자 리스트를 만들 때 사용한다.</p>

<pre><code>  
iex&gt; ~c(this is a char list containing 'single quotes')
  
'this is a char list containing \'single quotes\''
  
</code></pre>

<h3 id="word-lists">Word lists</h3>

<p>~w sigil은 단어 리스트(단어는 문자열이다.)를 만들때 사용한다. ~w sigil안에서, 단어는 공백으로 구분한다.</p>

<pre><code>  
iex&gt; ~w(foo bar bat)
  
[&quot;foo&quot;, &quot;bar&quot;, &quot;bat&quot;]
  
</code></pre>

<p>~w sigil은 c, s, a 변경자(각각 문자 리스트, 문자열, atom을 위한)를 사용할 수 있는데, 각 요소의 결과 데이터타입을 명시할 때 사용한다.</p>

<pre><code>  
iex&gt; ~w(foo bar bat)a
  
[:foo, :bar, :bat]
  
</code></pre>

<h2 id="interpolation-and-escaping-in-sigils">Interpolation and escaping in sigils</h2>

<p>소문자화(lowercase) sigil 이외에도, elixir는 대문자화(uppercase) sigil을 문자열 삽입(interpolation)에서 문자를 escape하기 위해 사용한다. ~s와 ~S는 문자열을 반환하며, 전자는 escape와 interpolation을 지원하며 후자는 지원하지 않는다.</p>

<pre><code>  
iex&gt; ~s(String with escape codes \x26 #{&quot;inter&quot; &quot;polation&quot;})
  
&quot;String with escape codes &amp; interpolation&quot;
  
iex&gt; ~S(String without escape codes and without #{interpolation})
  
&quot;String without escape codes and without \#{interpolation}&quot;
  
</code></pre>

<p>다음 escape 코드는 문자열과 문자리스트에서 사용된다.</p>

<ul>
<li>&#092;&rdquo; &#8211; double quote</li>
<li>&#092;&rsquo; &#8211; single quote</li>
<li>&#092;&#092; &#8211; single backslash</li>
<li>&#092;a &#8211; bell/alert</li>
<li>&#092;b &#8211; backspace</li>
<li>&#092;d &#8211; delete</li>
<li>&#092;e -escape</li>
<li>&#092;f &#8211; form feed</li>
<li>&#092;n &#8211; newline</li>
<li>&#092;r &#8211; carriage return</li>
<li>&#092;s &#8211; space</li>
<li>&#092;t &#8211; tab</li>
<li>&#092;v &#8211; vertical tab</li>
<li>&#092;0 &#8211; null byte</li>
<li>&#092;xDD &#8211; 16진수 표현(예, &#092;x13)</li>
<li>&#092;x{D&#8230;} &#8211; 16진수 숫자를 하나 이상 갖는 16진수 표현(예, &#092;x{abc13})</li>
</ul>

<p>sigil은 heredoc을 지원하며, 구분자로 &ldquo;&rdquo;&ldquo;나 &lsquo;를 사용한다.</p>

<pre><code>  
iex&gt; ~s&quot;&quot;&quot;
  
&amp;#8230;&gt; this is
  
&amp;#8230;&gt; a heredoc string
  
&amp;#8230;&gt; &quot;&quot;&quot;
  
</code></pre>

<p>heredoc sigil의 대표적인 사용예는 문서를 쓸 때 이다. 예를 들어, 문서에서 escape 문자를 쓰고자 할 때는 두번 적어야 한다.</p>

<pre><code>  
@doc &quot;&quot;&quot;
  
Converts double-quotes to single-quotes.

\## Examples

iex&gt; convert(&quot;\\\&quot;foo\\\&quot;&quot;)
      
&quot;'foo'&quot;

&quot;&quot;&quot;
  
def convert(&amp;#8230;)
  
</code></pre>

<p>~S를 사용하면 다음과 같이 작성할 수 있다.</p>

<pre><code>  
@doc ~S&quot;&quot;&quot;
  
Converts double-quotes to single-quotes.

\## Examples

iex&gt; convert(&quot;\&quot;foo\&quot;&quot;)
      
&quot;'foo'&quot;

&quot;&quot;&quot;
  
def convert(&amp;#8230;)
  
</code></pre>

<h2 id="custom-sigils">Custom sigils</h2>

<p>이번 챕터의 시작부분에서 준 힌트처럼, elixir의 sigil은 확장성이 있다. 사실, ~r/foo/i와 같은 sigil은 바이너리와 문자리스트를 매개변수로 사용하는 sigil_r 함수를 호출하는 것과 동등하다.</p>

<pre><code>  
iex&gt; sigil_r(&lt;&gt;, 'i')
  
~r&quot;foo&quot;i
  
</code></pre>

<p>우리는 sigil_r 함수를 통해, ~r sigil에 대한 문서에 접근할 수 있다.</p>

<pre><code>  
iex&gt; h sigil_r
  
&amp;#8230;
  
</code></pre>

<p>우리는 또한 sigil_{identifier} 패턴을 따르는 함수를 작성해서 우리 자신의 sigil을 만들 수도 있다. 예를 들어, 정수를 반환하는(음수를 만들기 위해 선택적으로 n 변경자를 갖는) ~i sigil을 만들어 보자.</p>

<pre><code>  
iex&gt; defmodule MySigils do
  
&amp;#8230;&gt; def sigil\_i(string, []), do: String.to\_integer(string)
  
&amp;#8230;&gt; def sigil\_i(string, [?n]), do: -String.to\_integer(string)
  
&amp;#8230;&gt; end
  
iex&gt; import MySigils
  
iex&gt; ~i(13)
  
13
  
iex&gt; ~i(42)n
  
-42
  
</code></pre>

<p>sigil은 매크로의 도움을 받아 컴파일 타임에 사용될 수 있다. 예를 들어, elixir의 정규 표현식이 소스코드의 컴파일 동안 컴파일된다면, 런타임에 이런 단계가 생략될 수 있다. 이 주제에 관심이 있다면, 매크로에 대해 더 자세히 배우길 권장하며, sigil이 Kernel 모듈(sigil_* 함수가 정의된 곳)에서 어떻게 구현되어 있는지 살펴볼 것을 권장한다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/sigils.html#strings%2C-char-lists-and-words-sigils">Elixir Sigils</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-19T00:00:00Z">
            19 Jun 2015
        </time>
    </footer>
</article>

	

	<nav class="pagination" role="navigation">
	
	    <a class="newer-posts" href="/posts/page/5/">&larr; Newer Posts</a>
	
	<span class="page-number">Page 6 of 20</span>
	
	    <a class="older-posts" href="/posts/page/7/">Older Posts &rarr;</a>
	
</nav>

</main>



    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">Erlang &amp; Go</a> </section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://jeidee.github.iojs/jquery.js"></script>
    <script type="text/javascript" src="https://jeidee.github.iojs/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://jeidee.github.iojs/index.js"></script>

</body>
</html>

