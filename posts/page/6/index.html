<!DOCTYPE html>
<html lang="ko-kr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Erlang &amp; Go </title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.51" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    
      <link href="https://jeidee.github.io/posts/index.xml" rel="alternate" type="application/rss+xml" title="Erlang &amp; Go" />
      <link href="https://jeidee.github.io/posts/index.xml" rel="feed" type="application/rss+xml" title="Erlang &amp; Go" />
    

    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://jeidee.github.io/posts/" />
<meta property="og:updated_time" content="2015-08-31T00:00:00&#43;00:00"/>

<meta itemprop="name" content="Posts">
<meta itemprop="description" content="">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://jeidee.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Erlang &amp; Go
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
  <main class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></main>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/08/31/go-buffered-channleec9d84-ec9db4ec9aa9ed959c-concurrent-queue-eab5aced9884" class="link black dim">
        go buffered channel을 이용한 Concurrent Queue 구현
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      이전 포스트에서는 cotainer/list와 sync/mutex를 사용해서 Concurrent Queue를 구현해 보았다.
해당 큐의 단점은 Multi-Goroutine 동기화를 위해 Mutex를 사용하면서 비용이 발생하고,
Pop()함수를 사용할 경우 값이 없을 경우에도 즉시 리턴을 하기 때문에,
외부 모듈에서는 큐에서 값을 가져오기 위해 계속해서 Pop()함수를 호출해야 하는 비용이 발생했다.
이러한 단점을 보완하기 위해 go에서 제공하는 buffered channel을 사용해 다음과 같이 구현할 수 있다.
 package queue import ( &quot;sync/atomic&quot; ) type ChanQueue struct { syncChan chan interface{} size int32 } func NewChanQueue(maxSize int) *ChanQueue { return &amp;ChanQueue{syncChan: make(chan interface{}, maxSize)} } func (q *ChanQueue) Push(v interface{}) { atomic.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/08/31/go-console-progress-bar" class="link black dim">
        go console progress bar
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      console에서 진행 상태를 프로그레스바 형태로 출력하고자 할 때 다음 패키지를 사용할 수 있다.
 https://github.com/cheggaaa/pb  사용법은 다음과 같이 간단하다.
 package main import ( &quot;github.com/cheggaaa/pb&quot; &quot;time&quot; ) func main() { count := 100000 bar := pb.StartNew(count) for i := 0; i &lt; count; i++ { bar.Increment() time.Sleep(time.Millisecond) } bar.FinishPrint(&quot;The End!&quot;) }  console에서 프로그레스바를 출력하는 기능의 핵심은,
고정된 위치에 문자열을 출력하는 것이라 할 수 있다.
(보통 Print()문을 사용할 경우 커서가 계속 이동하며 \r\n을 만나면 다음 줄의 처음으로 커서를 이동)
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/08/26/go-containterlisteba5bc-ec82acec9aa9ed959c-concurrent-queue" class="link black dim">
        go containter/list를 사용한 Concurrent Queue
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      참고자료  Stack and Queue in golang   container/list와 sync.Mutex를 사용한 쓰레드(고루틴)에 안전한 Queue는 다음과 같이 만들 수 있다.
 package queue import ( &quot;container/list&quot; &quot;sync&quot; ) type Queue struct { l *list.List lock sync.Mutex } func NewQueue() *Queue { return &amp;Queue{list.New(), sync.Mutex{}} } func (q *Queue) Push(i interface{}) { q.lock.Lock() defer q.lock.Unlock() q.l.PushBack(i) } func (q *Queue) Pop() (interface{}, bool) { q.lock.Lock() defer q.lock.Unlock() if q.l.Len() == 0 { return nil, false } v := q.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/08/25/erlang-ec8998ec9790ec849c-observereba5bc-ec82acec9aa9ed95b4-ec9b90eab2a9-eb85b8eb939c-eca091ec868d" class="link black dim">
        erlang 쉘에서 observer를 사용해 원격 노드 접속
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      먼저 A와 B, 두 노드가 있고, A에서 B노드에 연결한다고 가정한다.
두 노드를 연결하기 위해서는 다음 조건을 우선 만족시켜야 한다.
1) short name을 사용하는 경우
 A와 B노드는 동일한 네트워크에 있고, 방화벽을 통하지 않는다.
 방화벽을 통해 접속할 경우 B노드의 다음 TCP포트(아래 예에서는 47242)가 Inbound 오픈되어 있어야 한다.
   B&gt; net_adm:names(); {ok, [{&quot;ejabberd&quot;, 47242}, &amp;#8230;]}   A와 B노드의 erlang secretkey(cookie)는 동일해야 한다.   $ erl -sname A@node1 -setcookie secret $ erl -sname B@node2 -setcookie secret A&gt; erlang:get_cookie().
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/08/25/go-json-eb9494ecbd94eb8d94eba5bc-ec82acec9aa9ed95b4ec849c-tcp-ec8aa4ed8ab8eba6bcec9cbceba19c-ec8898ec8ba0ed959c-json-object-ecb298eba6aced9598" class="link black dim">
        go json 디코더를 사용해서 TCP 스트림으로 수신한 json object 처리하기
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      우선 net.Conn 인스턴스(c.conn은 net.Conn 인스턴스)를 사용해서 json 디코더를 생성한다.
 d := json.NewDecoder(c.conn)  수신받은 데이터를 json 오브젝트로 디코딩한다.
 var packet map[string]interface{} err := d.Decode(&amp;packet)  json 오브젝트를 특정 구조체 데이터로 캐스팅한다.
그 전에 송수신 하는 json 오브젝트에 id필드가 있다고 가정하며,
id필드 값에 따라 다른 구조체로 캐스팅하도록 한다.
 type ReqLoginPacket struct { Id int \`json:&quot;id&quot;\` UserId string \`json:&quot;user_id&quot;\` } pid := int(p[&quot;id&quot;].(float64)) switch pid { case 1: reqPacket := new(ReqLoginPacket) MapToObject(packet, reqPacket) &amp;#8230; }  MapToObject/2 함수는 다음과 같다.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/08/19/go-tcp-json-decoder-ec82acec9aa9ed9598eab8b0" class="link black dim">
        go tcp &#43; json decoder 사용하기
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      다음 코드는 클라이언트에서 보낸 json 패킷을 디코딩하는 간단한 tcp 서버 예제코드이다.
 package main import ( &quot;encoding/json&quot; &quot;log&quot; &quot;net&quot; ) func main() { ln, err := net.Listen(&quot;tcp&quot;, &quot;:9080&quot;) if err != nil { log.Fatal(err) return } defer ln.Close() for { c, err := ln.Accept() if err != nil { log.Fatalln(&quot;Can't accept new client!&quot;, err) return } defer c.Close() go requestHandler(c) } } type Packet struct { Id int16 \`json:&quot;id&quot;\` Data interface{} \`json:&quot;data&quot;\` } func requestHandler(c net.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/08/19/go-gtk-ec84a4ecb998" class="link black dim">
        go-gtk 설치
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      golang을 사용해서 gui 프로그래밍을 하려면 go-gtk를 설치하면 된다.
go-gtk는 libgtk+ 2.0을 필요로 하는데,
ubuntu에서 libgtk+ 2.0은 다음과 같이 설치할 수 있다.
 $ sudo apt-get install libgtk2.0-dev $ go get github.com/mattn/go-gtk/gtk  
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/07/24/erlang-mumble-server-maunder" class="link black dim">
        erlang mumble server &amp;#8211; maunder
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      erlang으로 구현된 mumble서버 중에 maunder라고 있다.
2년전 커밋이 마지막이다.
erlang 17버전에서 빌드하고 실행하면 application:start()할 때 오류가 발생한다.
원인은 erlang 17버전에서 public_key application이 asn1을 의존하기 때문인데,
maunder.erl 소스를 다음과 같이 수정하고 다시 빌드하면 문제가 해결된다.
 %% @spec start() -&gt; ok %% @doc Start the maunder server. start() -&gt; ensure_started(sasl), ensure_started(crypto), ensure_started(asn1), ensure\_started(public\_key), ensure_started(ssl), application:start(maunder).  기동시 eaddrinuse 관련 에러가 발생하는 경우,
maunder_app.erl의 DEF_PORT값(기본값은 8080)을 변경한 후 다시 빌드하면 된다.
매번 포트를 변경할 때마다 재빌드하는게 번거로울 경우 빌드후 생성되는 ebin/maunder.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/07/23/ejabberd-ec9ab0ebb684ed88acec9790ec849c-fqdnec9d84-ec82acec9aa9ed95b4-long-node-nameec9d84-ec84a4eca095ed95a0-eb958c-cant-set-long-node-name-ec9790" class="link black dim">
        ejabberd 우분투에서 FQDN을 사용해 long node name을 설정할 때, Can&amp;#8217;t set long node name 에러 발생하는 경우
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      제목과 같이 우분투에서 long node name을 사용해 ejabberd(erlang) 노드를 사용할 경우,
ejabberdctl의 status, debug등의 명령을 실행하면 다음과 같은 에러가 발생하는 경우가 있다.
 &quot;Can't set long node name!nPlease check your configurationn&quot;,[]}  예를 들어, 노드명을 ejabberd@hello.world.com 으로 사용할 경우 다음과 같이 hostname을 확인해 본다.
 $ sudo hostname  hostname이 hello.world.com으로 설정되어 있어야 한다.
만약, 제대로 설정되어 있지 않은 경우 다음과 같이 설정한다.
 $ sudo hostname hello.world.com  영구적으로 사용하고자 한다면 /etc/hostname의 값도 수정해야 한다.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/25/ejabberdec9980-riak-ec97b0eb8f99" class="link black dim">
        ejabberd와 riak 연동
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      ejabberd 설치 ejabberd에 riak를 활성화해서 설치하는 방법은 이전 포스트를 참고해서 설치한 후, 공식 문서를 참고해서 설정한다.
riak 설치 riak 설치방법은 여러 방법이 있지만 ubuntu에서 간단히 다음 방법을 사용해 설치한다.
 wget http://s3.amazonaws.com/downloads.basho.com/riak/2.1/2.1.1/ubuntu/precise/riak\_2.1.1-1\_amd64.deb sudo dpkg -i riak\_2.1.1-1\_amd64.deb  riak 주요 파일 위치 위와 같이 설치되면 다음의 디렉토리에 주요 파일들이 위치하게 된다.
1) 실행파일
/usr/sbin/riak
/usr/sbin/riak-admin
/usr/sbin/riak-debug
2) 설정파일
/etc/riak/riak.conf
3) 로그파일
/var/log/riak/console.log
/var/log/riak/crash.log
/var/log/riak/error.log
/var/log/riak/erlang.log
/var/log/riak/run_erl.log
riak 실행 확인 설치가 완료되면 다음과 같이 riak를 시작한다.
    </div>
  </div>
</div>
</div>
      
    </section>

<ul class="pagination">
    
    <li class="page-item">
        <a href="/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item">
    <a href="/posts/page/5/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/2/">2</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/3/">3</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item disabled"><span aria-hidden="true">&nbsp;&hellip;&nbsp;</span></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/5/">5</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/posts/page/6/">6</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/7/">7</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item disabled"><span aria-hidden="true">&nbsp;&hellip;&nbsp;</span></li>
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/20/">20</a></li>
    
    
    <li class="page-item">
    <a href="/posts/page/7/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/posts/page/20/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>
</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://jeidee.github.io/" >
    &copy; 2018 Erlang &amp; Go
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
