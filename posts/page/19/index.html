<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" Posts &middot;  Erlang &amp; Go" />
  	<meta property="og:site_name" content="Erlang &amp; Go" />
  	<meta property="og:url" content="https://jeidee.github.io/posts/" />
    
    
    <meta property="og:type" content="website" />
    

  <title>
     Posts &middot;  Erlang &amp; Go
  </title>

    <meta name="description" content="" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://jeidee.github.ioimages/favicon.ico">
	  <link rel="apple-touch-icon" href="https://jeidee.github.ioimages/apple-touch-icon.png" />
    
    <link rel="stylesheet" type="text/css" href="https://jeidee.github.iocss/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
      
          <link href="https://jeidee.github.ioindex.xml" rel="alternate" type="application/rss+xml" title="Erlang &amp; Go" />
      
      
        <link href="https://jeidee.github.io/posts/index.xml" rel="alternate" type="application/rss+xml" title="Posts &middot; Erlang &amp; Go" />
      
    
    <meta name="generator" content="Hugo 0.31.1" />

    <link rel="canonical" href="https://jeidee.github.io/posts/" />

    
<div id="particles-js"></div>
<script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
<script src="https://jeidee.github.iojs/particles.js"></script>   
</head>
<body class="nav-closed">

  


 <div class="site-wrapper">




	<header class="main-header tag-head no-cover">

    <nav class="main-nav overlay clearfix">
      
      
        
          <a class="menu-button icon-feed" href="https://jeidee.github.io/posts/index.xml">&nbsp;&nbsp;Subscribe</a>
        
      
    </nav>
    <div class="vertical">

        <div class="main-header-content inner">
            <h1 class="page-title">

              <a class="btn-bootstrap-2" href="#content">Erlang &amp; Go</a>
          </h1>
        </div>
</div>
    <a class="scroll-down icon-arrow-left" href="#content"><span class="hidden">Scroll Down</span></a>
</header>

<main id="content" class="content" role="main">
    

	<div class="extra-pagination inner">
    <nav class="pagination" role="navigation">
	
	    <a class="newer-posts" href="/posts/page/18/">&larr; Newer Posts</a>
	
	<span class="page-number">Page 19 of 20</span>
	
	    <a class="older-posts" href="/posts/page/20/">Older Posts &rarr;</a>
	
</nav>

	</div>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/01/21/erlang-1ebb0b1eba78c-tcp-eb8f99ec8b9c-eca091ec868d-ecb298eba6ac/">erlang 1백만 tcp 동시 접속 처리</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p><a href="http://www.erlang-factory.com/upload/presentations/558/efsf2012-whatsapp-scaling.pdf">http://www.erlang-factory.com/upload/presentations/558/efsf2012-whatsapp-scaling.pdf</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        
        <time class="post-date" datetime="2015-01-21T00:00:00Z">
            21 Jan 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/01/21/erlang-game-server-programming/">erlang game server programming</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p><a href="http://www.diva-portal.org/smash/get/diva2:641311/FULLTEXT01.pdf">http://www.diva-portal.org/smash/get/diva2:641311/FULLTEXT01.pdf</a></p>

<p><a href="http://www.erlang-factory.com/upload/presentations/395/ErlangandFirst-PersonShooters.pdf">http://www.erlang-factory.com/upload/presentations/395/ErlangandFirst-PersonShooters.pdf</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        
        <time class="post-date" datetime="2015-01-21T00:00:00Z">
            21 Jan 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/01/21/erlang-key-value-ed8a9ced948c-eba6acec8aa4ed8ab8ec9790ec849c-keyeba19c-value-ecb0beeab8b0/">erlang key-value 튜플 리스트에서 key로 value 찾기</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p>proplists 모듈의 get_value/2를 사용하면 된다.</p>

<pre><code class="language-erlang">      
proplists:get_value(Key, List).
  
</code></pre>

<p>예를 들어 다음과 같이 과일의 수량정보를 갖는 리스트가 있다고 하자.</p>

<pre><code class="language-erlang">      
List = [{apple, 10}, {orange, 20}].
  
</code></pre>

<p>위 리스트에서 apple을 key로 사용해서 apple의 개수를 얻으려면 다음과 같이 하면 된다.</p>

<pre><code class="language-erlang">      
proplists:get_value(apple, List).
  
</code></pre>

<p>튜플 자체를 구하고자 한다면 다음과 같이 한다.</p>

<pre><code class="language-erlang">      
proplists:lookup(apple, List).
  
</code></pre>

<p>get_value/2와 lookup/2은 매치하는 튜플 중에서 첫 번째 엔트리만 반환하기 때문에 모두 찾고자 한다면 get_all_values/2나 lookup_all/2을 사용해야 한다. 단 결과는 리스트로 반환된다.</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        
        <time class="post-date" datetime="2015-01-21T00:00:00Z">
            21 Jan 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/01/21/erlang-otp-eb9494ec9e90ec9db8-ecbba8ec8589/">erlang otp 디자인 컨셉</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<h2 id="supervision-tree">supervision tree</h2>

<p>erlang otp 디자인 컨셉의 기본은 supervision tree이다.</p>

<p>supervision tree는 supervisor(감독 프로세스)와 worker(실제 업무 수행 프로세스) 기반으로 모델링한 프로세스 구조이다.</p>

<ul>
<li>worker는 계산 등의 실제 업무를 수행하는 프로세스이다.</li>
<li>supervisor는 worker의 행동을 모니터하는 프로세스이며 worker에 이상을 감지하면 worker를 재시작할 수 있다.</li>
<li>supervision tree는 worker와 supervisor의 계층적인 구조를 갖고, 내고장성(fault-tolerant) 소프트웨어 디자인을 가능케 한다.</li>
</ul>

<blockquote>
<p><img src="http://www.erlang.org/doc/design_principles/sup6.gif" alt="Supervision Tree" /></p>
</blockquote>

<p>위 그림은 Supervision Tree이며 박스는 supervisor를, 원은 worker를 나타낸다.</p>

<h2 id="behaviours">behaviours</h2>

<p>supervision tree에서 대부분의 프로세스는 동일한 패턴에 동일한 구조를 갖는다. supervisor는 자식 프로세스를 감독하는 프로세스이고 worker는 대부분 서버-클라이언트 관계에서 서버에 해당한다.</p>

<p><strong>behaviour</strong>는 이러한 일반 패턴을 형식화한 것이다. 이 아이디어는 코드를 일반 파트(generic part &#8211; behaviour module)와 구체 파트(specific part &#8211; callback module)로 나눈다.</p>

<p>behaviour 모듈은 Erlang/OTP의 일부이며 supervisor를 구현하려면 미리 정의되어 export된 callback function을 구현하면 된다.</p>

<p>예제를 통해 살펴보도록 하자.</p>

<p>다음 예제는 많은 채널을 관리하는 간단한 server를 구현한다.</p>

<pre><code class="language-erlang">      
-module(ch1).
      
-export([start/0]).
      
-export([alloc/0, free/1]).
      
-export([init/0]).

start() -&gt;
          
spawn(ch1, init, []).

alloc() -&gt;
          
ch1 ! {self(), alloc},
          
receive
              
{ch1, Res} -&gt;
                  
Res
          
end.

free(Ch) -&gt;
          
ch1 ! {free, Ch},
          
ok.

init() -&gt;
          
register(ch1, self()),
          
Chs = channels(),
          
loop(Chs).

loop(Chs) -&gt;
          
receive
              
{From, alloc} -&gt;
                  
{Ch, Chs2} = alloc(Chs),
                  
From ! {ch1, Ch},
                  
loop(Chs2);
              
{free, Ch} -&gt;
                  
Chs2 = free(Ch, Chs),
                  
loop(Chs2)
          
end.
  
</code></pre>

<p>위의 코드에서 channels/0, alloc/1, free/2 함수는 생략되어 있음을 참고하자.</p>

<p>해당 코드는 아래에 추가해 놓았으니 실습을 할 때는 해당 코드를 내부함수로 소스에 포함하도록 한다.</p>

<p>간단히 코드를 살펴보면 다음과 같다.</p>

<ul>
<li>start/0 함수를 사용해 서버를 시작한다.</li>
<li>start/0 함수에서는 ch1 모듈의 init함수를 매개변수 없이 호출해 프로세스를 생성한다.(spawn)</li>
<li>init/0 함수에서는 현재 프로세스(self())의 pid를 ch1 애텀에 등록하고, 현재의 채널리스트를 channels/0 함수로 구해 초기 상태로 loop/1 함수에 넘겨준다.</li>
<li>loop/1 함수에서는 현재 프로세스에서 메세지를 수신하도록 대기(동기)하는데 {From, alloc}이나 {free, Ch} 패턴의 메세지만 처리할 수 있다.</li>
<li>{From, alloc} 메세지를 수신하면 alloc/1 함수를 사용해 현재 채널리스트에서 신규 채널을 할당(Ch)하고 메세지를 전송한 프로세스에 {ch1, Ch} 메세지를 전송한 후, 새로운 상태(채널리스트 &#8211; Chs2)를 넘겨주어 loop를 지속시킨다.</li>
<li>{free, Ch} 메세지를 수신하면 해당 채널(Ch)를 free/2 함수로 해제하고, 새로운 상태(Chs2)를 loop/1 함수에 넘겨주어 loop를 지속시킨다.</li>
</ul>

<p>ch1.erl 모듈은 서버코드(start/0, init/0)와 클라이언트코드(alloc/0, free/1)를 모두 포함하고 있다.</p>

<p>서버를 시작할 경우 다음과 같이 실행한다.</p>

<pre><code class="language-erlang">      
&gt; ch1:start().
  
</code></pre>

<p>클라이언트를 테스트할 경우 다음과 같이 실행한다.</p>

<pre><code class="language-erlang">      
&gt; Ch = ch1:alloc().
      
&gt; ch1:free(Ch).
  
</code></pre>

<p>위 ch1 모듈을 otp 디자인에 맞게 다음과 같은 절차로 수정해 보도록 하자.</p>

<h3 id="1-generic-part에-해당하는-server-erl-코드를-생성한다">1) generic part에 해당하는 server.erl 코드를 생성한다.</h3>

<pre><code class="language-erlang">      
-module(server).
      
-export([start/1]).
      
-export([call/2, cast/2]).
      
-export([init/1]).

start(Mod) -&gt;
          
spawn(server, init, [Mod]).

call(Name, Req) -&gt;
          
Name ! {call, self(), Req},
          
receive
              
{Name, Res} -&gt;
                  
Res
          
end.

cast(Name, Req) -&gt;
          
Name ! {cast, Req},
          
ok.

init(Mod) -&gt;
          
register(Mod, self()),
          
State = Mod:init(),
          
loop(Mod, State).

loop(Mod, State) -&gt;
          
receive
              
{call, From, Req} -&gt;
                  
{Res, State2} = Mod:handle_call(Req, State),
                  
From ! {Mod, Res},
                  
loop(Mod, State2);
              
{cast, Req} -&gt;
                  
State2 = Mod:handle_cast(Req, State),
                  
loop(Mod, State2)
          
end.
  
</code></pre>

<p>generic part는 behaviour에 해당하고 callback function은 handle_call/2와 handle_cast/2에 해당한다.</p>

<p>call/2과 cast/2함수는 클라이언트 함수이며 ch1.erl 모듈에서 alloc/0과 free/1에 매치되는 함수인데 server모듈의 behaviour가 call/2, cast/2로 일반화 되었기 때문에 실제 callback 함수를 구현하는 구현 파트에서 해당 기능이 명확(specific)해 지게 된다.</p>

<h3 id="2-specific-part에-해당하며-callback-모듈인-ch2-erl을-작성한다">2) specific part에 해당하며 callback 모듈인 ch2.erl을 작성한다.</h3>

<pre><code class="language-erlang">      
-module(ch2).
      
-export([start/0]).
      
-export([alloc/0, free/1]).
      
-export([init/0, handle\_call/2, handle\_cast/2]).

start() -&gt;
          
server:start(ch2).

alloc() -&gt;
          
server:call(ch2, alloc).

free(Ch) -&gt;
          
server:cast(ch2, {free, Ch}).

init() -&gt;
          
channels().

handle_call(alloc, Chs) -&gt;
          
alloc(Chs). % =&gt; {Ch,Chs2}

handle_cast({free, Ch}, Chs) -&gt;
          
free(Ch, Chs). % =&gt; Chs2
  
</code></pre>

<p>실제 로직은 구현 파트에 해당하는 callback 모듈에 포함된다.</p>

<p>handle_call/2과 handle_cast/2는 server 모듈에 의해 호출되는 callback function으로 각각 alloc/1과 free/2 함수를 실제 호출해 처리하게 된다.</p>

<p>위의 예제에서 알 수 있는 것은 다음과 같다.</p>

<ul>
<li>server 모듈의 코드는 많은 다른 서버에서 재사용될 수 있는 일반적인 코드이다.</li>
<li>서버의 이름을, 이 예제에서는 ch2, 클라이언트 함수를 사용하는 유저에게 숨길 수 있다. 이 것이 의미하는 것은 이름이 외부에 영향을 주지 않고 바뀔수 있음을 나타낸다.</li>
<li>프로토콜(서버로부터 주고 받는 메세지들)을 잘 숨길 수 있다. 이 것은 실전 프로그래밍에 유용하고 인터페이스 함수를 사용하는 코드를 변경하지 않고 프로토콜을 변경할 수 있게 해 준다.</li>
<li>우리는 ch2나 다른 콜백 모듈을 변경하지 않고, 서버를 기능적으로 확장할 수 있다.</li>
</ul>

<p>behaviour를 사용하지 않고 더 효율적으로 코드를 작성할 수 있을지도 모르지만, 증가된 효율성은 일반화에 대한 비용으로 지불될 것이다. 시스템에서 일관된 방법을 통해 모든 어플리케이션을 관리할 수 있도록 하는 능력은 매우 중요하다.</p>

<p>behaviour를 사용하는 것은 다른 프로그래머들이 코드를 이해하고 읽기 쉽도록 해 준다. 즉흥적이고 임시변통인(Ad-hoc) 프로그래밍은 효율을 좀더 올려 줄 수 있겠지만 항상 이해하기 어렵게 만든다.</p>

<p>위의 server 모듈은, Erlang/OTP behaviour인 gen_server 모듈과 일치한다.</p>

<p>표준 Erlang/OTP behaviour는 다음과 같다.</p>

<ul>
<li>gen_server : client-server에서 server를 구현하는데 사용</li>
<li>gen_fsm : 유한 상태 기계를 구현할 때 사용</li>
<li>gsn_event : 이벤트 핸들링을 구현할 때 사용</li>
<li>supervisor : supervision tree에서 supervisor를 구현할 때 사용</li>
</ul>

<p>컴파일러는 behaviour(Behaviour) 구문을 이해하고 callback 함수를 구현하지 않을 경우 다음과 같이 경고를 발생시킨다.</p>

<pre><code class="language-erlang">      
-module(chs3).
      
-behaviour(gen_server).
      
&amp;#8230;

3&gt; c(chs3).
      
./chs3.erl:10: Warning: undefined call-back function handle_call/3
      
{ok,chs3}
  
</code></pre>

<h2 id="applications">applications</h2>

<p>Erlang/OTP는 각각이 특정한 기능을 수행하는 많은 컴포넌트로 구성되어 있다. 컴포넌트는 Elang/OTP에서 applications란 용어로 불린다. Erlang/OTP applications의 예로는 Mnesia, Debugger를 들 수 있다. Erlang/OTP 기반의 최소한의 시스템은 Kernel과 STDLIB application으로 구성한다.</p>

<p>application 컨셉은 program 구조인 process와 directory 구조인 module 모두에 적용된다.</p>

<p>가장 간단한 구조의 application은 process 없이 module로만 구성할 수 있다. 그런 application을 library application이라고 부른다. library application의 예는 STDLIB를 들 수 있다.</p>

<p>process를 포함하는 application은 표준 behaviour를 사용해서 supervision tree로 가장 간단하게 구현할 수 있다.</p>

<p>application을 프로그래밍하는 방법은 <a href="http://www.erlang.org/doc/design_principles/applications.html">Applications</a>를 참고하도록 한다.</p>

<h2 id="releases">releases</h2>

<p>release는 Erlang/OTP application의 서브셋과 user가 구현한 application의 셋으로 구성된 완전한 시스템을 말한다.</p>

<p>release와 관련된 자세한 내용은 <a href="http://www.erlang.org/doc/design_principles/release_structure.html">Releases</a>를 참고하도록 한다.</p>

<p>타겟 환경에 release를 설치하는 방법은 System Principles의 Target Systems에 기술되어 있다.</p>

<h2 id="release-handling">release handling</h2>

<p>release handling은 release의 업그레이드와 다운그레이드와 관련된 내용을 포함한다.</p>

<p>이와 관련된 자세한 내용은 <a href="http://www.erlang.org/doc/design_principles/release_handling.html">Release Handling</a>을 참고하도록 한다.</p>

<h2 id="reference">reference</h2>

<ul>
<li><a href="http://www.erlang.org/doc/design_principles/des_princ.html">Erlang OTP Design Overview</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        
        <time class="post-date" datetime="2015-01-21T00:00:00Z">
            21 Jan 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/01/21/erlang-timestamp-ec96bbeab8b0/">erlang timestamp 얻기</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p>os모듈의 timestamp/0 함수를 사용한다.</p>

<pre><code class="language-erlang">      
{MegaSecs, Secs, MicroSecs} = os:timestamp().
  
</code></pre>

<p>MegaSecs는 seconds의 (1000 * 1000)배이다.</p>

<p>위의 결과값을 milliseconds로 변환하기 위해서는 microseconds를 구해서 1000으로 나눠줘야 한다.</p>

<pre><code class="language-erlang">      
((MegaSecs\*1000000 + Secs) \* 1000000 + MicroSecs)/1000.
  
</code></pre>

<p>소숫점 이하를 버리고자 한다면 div 연산을 사용해서 몫만 구하면 된다.</p>

<pre><code class="language-erlang">      
((MegaSecs\*1000000 + Secs) \* 1000000 + MicroSecs) div 1000.
  
</code></pre>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        
        <time class="post-date" datetime="2015-01-21T00:00:00Z">
            21 Jan 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/01/21/erlang-ebacb8ec9e90ec97b4-ed8faceba7b7-ed9b84-binaryeba19c-ebb380ed9998/">erlang 문자열 포맷 후 binary로 변환</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p>c의 sprintf() 같은 문자열 포맷 함수인 io_lib:format()을 사용하면 &#8220;Count : 10&#8221; 과 같은 문자열을 binary로 만들 수 있다.</p>

<pre><code class="language-erlang">      
Count = 20.
      
Result = io_lib:format(&quot;Count : ~p&quot;, [Count]).
      
Bin = binary:list\_to\_bin(Result).
  
</code></pre>

<p>또는 간략하게 다음과 같이 줄일 수도 있다.</p>

<pre><code class="language-erlang">      
Bin = binary:list\_to\_bin(io_lib:format(&quot;Count : ~p&quot;, [Count]).
  
</code></pre>

<p>erlang에서 문자열이 곧 리스트이기 때문에 binary 모듈의 list_to_bin()함수의 매개변수로 리스트 대신 문자열을 입력해도 된다.</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        
        <time class="post-date" datetime="2015-01-21T00:00:00Z">
            21 Jan 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/01/21/erlang-ebacb8ec9e90ec97b4-ed8faceba7b7ed8c85/">erlang 문자열 포맷팅</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <p>문자열 포맷하기 위해서는 io_lib:format/2 함수를 사용하면 된다.</p>

<p>하지만 다음과 같이 바로 사용할 수 없는 형태이다.</p>

<pre><code class="language-erlang">      
17&gt; Str = io_lib:format(&quot;name=~p&amp;age=~p&quot;, [&quot;romeo&quot;, 10]).
      
[110,97,109,101,61,&quot;\&quot;romeo\&quot;&quot;,38,97,103,101,61,&quot;10&quot;]
      
18&gt; Str.
      
[110,97,109,101,61,&quot;\&quot;romeo\&quot;&quot;,38,97,103,101,61,&quot;10&quot;]
      
19&gt;
  
</code></pre>

<p>이럴 경우 lists모듈의 flatten/1 함수를 사용한다.</p>

<pre><code class="language-erlang">      
19&gt; Result = lists:flatten(Str).
  
&quot;name=\&quot;romeo\&quot;&amp;age=10&quot;
  
</code></pre>

<p>한 줄로 줄여서 다음과 같이 사용해도 된다.</p>

<pre><code class="language-erlang">      
20&gt; lists:flatten(io_lib:format(&quot;name=~p&amp;age=~p&quot;, [&quot;romeo&quot;, 10])).
      
&quot;name=\&quot;romeo\&quot;&amp;age=10&quot;
  
</code></pre>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        
        <time class="post-date" datetime="2015-01-21T00:00:00Z">
            21 Jan 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/01/21/erlang-ec84a4ecb998/">erlang 설치</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<h1 id="erlang-otp-설치">erlang/otp 설치</h1>

<h2 id="준비">준비</h2>

<p>우선 git repository에서 clone합니다.</p>

<pre><code>      
git clone git://github.com/erlang/otp.git
  
</code></pre>

<p>ubuntu : aptitude는 다음과 같이 설치합니다.</p>

<pre><code>      
sudo apt-get install aptitude
  
</code></pre>

<p><strong>erlang/otp의 기본 설치를 원할 경우</strong></p>

<p>ubuntu</p>

<pre><code>      
aptitude install autoconf libncurses-dev build-essential
  
</code></pre>

<p>centos 6.*</p>

<pre><code>      
yum install ncurses-devel
  
</code></pre>

<p><strong>wxWidgets과 함께 설치를 원할 경우</strong></p>

<pre><code>      
aptitude install libwxgtk2.8-dev libgl1-mesa-dev libglu1-mesa-dev libpng3
  
</code></pre>

<p><strong>jinterface와 함께 설치를 원할 경우</strong></p>

<pre><code>      
aptitude install sun-java6-jre sun-java6-jdk sun-java6-bin
  
</code></pre>

<p><strong>다른 c++ 프로젝트와 함께 설치를 원할 경우</strong></p>

<pre><code>      
sudo aptitude install g++
  
</code></pre>

<h2 id="컴파일">컴파일</h2>

<p>컴파일 하기 전에 $ERL_TOP과 $PATH 환경변수를 다음과 같이 설정해 줍니다.</p>

<pre><code>      
cd otp
      
\# Bourne Shell
      
export ERL_TOP=$PWD
      
export PATH=$ERL_TOP/bin:$PATH
      
\# C Shell
      
setenv ERL_TOP $PWD
      
setenv PATH $ERL_TOP/bin:$PATH
  
</code></pre>

<p>repository에는 configure 파일이 없으므로 다음과 같이 생성해 줍니다.</p>

<pre><code>      
./otp_build autoconf
  
</code></pre>

<p>다음과 같이 make합니다.</p>

<pre><code>      
./configure
      
make &amp; make install
  
</code></pre>

<p>이 외에 추가 내용은 다음 링크를 참고해 주세요.</p>

<p><a href="https://github.com/erlang/otp/wiki/Installation">https://github.com/erlang/otp/wiki/Installation</a></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/otp/">#otp</a>,
            
        
        <time class="post-date" datetime="2015-01-21T00:00:00Z">
            21 Jan 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/01/21/erlang-ec9d98-caseec9980-if/">erlang 의 case와 if</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<p>erlang에서는 조건 분기문에 해당하는 case와 if가 다른 언어와는 형태가 조금 다르다.</p>

<p>처음 보면 어떻게 사용해야 할지 감이 오지 않는데, 알고 보면 다른 언어와 크게 다르지도 않다는 것을 알 수 있다.</p>

<p>erlang의 if와 case는 가드(guard)를 이용한 구문으로 되어 있는데, if와 case를 살펴보기 전에 먼저 가드를 간략히 살펴보자.</p>

<h2 id="guard">guard</h2>

<p>가드는 true와 false 애텀으로 평가받는 식이며 다음과 같은 형식으로 사용할 수 있다.</p>

<pre><code class="language-erlang">      
max(X, Y) when X &gt; Y -&gt; X;
      
max(X, Y) -&gt; Y.
  
</code></pre>

<p>위 예제는 max(X, Y) 함수를 구현한 코드인데 when X &gt; Y -&gt; X; 부분이 가드 시퀀스에 해당한다.</p>

<p>가드 시퀀스는 가드와 가드 평가식의 조합을 의미하며,</p>

<p>X &gt; Y가 가드, -&gt; X가 가드 평가식이 된다.</p>

<p>여러 가드가 and로 조합해야 할 때는 쉼표(,)로 구분하며, 가드 시퀀스가 복수개일 경우에는 세미콜론(;)으로 가드 시퀀스를 구분한다.</p>

<h2 id="if">if</h2>

<p>if식을 살펴 보자.</p>

<pre><code class="language-erlang">      
if
          
GuardSeq1 -&gt;

Body1;
          
&amp;#8230;;
          
GuardSeqN -&gt;
              
BodyN
      
end
  
</code></pre>

<p>GuardSeq1부터 순차적으로 평가가 이뤄지며, 가드 평가로 얻어진 값이 true 애텀일 경우 해당 Body 식을 평가한 값이 if의 결과가 된다.</p>

<blockquote>
<p>평가란 식을 수행해 결과를 얻는 것을 의미한다.</p>
</blockquote>

<p>모든 가드 시퀀스를 평가해도 true가 없을 경우 if 식은 오류를 발생시키므로 다른 언어의 if ~ else 구문처럼 사용하고자 한다면 다음과 같이 작성해야 한다.</p>

<pre><code class="language-erlang">      
if
          
GuardSeq1 -&gt;
              
Body1;
          
&amp;#8230;;
          
GuardSeqN -&gt;
              
BodyN;
          
true -&gt;
              
BodyElse
      
end
  
</code></pre>

<p>모든 가드 시퀀스를 평가한 후 마지막 true 애텀이 평가되어 오류 없이 if else 처럼 동작하게 된다.</p>

<p>매 가드 시퀀스는 세미콜론(;)으로 구분하며 마지막 평가식의 경우 세미콜론 없이 입력해야 함을 주의하자.</p>

<h2 id="case">case</h2>

<p>먼저 구문을 살펴보자.</p>

<pre><code class="language-erlang">      
case Expr of
          
Pattern1 [when GuardSeq1] -&gt;
              
Body1;
          
&amp;#8230;;
          
PatternN [when GuardSeqN] -&gt;
              
BodyN
      
end
  
</code></pre>

<p>먼저 Expr 식을 평가하고 그 결과를 Pattern1부터 차례로 매치를 진행한다. 패턴 매치를 할 때는 when 가드를 써서 추가 조건을 평가할 수도 있다.</p>

<p>매치가 성공할 경우 해당 Body식을 평가하고 그 결과값이 case의 결과가 된다.</p>

<p>만약 매치하는 패턴이 없을 경우 if 식과 마찬가지로 오류가 발생한다.</p>

<p>따라서 if 식에서 else를 처리하듯이 하려면 마지막 패턴을 _ 애텀으로 매치하면 일치하는 패턴이 없다 하더라도 예외 없이 실행시킬 수 있다.</p>

<blockquote>
<p>_ 애텀은 어떤 값도 매치시킬 수 있는 애텀이다.</p>
</blockquote>

<h2 id="examples">examples</h2>

<p>다음 예제는 Msg 변수를 &#8220;OK&#8221;와 비교하는 구문을 if와 case로 구현한 코드이다.</p>

<p><strong>if</strong></p>

<pre><code class="language-erlang">      
if
          
Msg == &quot;OK&quot; -&gt;
              
io:format(&quot;This is OK&quot;);
          
true -&gt;
              
io:format(&quot;This is not OK&quot;)
      
end.
  
</code></pre>

<p><strong>case</strong></p>

<pre><code class="language-erlang">      
case Msg of
          
&quot;OK&quot; -&gt; io:format(&quot;This is OK&quot;);
          
_ -&gt; io:format(&quot;This is not OK&quot;)
      
end.
  
</code></pre>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        
        <time class="post-date" datetime="2015-01-21T00:00:00Z">
            21 Jan 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/01/21/erlangotp-application/">erlang/otp application</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<h2 id="application-concept">application concept</h2>

<p>어떤 특정 기능을 수행하는 코드를 작성할 때, 우리는 다른 시스템에서 재사용될 수 있으며, 유닛으로써 시작과 중지할 수 있는 컴포넌트인 application에 코드를 작성할 수 있길 원한다.</p>

<p>이것을 위해 Erlang/OTP에서는 application callback module을 제공한다. application이 어떻게 시작되고 중지될 수 있는지에 대해서는 application callback moudule과 함께 설명하도록 하겠다.</p>

<p>application 명세는 application resource file에 포함하는데, 해당 명세에는 application을 구성하는 모듈과 callback module의 이름이 명시되어 있다.</p>

<p>코드 패키징을 위한 Erlang/OTP 도구인 systool을 사용한다면(자세한 내용은 <a href="http://www.erlang.org/doc/design_principles/release_structure.html">Release</a>참조) , 각각의 application 코드들은 미리 정의된 디렉토리 구조(뒤에 설명함)를 따르는 구분된 디렉토리에 위치해야 한다.</p>

<h2 id="application-callback-module">application callback module</h2>

<p>application을 시작하고 중지하기 위해서는(예를 들어 supervison tree에서) 다음의 두 callback 함수가 필요하다.</p>

<pre><code class="language-erlang">      
start(StartType, StartArgs) -&gt; {ok, Pid} | {ok, Pid, State}
      
stop(State)
  
</code></pre>

<p>start/2함수는 application이 시작할때 호출되며 상위 supervisor를 시작하는 supervision tree에 의해 생성되어야 한다. start/2 함수는 top supervisor의 pid를 반환해야 하고 선택적으로 State term([] 기본값을 갖는)도 반환할 수 있다. 이 term은 stop/1 함수 매개변수로 넘겨야 한다.</p>

<p>StartType은 일반적으로 normal 애텀이 사용된다. <a href="http://www.erlang.org/doc/design_principles/distributed_applications.html">Distributed Applications</a>에서 설명된 takeover와 faileover의 경우에만 다른 값을 사용할 수 있다. StartArgs는 application resource file에 명시된 mod의 key에 의해 정의된다.</p>

<p>stop/1함수는 application이 중지된 후에 호출되며 필요한 해제절차를 수행해야 한다. 실제 application의 중지는 supervision tree가 종료될 때 자동적으로 처리되는데 자세한 내용은 뒷부분에서 자세히 설명하도록 한다.</p>

<h2 id="application-resource-file">application resource file</h2>

<p>application을 정의하기 위해서 application resource file(.app file)에 application 명세를 작성해야 한다.</p>

<pre><code class="language-erlang">      
{application, Application, [Opt1,&amp;#8230;,OptN]}.
  
</code></pre>

<p>Application 부분에는 application의 이름을 애텀으로 작성한다. 파일명은 Application.app(즉, application의 애텀명.app 형태)이어야 한다.</p>

<p>각각의 Opt는 {Key, Value} 튜플이고, application의 특정 프로퍼티를 정의한다.</p>

<p>예를 들어 library application인 libapp을 위한 최소한의 .app 파일은 다음과 같을 것이다.</p>

<pre><code class="language-erlang">      
{application, libapp, []}.
  
</code></pre>

<p>supervision tree application의 최소버전인 ch_app.app의 최소한의 내용은 다음과 같다.</p>

<pre><code class="language-erlang">      
{application, ch_app,
       
[{mod, {ch_app,[]}}]}.
  
</code></pre>

<p>mod 키는 callback module과 application의 start 매개변수를 정의한다. 이 경우에 callback module은 ch_app이고 start의 매개변수는[] 이다.</p>

<p>이것이 의미하는 바는 다음과 같다.</p>

<pre><code class="language-erlang">      
ch_app:start(normal, [])
  
</code></pre>

<p>application이 시작할 때 위와 같이 호출되고,</p>

<pre><code class="language-erlang">      
ch_app:stop([])
  
</code></pre>

<p>application이 중지될 때 위와 같이 호출된다.</p>

<p>systools를 사용해서 패키징할 때는 description, vsn, modules, registered, applications 키가 다음과 같이 명시되어야 한다.</p>

<pre><code class="language-erlang">      
{application, ch_app,
       
[{description, &quot;Channel allocator&quot;},
        
{vsn, &quot;1&quot;},
        
{modules, [ch\_app, ch\_sup, ch3]},
        
{registered, [ch3]},
        
{applications, [kernel, stdlib, sasl]},
        
{mod, {ch_app,[]}}
       
]}.
  
</code></pre>

<ul>
<li>description : 기본값을 &#8220;&#8221;로 설정할 수 있는 짧은 문자열로 된 설명</li>
<li>vsn : 기본값을 &#8220;&#8221;로 설정할 수 있는 버전 문자열</li>
<li>modules : application에서 소개될 모든 모듈들. systools는 boot scripts와 tar files를 생성할 때 이 리스트를 사용하게 된다. 모듈은 오직 하나만 정의해야 한다. 기본값은 []이다.</li>
<li>registered : application에서 등록된 process의 이름 리스트이다. systools는 이 리스트를 통해 application들 사이에서 이름 충돌을 찾는다. 기본값은 []이다.</li>
<li>applications : 이 application이 시작될 대 함께 시작되어야 하는 application의 목록이다. systools는 이 리스트를 사용해 올바른 boot scripts를 작성한다. 기본값은 []이지만, 모든 application은 최소한 kernel과 stdlib에 의존성이 있음을 알아야 한다.</li>
</ul>

<blockquote>
<p>좀더 자세한 내용은 <a href="http://www.erlang.org/doc/man/app.html">Application resource file reference</a>을 참고하도록 한다.</p>
</blockquote>

<h2 id="directory-structure">directory structure</h2>

<p>systools를 사용해 패키징할 때, 각 application의 코드는 lib/Application-Vsn의 구분된 디렉토리에 위치해야 한다.</p>

<p>systools를 사용하지 않더라도 이러한 방식은 유용하며 Erlang/OTP 자체가 이러한 OTP 원칙에 의해 패키징되어 있다. code 서버는 자동적으로 취상위 버전의 디렉토리에 있는 코드를 사용할 것이다.</p>

<p>application 디렉토리 구조는 개발환경에서도 사용할 수 있으며 이때는 버전 번호를 생략할 수 있다.</p>

<p>application 디렉토리는 다음과 같은 서브 디렉토리를 갖는다.</p>

<ul>
<li>src : erlang source code</li>
<li>ebin : erlang object code(beam files) and .app file</li>
<li>priv : application specific files(예를 들어 c 실행파일, code:priv_dir/1함수는 이 경로를 접근한다.)</li>
<li>include : includes files(.hrl)</li>
</ul>

<h2 id="application-controller">application controller</h2>

<h2 id="references">references</h2>

<ul>
<li><a href="http://www.erlang.org/doc/design_principles/applications.html#appl_res_file">Erlang/OTP Applications</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        
        <time class="post-date" datetime="2015-01-21T00:00:00Z">
            21 Jan 2015
        </time>
    </footer>
</article>

	

	<nav class="pagination" role="navigation">
	
	    <a class="newer-posts" href="/posts/page/18/">&larr; Newer Posts</a>
	
	<span class="page-number">Page 19 of 20</span>
	
	    <a class="older-posts" href="/posts/page/20/">Older Posts &rarr;</a>
	
</nav>

</main>



    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">Erlang &amp; Go</a> </section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://jeidee.github.iojs/jquery.js"></script>
    <script type="text/javascript" src="https://jeidee.github.iojs/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://jeidee.github.iojs/index.js"></script>

</body>
</html>

