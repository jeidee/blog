<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ejabberd on Erlang &amp; Go</title>
    <link>https://jeidee.github.io/categories/ejabberd/</link>
    <description>Recent content in Ejabberd on Erlang &amp; Go</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 25 Jan 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jeidee.github.io/categories/ejabberd/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ejabberd의 deps 라이브러리 수정 후 컴파일에서 누락될 때</title>
      <link>https://jeidee.github.io/2017/01/25/ejabberdec9d98-deps-eb9dbcec9db4ebb88ceb9faceba6ac-ec8898eca095-ed9b84-ecbbb4ed8c8cec9dbcec9790ec849c-eb8884eb9dbdeb90a0-eb958c/</link>
      <pubDate>Wed, 25 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2017/01/25/ejabberdec9d98-deps-eb9dbcec9db4ebb88ceb9faceba6ac-ec8898eca095-ed9b84-ecbbb4ed8c8cec9dbcec9790ec849c-eb8884eb9dbdeb90a0-eb958c/</guid>
      <description>Makefile.in을 열어 skip_deps=true 부분을 찾아 skip_deps=false로 수정하면 된다.</description>
    </item>
    
    <item>
      <title>tsung을 사용해 ejabberd 테스트하기</title>
      <link>https://jeidee.github.io/2016/06/28/tsungec9d84-ec82acec9aa9ed95b4-ejabberd-ed858cec8aa4ed8ab8ed9598eab8b0/</link>
      <pubDate>Tue, 28 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2016/06/28/tsungec9d84-ec82acec9aa9ed95b4-ejabberd-ed858cec8aa4ed8ab8ed9598eab8b0/</guid>
      <description>테스트 환경  ejabber node 1대, tsung node 1대, dabase node 1대 ulimit -n 100000  tsung.xml https://gist.github.com/jeidee/ae4cb98e609f405d5ce6b60a4b53f0fe</description>
    </item>
    
    <item>
      <title>erlang 어플리케이션 중단 없이 변경된 모듈만 리로드하기</title>
      <link>https://jeidee.github.io/2016/04/22/erlang-ec96b4ed948ceba6acecbc80ec9db4ec8598-eca491eb8ba8-ec9786ec9db4-ebb380eab2bdeb909c-ebaaa8eb9388eba78c-eba6aceba19ceb939ced9598/</link>
      <pubDate>Fri, 22 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2016/04/22/erlang-ec96b4ed948ceba6acecbc80ec9db4ec8598-eca491eb8ba8-ec9786ec9db4-ebb380eab2bdeb909c-ebaaa8eb9388eba78c-eba6aceba19ceb939ced9598/</guid>
      <description>erlang 어플리케이션이 작동 중인 상황에서 중단 없이 변경된 모듈만 리로드 하고 싶은 경우가 있다.
단순히 .beam 파일만 교체하는 것으로 해결되지는 않으며,
변경된 .beam 파일로 교체(copy)한 후 실행 중인 어플리케이션에 콘솔로 접속한 후 다음과 같이 변경된 모듈을 명시적으로 리로드해야 한다.
&amp;gt; code:purge(M), code:load_file(M).  code:purge/1 함수는 정해진 모듈을 메모리에서 제거하는데, 해당 모듈을 사용하는 프로세스가 있을 경우 먼저 해당 프로세스들을 kill하게 된다.
프로세스를 kill할 수 없는 경우 code:purge/1는 false를 리턴한다.
보통 서버 모듈(gen_server를 구현했거나 자체 루프를 가지고 프로세스 형태로 존재하는)의 경우 code:purge/1함수를 호출하면 false를 반환할 것이다.</description>
    </item>
    
    <item>
      <title>특정 포트를 사용하는 프로그램 찾기</title>
      <link>https://jeidee.github.io/2016/02/19/ed8ab9eca095-ed8faced8ab8eba5bc-ec82acec9aa9ed9598eb8a94-ed9484eba19ceab7b8eb9ea8-ecb0beeab8b0/</link>
      <pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2016/02/19/ed8ab9eca095-ed8faced8ab8eba5bc-ec82acec9aa9ed9598eb8a94-ed9484eba19ceab7b8eb9ea8-ecb0beeab8b0/</guid>
      <description> netstat -tulpn | grep 12345 -t | &amp;amp;#8211;tcp -u | &amp;amp;#8211;udp -l | &amp;amp;#8211;listening -p | &amp;amp;#8211;programs -n | &amp;amp;#8211;numeric (don&#39;t resolve name)  </description>
    </item>
    
    <item>
      <title>cowboy에서 SSE를 사용한 웹서버 push 구현하기</title>
      <link>https://jeidee.github.io/2016/02/15/cowboyec9790ec849c-sseeba5bc-ec82acec9aa9ed959c-ec9bb9ec849cebb284-push-eab5aced9884ed9598eab8b0/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2016/02/15/cowboyec9790ec849c-sseeba5bc-ec82acec9aa9ed959c-ec9bb9ec849cebb284-push-eab5aced9884ed9598eab8b0/</guid>
      <description>ejabberd에 cowboy를 연동했다고 가정한다.
Front-end는 AngularJS를 사용한다.
 SSE(Server Sent Event)참고  클라이언트에서 다음과 같이 EventSource객체를 생성한 후 서버 이벤트를 위한 이벤트리스닝을 시작한다.
https://gist.github.com/jeidee/a135060aef54b48bae1d
서버에서는 다음과 같이 cowboy_req:chunked_reply/3 함수를 사용해 content-type이 text/event-stream인 응답을 보내고 {cowboy_loop, _, _}를 반환한다.
일반적으로 하나의 클라이언트 요청(http request)당 하나의 erlang process를 생성하며, cowboy_req:reply/4 함수를 사용해 reponse를 보내고 {ok, _, _}를 반환하면 해당 erlang process를 종료한다.
하지만 Server Sent Event를 위해 {cowboy_loop, _, _}를 반환하면 해당 클라이언트의 요청(Request) 객체를 erlang process에 상태로 유지하며,</description>
    </item>
    
    <item>
      <title>ejabberd와 cowboy 연동</title>
      <link>https://jeidee.github.io/2016/02/03/ejabberdec9980-cowboy-ec97b0eb8f99/</link>
      <pubDate>Wed, 03 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2016/02/03/ejabberdec9980-cowboy-ec97b0eb8f99/</guid>
      <description>ejabberd에 포함된 관리자용 웹사이트는 인터페이스가 썩 편하지 않다. 더군다나 admin 모듈(ejabberd_web_admin.erl)을 살펴보면 erlang 코드에서 직접 html을 생성하도록 코드가 작성되어 있어 수정하기가 여간 불편한게 아니다.
이러한 이유로 erlang web framework인 cowboy를 연동하기로 했다.
cowboy는 현재 erlang/otp 18에서 컴파일 가능하기 때문에 다음과 같이 준비가 되어 있어야 한다.
준비  erlang/otp 18 ejabberd 15.04  ejabberd의 최신 버전의 경우 erlang/otp 18을 정상 지원하지만, 현재 사용하고 있는 15.04의 경우 일부 모듈(특히 ejabberd_riak관련 의존성 모듈들)은 erlang/otp 18에서 컴파일 되지 않는 문제가 있다.</description>
    </item>
    
    <item>
      <title>ejabberd couchbase 사용하기</title>
      <link>https://jeidee.github.io/2015/12/30/ejabberd-couchbase-ec82acec9aa9ed9598eab8b0/</link>
      <pubDate>Wed, 30 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/12/30/ejabberd-couchbase-ec82acec9aa9ed9598eab8b0/</guid>
      <description>mongodb와 마찬가지로 couchbase역시 ejabberd에서 공식 지원하지 않는다. erlang driver도 커뮤니티에서 만든 driver만 제공하므로 사용상 주의할 필요가 있다.
couchbase의 erlang driver인 cberl을 사용해서 ejabberd용 couchbase 모듈을 만들어보자.
준비  erlang/otp 17(or 17.5) ejabberd 15.04 couchbase server 4.x  cberl의 경우 빌드서버에는 libcouchbase2와 libcouchbase-dev가 설치되어 있어야 하며, 운영서버에는 libcouchbase2가 설치되어 있어야 한다.
 sudo wget -O/etc/yum.repos.d/couchbase.repo http://packages.couchbase.com/rpm/couchbase-centos62-x86_64.repo sudo yum check-update sudo yum install &amp;amp;#8211;enablerepo=epel libcouchbase2 libcouchbase-devel  cberl의 경우 ejabberd에 연동시 cberl_drv.</description>
    </item>
    
    <item>
      <title>ejabberd mongo-db 사용하기</title>
      <link>https://jeidee.github.io/2015/11/27/ejabberd-mongo-db-ec82acec9aa9ed9598eab8b0/</link>
      <pubDate>Fri, 27 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/11/27/ejabberd-mongo-db-ec82acec9aa9ed9598eab8b0/</guid>
      <description>ejabberd에는 mongodb를 사용할 수 있는 모듈이 없다.
mongodb에서도 erlang driver를 공식적으로 지원하지 않으며, community driver(일반 개발자가 만들어 공개한)만 사용할 수 있다.
community erlang driver중에서 mongodb-erlang을 사용해 ejabberd용 mongodb 모듈을 만들어 보자.
준비  erlang/otp 17(or 17.5) ejabberd 15.04 mongodb 3.0.7  mongodb-erlang의 경우 의존하고 있는 라이브러리 중에서 pbkdf2가 최신 버전의 erlang(17~)에서 컴파일이 안되는 문제(rebar.config에 명시된 {require_min_otp_vsn, &amp;#8220;R14B03&amp;#8221;}. 때문)가 있고, bson-erlang 역시 동일한 문제가 있어, 이를 수정해서 다음과 같이 fork를 생성했다.</description>
    </item>
    
    <item>
      <title>ejabberd 우분투에서 FQDN을 사용해 long node name을 설정할 때, Can&amp;#8217;t set long node name 에러 발생하는 경우</title>
      <link>https://jeidee.github.io/2015/07/23/ejabberd-ec9ab0ebb684ed88acec9790ec849c-fqdnec9d84-ec82acec9aa9ed95b4-long-node-nameec9d84-ec84a4eca095ed95a0-eb958c-cant-set-long-node-name-ec9790/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/07/23/ejabberd-ec9ab0ebb684ed88acec9790ec849c-fqdnec9d84-ec82acec9aa9ed95b4-long-node-nameec9d84-ec84a4eca095ed95a0-eb958c-cant-set-long-node-name-ec9790/</guid>
      <description>제목과 같이 우분투에서 long node name을 사용해 ejabberd(erlang) 노드를 사용할 경우,
ejabberdctl의 status, debug등의 명령을 실행하면 다음과 같은 에러가 발생하는 경우가 있다.
 &amp;quot;Can&#39;t set long node name!nPlease check your configurationn&amp;quot;,[]}  예를 들어, 노드명을 ejabberd@hello.world.com 으로 사용할 경우 다음과 같이 hostname을 확인해 본다.
 $ sudo hostname  hostname이 hello.world.com으로 설정되어 있어야 한다.
만약, 제대로 설정되어 있지 않은 경우 다음과 같이 설정한다.
 $ sudo hostname hello.world.com  영구적으로 사용하고자 한다면 /etc/hostname의 값도 수정해야 한다.</description>
    </item>
    
    <item>
      <title>ejabberd와 riak 연동</title>
      <link>https://jeidee.github.io/2015/06/25/ejabberdec9980-riak-ec97b0eb8f99/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/06/25/ejabberdec9980-riak-ec97b0eb8f99/</guid>
      <description>ejabberd 설치 ejabberd에 riak를 활성화해서 설치하는 방법은 이전 포스트를 참고해서 설치한 후, 공식 문서를 참고해서 설정한다.
riak 설치 riak 설치방법은 여러 방법이 있지만 ubuntu에서 간단히 다음 방법을 사용해 설치한다.
 wget http://s3.amazonaws.com/downloads.basho.com/riak/2.1/2.1.1/ubuntu/precise/riak\_2.1.1-1\_amd64.deb sudo dpkg -i riak\_2.1.1-1\_amd64.deb  riak 주요 파일 위치 위와 같이 설치되면 다음의 디렉토리에 주요 파일들이 위치하게 된다.
1) 실행파일
/usr/sbin/riak
/usr/sbin/riak-admin
/usr/sbin/riak-debug
2) 설정파일
/etc/riak/riak.conf
3) 로그파일
/var/log/riak/console.log
/var/log/riak/crash.log
/var/log/riak/error.log
/var/log/riak/erlang.log
/var/log/riak/run_erl.log
riak 실행 확인 설치가 완료되면 다음과 같이 riak를 시작한다.</description>
    </item>
    
    <item>
      <title>ejabberd에 redis 라이브러리(eredis) 추가</title>
      <link>https://jeidee.github.io/2015/06/03/ejabberdec9790-redis-eb9dbcec9db4ebb88ceb9faceba6aceredis-ecb694eab080/</link>
      <pubDate>Wed, 03 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/06/03/ejabberdec9790-redis-eb9dbcec9db4ebb88ceb9faceba6aceredis-ecb694eab080/</guid>
      <description>ejabberd가 15.03버전이 릴리즈되면서 redis 지원이 추가되었다.
클라이언트 세션 관리를 redis로 할 수 있는데 직접 연관된 모듈은 ejabberd_sm 모듈이다.
redis를 사용하려면 다음과 같이 configure에서 &amp;#8211;enable-redis 옵션을 추가해 주면 된다.
 ./configure &amp;amp;#8230; &amp;amp;#8211;enable-redis  위와 같이 해 준후에 rebar를 사용해 의존 라이브러리를 다운로드 받아 컴파일해야 한다.
 rebar get-deps rebar compile  그런 후 make &amp;amp;&amp;amp; make install을 수행하면 된다.
ejabberd.yml에서 sm_db_type을 redis로 설정하기 위해서는 다음 라인을 추가해 주면 된다.</description>
    </item>
    
    <item>
      <title>gloox xmppPing</title>
      <link>https://jeidee.github.io/2015/06/02/gloox-xmppping/</link>
      <pubDate>Tue, 02 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/06/02/gloox-xmppping/</guid>
      <description>gloox의 경우 tcp 연결이 비정상적으로 종료되었을 때 disconnect를 감지할 수 없는 경우가 있다.
이럴 경우를 대비해 xmpp 서버에 주기적으로 ping을 보내고 pong을 수신해서 연결 상태를 관리하는 것이 좋다.
class MsgClient : public MessageSessionHandler , &amp;amp;#8230; , EventHandler { private: int m_heartBeat; }; void MsgClient::heartBeat() { m\_client-&amp;gt;xmppPing(m\_client-&amp;gt;jid(), this); if (++m_heartBeat &amp;gt; 3) { LOGD(&amp;quot;허트비트 무응답 초과로 연결 종료!&amp;quot;); m_client-&amp;gt;disconnect(); } } void MsgClient::handleEvent(const Event&amp;amp; event) { switch (event.eventType()) { case Event::PingPing: LOGD(&amp;quot;PingPing&amp;quot;); break; case Event::PingPong: LOGD(&amp;quot;PingPong&amp;quot;); &amp;amp;#8211;m_heartBeat; break; case Event::PingError: LOGE(&amp;quot;PingError&amp;quot;); break; default: break; } return; } // ConnectionListener void MsgClient::onConnect() { LOGD(&amp;quot;connected!</description>
    </item>
    
    <item>
      <title>gloox for android</title>
      <link>https://jeidee.github.io/2015/04/21/gloox-for-android/</link>
      <pubDate>Tue, 21 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/04/21/gloox-for-android/</guid>
      <description>gloox를 android에서 사용하기 위한 과정을 살펴보자.
사전 준비 작업 다음과 같은 환경이 구축되어 있다고 가정한다.
 개발 환경 : Mac OS X Yosemite 10.10.3 Android Studio : 1.1.0  Android SDK 경로는 ~/Android/sdk로 변경  NDK  ~/Android/ndk에 복사하고 path 지정   Android Studio에 ndk 설정 Preference &amp;gt; External Tools에서 + 버튼을 클릭해 javah, ndk-build, ndk-build clean 도구를 추가한다.
1) javah
2) ndk-build
3) ndk-build clean
Android Project 생성후 NDK 테스트 1) GlooxForAndroid 이름을 갖는 Android Project를 생성한다.</description>
    </item>
    
    <item>
      <title>nGrinder와 smack api를 사용해 ejabberd 테스트하기</title>
      <link>https://jeidee.github.io/2015/03/30/ngrinderec9980-smack-apieba5bc-ec82acec9aa9ed95b4-ejabberd-ed858cec8aa4ed8ab8ed9598eab8b0/</link>
      <pubDate>Mon, 30 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/03/30/ngrinderec9980-smack-apieba5bc-ec82acec9aa9ed95b4-ejabberd-ed858cec8aa4ed8ab8ed9598eab8b0/</guid>
      <description>테스트 환경 smack api는 3.2.2, nGrinder는 3.3 버전이다.
192.168.56.101서버에 ejabberd가 실행중이고, ngrinder-controller, -agent, -monitor가 실행중이라고 가정한다.
테스트 스크립트 작성 1) Script &amp;gt; Create a script 버튼을 클릭해 다음과 같이 스크립트를 만들어 준다.
 Script Name : testXmpp
Type : Groovy
URL to be tested :
Create Lib and Resource folders : Check
 2) smack-3.2.2.jar 파일을 lib 폴더에 업로드한다.
3) 만들어진 스크립트를 다음과 같이 수정한다.
testXmpp.groovy
package org.ngrinder; import static net.</description>
    </item>
    
    <item>
      <title>ejabberd 패킷 후킹 및 필터링</title>
      <link>https://jeidee.github.io/2015/03/05/ejabberd-ed8ca8ed82b7-ed9b84ed82b9-ebb08f-ed9584ed84b0eba781/</link>
      <pubDate>Thu, 05 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/03/05/ejabberd-ed8ca8ed82b7-ed9b84ed82b9-ebb08f-ed9584ed84b0eba781/</guid>
      <description>ejabberd에서 패킷을 후킹한 후 필터링하고 싶다면 다음과 같이 커스텀 모듈을 생성해 처리하면 된다.
다음 코드는 chat 메세지 패킷을 가로체 디버그 로그에 출력해 주는 소스이다.
-module(mod\_packet\_hook). -behaviour(gen_mod). -export([start/2, stop/1]). -export([on\_filter\_packet/1]). -include(&amp;quot;ejabberd.hrl&amp;quot;). -include(&amp;quot;jlib.hrl&amp;quot;). -include(&amp;quot;logger.hrl&amp;quot;). start(\_Host, \_Opts) -&amp;gt; ejabberd\_hooks:add(filter\_packet, global, ?MODULE, on\_filter\_packet, 0), ok. stop(_Host) -&amp;gt; ejabberd\_hooks:delete(filter\_packet, global, ?MODULE, on\_filter\_packet, 0), ok. on\_filter\_packet({From, To, XML} = Packet) -&amp;gt; %% does something with a packet %% should return modified Packet or atom \`drop\` to drop the packet Type = proplists:get_value(&amp;lt;&amp;lt;&amp;quot;type&amp;quot;&amp;gt;&amp;gt;, XML#xmlel.</description>
    </item>
    
    <item>
      <title>ejabberd external component 연동</title>
      <link>https://jeidee.github.io/2015/03/04/ejabberd-external-component-ec97b0eb8f99/</link>
      <pubDate>Wed, 04 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/03/04/ejabberd-external-component-ec97b0eb8f99/</guid>
      <description>xmpp component 개요 xmpp에는 external component 관련 공식 프로토콜인 Jabber Component Protocol이 있다.
Jabber Component Protocol은 외부 컴포넌트를 XMPP서버와 연동하기 위한 규약을 제안하는데 크게 accept와 connect에 대한 XML 스키마와 handshake flow를 명세하고 있다.
xmpp의 external component는 프로토콜만 준수한다면 어떤 언어를 사용해서도 구현할 수 있다. 3rd-party 컴포넌트를 ejabberd와 연동하는 방법은 Install Components and Transports to othe networks 문서를 참고하도록 한다.
echo-bot component 만들어서 연동해 보기 node-xmpp-component 모듈을 사용해서 간단한 에코봇을 컴포넌트로 만들어 ejabberd와 연동해 보도록 하자.</description>
    </item>
    
    <item>
      <title>ejabberd riak 활성화 설치</title>
      <link>https://jeidee.github.io/2015/01/31/ejabberd-riak-ed999cec84b1ed9994-ec84a4ecb998/</link>
      <pubDate>Sat, 31 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/31/ejabberd-riak-ed999cec84b1ed9994-ec84a4ecb998/</guid>
      <description>riak를 활성화하려면 다음과 같이 설치한다.
 $ ./configure &amp;amp;#8211;enable-riak $ make &amp;amp;&amp;amp; make install  ejabberd 15.03 이후 릴리즈에서는 erlc 버전이 r17 이상 버전에서 정상 컴파일되는 것을 확인했다.
ejabberd 14.07 이전 릴리즈에서는 meck.erl 관련 compile에러가 날 경우 erlc 버전이 r16b3인지 확인해야 한다.
riak 모듈을 제외한 모든 플러그인 모듈을 설치하기 위해서는 다음과 같이 설치하면 된다.
 $ ./configure &amp;amp;#8211;enable-all &amp;amp;#8211;disable-riak  </description>
    </item>
    
    <item>
      <title>ejabberd 설치전 필수 라이브러리</title>
      <link>https://jeidee.github.io/2015/01/31/ejabberd-ec84a4ecb998eca084-ed9584ec8898-eb9dbcec9db4ebb88ceb9faceba6ac/</link>
      <pubDate>Sat, 31 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/31/ejabberd-ec84a4ecb998eca084-ed9584ec8898-eb9dbcec9db4ebb88ceb9faceba6ac/</guid>
      <description>PAM 라이브러리 설치
 $ sudo apt-get install libpam0g-dev  expat 라이브러리 설치
 $ sudo apt-get install libexpat1-dev  rebar 설치
 $ sudo apt-get install rebar  ssl 라이브러리 설치
 $ sudo apt-get install libssl-dev  yaml 라이브러리 설치
 $ sudo apt-get install libyaml-dev  </description>
    </item>
    
    <item>
      <title>ejabberd bosh를 https로 설정하기</title>
      <link>https://jeidee.github.io/2015/01/22/ejabberd-bosheba5bc-httpseba19c-ec84a4eca095ed9598eab8b0/</link>
      <pubDate>Thu, 22 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/22/ejabberd-bosheba5bc-httpseba19c-ec84a4eca095ed9598eab8b0/</guid>
      <description>ejabberd에서 bosh를 설정하기 위해서는 다음과 같이 ejabberd.yml에서 ejabberd_http 모듈을 설정해야 한다.
 &amp;amp;#8211; port: 5280 module: ejabberd_http request_handlers: &amp;quot;/hello&amp;quot;: mod\_http\_hello &amp;quot;/api&amp;quot;: mod\_http\_api web_admin: true http_poll: true http_bind: true \## register: true captcha: true  위와 같이 설정할 경우 admin, api, bosh가 모두 http://localhost:5280 하에서 동작하게 되는데 https로 설정하기 위해서는 다음과 같이 5223 tls 설정과 유사하게 설정하면 된다.
 &amp;amp;#8211; port: 5281 module: ejabberd_http certfile: &amp;quot;/path/to/server.pem&amp;quot; tls: true http_bind: true  주의할 것은 tls 설정항목이 starttls가 아니라 tls라는 것이다.</description>
    </item>
    
    <item>
      <title>ejabberd clustering</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-clustering/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-clustering/</guid>
      <description>process-one 사이트에 명시된 p1-spec 문서는 찾을 수가 없었다.
대신 install guide에 포함된 clustering guide를 살펴보고 cluster-node를 구축하는 방법을 살펴보도록 한다.
cluster 구성을 위한 환경 다음과 같이 Virtualbox를 사용해 Windows 7 호스트에 ubuntu 14.10 게스트 OS를 설치해서 클러스터링을 구성한다.
 호스트 OS  Windows 7  게스트 OS #1  Ubuntu 14.10 desktop ip: 192.168.56.101 hostname: hello.world ejabberd 역할: slave node  게스트 OS #2  Ubuntu 14.10 desktop ip: 192.</description>
    </item>
    
    <item>
      <title>ejabberd http request handlers</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-http-request-handlers/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-http-request-handlers/</guid>
      <description>ejabberd 모듈 개발 문서 중에 http request handlers 개발 관련해서 간단히 정리해 봅니다.
튜토리얼 &amp;#8220;/hello&amp;#8221;로 시작하는 URL에 대한 모든 요청을 처리하기 위해 &amp;#8220;mod_http_hello&amp;#8221;를 작성한다고 가정해 봅시다, 다음과 같이:
 http://localhost:5280/hello/world http://localhost:5280/hello/hedgehog  process/2 함수의 절을 갖는 request 핸들러를 포함하는 &amp;#8220;mod_http_hello.erl&amp;#8221;파일을 작성하는 것으로 시작합니다.
&amp;#8220;/hello/world&amp;#8221; 요청을 처리하는 예는 다음과 같습니다:
process(\_LocalPath = [&amp;quot;world&amp;quot;], \_Request) -&amp;gt; {xmlelement, &amp;quot;html&amp;quot;, [{&amp;quot;xmlns&amp;quot;, &amp;quot;http://www.w3.org/1999/xhtml&amp;quot;}], [{xmlelement, &amp;quot;head&amp;quot;, [], [{xmlelement, &amp;quot;title&amp;quot;, [], []}]}, {xmlelement, &amp;quot;body&amp;quot;, [], [{xmlelement, &amp;quot;p&amp;quot;, [], [{xmlcdata, &amp;quot;Hello, world!</description>
    </item>
    
    <item>
      <title>ejabberd jabber search 수정하기</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-jabber-search-ec8898eca095ed9598eab8b0/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-jabber-search-ec8898eca095ed9598eab8b0/</guid>
      <description>jabber search를 다음과 같이 수정해야 한다고 가정해 본다.
 like query 가능해야 함 페이징 가능해야 함  우선 페이징이 가능하도록 검색폼과 결과폼을 다음과 같이 수정해야 한다.
 검색폼 : page no, page size 필드 추가 결과폼 : 현재 page no, 현재 page size(result count), 결과가 더 있는지 여부(more result) 필드 추가  검색폼 수정 검색폼을 수정하기 위해 ejabberd의 모듈 중에 mod_vcard.erl을 다음과 같이 수정하면 된다.
-define(FORM(JID), ?TLFIELD(&amp;lt;&amp;lt;&amp;quot;text-single&amp;quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&amp;quot;Organization Unit&amp;quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&amp;quot;orgunit&amp;quot;&amp;gt;&amp;gt;), ?</description>
    </item>
    
    <item>
      <title>ejabberd mod_admin_extra 사용해서 vcard 가져오기</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-mod_admin_extra-ec82acec9aa9ed95b4ec849c-vcard-eab080eca0b8ec98a4eab8b0/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-mod_admin_extra-ec82acec9aa9ed95b4ec849c-vcard-eab080eca0b8ec98a4eab8b0/</guid>
      <description>ejabberd에서는 커스텀 플러그인 모듈을 다음 URL에서 별도로 배포하고 있다.
https://www.ejabberd.im/ejabberd-modules
하지만 일부 모듈의 경우 최신 버전에서 사용할 수 없고, 수정된 모듈에서도 이전 버전과 인터페이스 호환이 되지 않아 문제를 일으키는 경우가 있으므로 주의해야 한다.
mod_admin_extra 모듈을 사용해 ejabberdctl의 get_vcard 코맨드 실행 ejabberd-modules 중에서 mod_ctlextra와 mod_admin_extra 모듈은 ejabberdctl용(관리자 콘솔 코맨드) 확장 코맨드 모듈이다. 둘 중에서 mod_admin_extra가 최신 버전이지만 최신 버전의 ejabberd(현재 기준 14.07)에서 사용되는 gen_mod:get_module_opt/5와 호환되지 않아(mod_admin_extra는 gen_mod:get_module_opt/4를 사용) 일부 코드를 수정해야 한다.</description>
    </item>
    
    <item>
      <title>ejabberd mod_admin_extra 사용해서 vcard 설정하기</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-mod_admin_extra-ec82acec9aa9ed95b4ec849c-vcard-ec84a4eca095ed9598eab8b0/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-mod_admin_extra-ec82acec9aa9ed95b4ec849c-vcard-ec84a4eca095ed9598eab8b0/</guid>
      <description>이전 글에서 설명한 vcard 가져오기 관련된 내용 중에 수정할 부분이 있다.
ejabberd_modules의 경우 최신 버전(현재 14.07)에서는 호환이 안되며 대신 ejabberd_contrib를 사용해야 한다.
https://www.ejabberd.im/ejabberd-contrib
 git clone git://github.com/processone/ejabberd-contrib.git  ejabberd-contrib에 포함된 mod_admin_extra는 ejaberd_modules에서 생기는 호환 문제가 해결되어 있으므로 수정할 필요없이 그대로 사용하면 된다.
설치(mod_admin_extra.erl을 ejabberd/src파일에 복사한 후 make &amp;amp;&amp;amp; make install, ejabberd.yml에 mod_admin_extra 모듈 등록)하고 ejabberd를 재시작한 후 터미널에서 다음과 같이 테스트해 보자.
 $ ejabberdctl get_vcard &amp;quot;romeo&amp;quot; &amp;quot;localhost&amp;quot; &amp;quot;NICKNAME&amp;quot; hello $ ejabberdctl set_vcard &amp;quot;romeo&amp;quot; &amp;quot;localhost&amp;quot; &amp;quot;NICKNAME&amp;quot; &amp;quot;world&amp;quot; $ ejabberdctl get_vcard &amp;quot;romeo&amp;quot; &amp;quot;localhost&amp;quot; &amp;quot;NICKNAME&amp;quot; world  닉네임이 잘 변경된다.</description>
    </item>
    
    <item>
      <title>ejabberd mysql odbc 설정</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-mysql-odbc-ec84a4eca095/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-mysql-odbc-ec84a4eca095/</guid>
      <description>mysql 설정은 다음과 같이 한다.
 $ vi /etc/ejabberd/ejabberd.yml auth_method: odbc \## auth_method: internal에서 변경한다. \## MySQL server: ## odbc_type: mysql odbc_server: &amp;quot;localhost&amp;quot; odbc_database: &amp;quot;ejabberd&amp;quot; odbc_username: &amp;quot;ejabberd&amp;quot; odbc_password: &amp;quot;ejabberd&amp;quot;  위와 같이 한 후 모듈별로 db_type을 설정해야 하는데, roster와 vcard를 mysql에 저장하도록 하려면 다음과 같이 ejabberd.yml파일을 수정한다.
 mod_roster: db_type: odbc mod\_shared\_roster: {} mod_stats: {} mod_time: {} mod_vcard: db_type: odbc  </description>
    </item>
    
    <item>
      <title>ejabberd node.js웹에서 ejabberd http api 호출하기</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-node-jsec9bb9ec9790ec849c-ejabberd-http-api-ed98b8ecb69ced9598eab8b0/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-node-jsec9bb9ec9790ec849c-ejabberd-http-api-ed98b8ecb69ced9598eab8b0/</guid>
      <description>ejabberd rest api를 위한 http 커스텀 모듈 ejabberd 의 http 커스텀 모듈을 mod_http_api.erl로 만들었다고 가정한다.
(mod_http_api.erl 관련 내용은 이전의 Post에서 참조)
http://localhost:5280/api/session/list URI를 호출했을 때 동작하는 API를 만들기 위해 mod_http_api.erl에 다음과 같이 추가한다.
process([&amp;lt;&amp;lt;&amp;quot;session&amp;quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&amp;quot;list&amp;quot;&amp;gt;&amp;gt;], _Request) -&amp;gt; session\_list(\_Request);  session_list/1 함수는 내부 함수이며 다음과 같다.
session\_list(\_Request) -&amp;gt; ?DEBUG(&amp;quot;session\_list() \_Request is ~p~n&amp;quot;, [_Request]), List = mod\_admin\_extra:connected\_users\_info(), Y = [X || {[X,\_,\_,\_,\_], \_, \_, \_, \_, \_, \_} &amp;lt;- List], Y1 = {[{list, Y}]}, Result1 = jiffy:encode(Y1), Result2 = to_bin(&amp;quot;~s&amp;quot;, [Result1]), {200, ?</description>
    </item>
    
    <item>
      <title>ejabberd roster 조회 api 만들기</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-roster-eca1b0ed9a8c-api-eba78ceb93a4eab8b0/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-roster-eca1b0ed9a8c-api-eba78ceb93a4eab8b0/</guid>
      <description>process handler 추가 mod_http_api.erl을 작성했다고 가정한다.
request handler에 다음과 같은 코드를 추가한다.
process([&amp;lt;&amp;lt;&amp;quot;friend&amp;quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&amp;quot;list&amp;quot;&amp;gt;&amp;gt;], _Request) -&amp;gt; try get\_friend\_list(_Request) catch throw: {Message, Result} -&amp;gt; {200, ?OPTIONS\_HEADER, list\_to_json(Message, Result)}; \_:\_ -&amp;gt; {200, ?OPTIONS\_HEADER, list\_to_json(&amp;lt;&amp;lt;&amp;quot;An error occured during the requested work.&amp;quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&amp;quot;500&amp;quot;&amp;gt;&amp;gt;)} end;  mod_http_api 모듈이 /api에 바인딩되어 있다면 위의 request 핸들러는 다음과 같은 url을 처리하게 된다.
 /api/friend/list  try&amp;#8230;catch 블럭은 get_friend_list/1에서 예외가 발생할 경우 catch해 올바른 포맷의 결과를 클라이언트에 전달할 수 있도록 해준다.</description>
    </item>
    
    <item>
      <title>ejabberd 강제로 특정 유저 presence 업데이트하기</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-eab095eca09ceba19c-ed8ab9eca095-ec9ca0eca080-presence-ec9785eb8db0ec9db4ed8ab8ed9598eab8b0/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-eab095eca09ceba19c-ed8ab9eca095-ec9ca0eca080-presence-ec9785eb8db0ec9db4ed8ab8ed9598eab8b0/</guid>
      <description>ejabberdctl debug로 쉘을 시작한 후 ejabbrd_sm 모듈의 force_update_presence/1 함수를 사용해 특정 유저의 presence를 업데이트할 수 있다.
(ejabberd@localhost)7&amp;gt; US = {&amp;lt;&amp;lt;&amp;quot;romeo&amp;quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&amp;quot;localhost&amp;quot;&amp;gt;&amp;gt;}. {&amp;lt;&amp;lt;&amp;quot;romeo&amp;quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&amp;quot;localhost&amp;quot;&amp;gt;&amp;gt;} (ejabberd@localhost)9&amp;gt; ejabberd\_sm:force\_update_presence(US). ok  XMPP 클라이언트에서는 다음과 같이 presence stanza가 갱신되어 수신된다.
(swift client의 Debug Console에서 확인)
 &amp;lt;!&amp;amp;#8211; IN &amp;amp;#8211;&amp;gt; &amp;lt;presence from=&#39;romeo@localhost/2239860841418983868905790&#39; to=&#39;romeo@localhost/2239860841418983868905790&#39;&amp;gt;&amp;lt;status/&amp;gt;&amp;lt;c xmlns=&#39;http://jabber.org/protocol/caps&#39; hash=&#39;sha-1&#39; node=&#39;http://swift.im&#39; ver=&#39;rs/tl9NCfXBpKoOYUy+JdBbPGDg=&#39;/&amp;gt;&amp;lt;/presence&amp;gt;&amp;lt;r xmlns=&#39;urn:xmpp:sm:2&#39;/&amp;gt;  </description>
    </item>
    
    <item>
      <title>ejabberd 디버그 모드로 ejabberd  core 모듈 테스트해 보기</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-eb9494ebb284eab7b8-ebaaa8eb939ceba19c-ejabberd-core-ebaaa8eb9388-ed858cec8aa4ed8ab8ed95b4-ebb3b4eab8b0/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-eb9494ebb284eab7b8-ebaaa8eb939ceba19c-ejabberd-core-ebaaa8eb9388-ed858cec8aa4ed8ab8ed95b4-ebb3b4eab8b0/</guid>
      <description>ejabberd를 실행한 상태에서 ejabberdctl의 debug 쉘을 사용해 실행 중인 ejabberd 노드에 접속해 core 모듈을 테스트해 볼 수 있다.
먼저 debug 쉘을 실행한다.
 ejabberdctl debug  ejabberd 모듈과 api를 확인하려면 ejabberd의 문서를 확인하거나 src 폴더의 .erl 소스파일을 열어 직접 확인해 볼 수 있다.
여러 모듈 중에서 인증 모듈을 사용해 유저가 존재하는지 여부를 체크해 보자.
(ejabberd@localhost)2&amp;gt; ejabberd\_auth:is\_user_exists(&amp;lt;&amp;lt;&amp;quot;test1&amp;quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&amp;quot;admin&amp;quot;&amp;gt;&amp;gt;). false (ejabberd@localhost)3&amp;gt; ejabberd\_auth:is\_user_exists(&amp;lt;&amp;lt;&amp;quot;test&amp;quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&amp;quot;admin&amp;quot;&amp;gt;&amp;gt;). true  위와 같이 테스트해 볼 수 있고, 실행 중인 ejabberd 노드의 상태를 모니터링하거나 dets/mnesia 테이블의 내용을 확인해 보기 위해 observer를 실행할 수 있다.</description>
    </item>
    
    <item>
      <title>ejabberd 모듈 개발</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-ebaaa8eb9388-eab09cebb09c/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-ebaaa8eb9388-eab09cebb09c/</guid>
      <description>ejabberd 모듈 개발 공식 문서 번역  원문  소개 ejabberd의 내부 모듈은 플러그인처럼 작동합니다. 각 모듈들은 &amp;#8220;mod_&amp;#8221;로 시작하는 erlang 모듈입니다. 만약 erlang을 모른다면 erlang 입문서를 먼저 보고 오세요.
모듈 API 모든 모듈은 &amp;#8220;gen_mod&amp;#8221; behavior를 사용해야 합니다.
해당 behavior는 다음 API를 제공합니다:
start(Host, Opts) -&amp;gt; ok stop(Host) -&amp;gt; ok * Host = string() * Opts = [{Name, Value}] * Name = Value = string()  Host는 모듈이 동작하는 가상호스트의 이름입니다.</description>
    </item>
    
    <item>
      <title>ejabberd 백업과 복원</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-ebb0b1ec9785eab3bc-ebb3b5ec9b90/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-ebb0b1ec9785eab3bc-ebb3b5ec9b90/</guid>
      <description>ejabberdctl의 admin 명령어를 사용해 백업과 복원을 수행할 수 있다.
백업
 $ ejabberdctl backup 백업파일명  복원
 $ ejabberdctl restore 백업파일명  </description>
    </item>
    
    <item>
      <title>ejabberd 설치와 기본 설정</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-ec84a4ecb998ec9980-eab8b0ebb3b8-ec84a4eca095/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-ec84a4ecb998ec9980-eab8b0ebb3b8-ec84a4eca095/</guid>
      <description>사전에 설치해야 하는 것 들  GNU Make GCC Libexpat 1.95 or higher Erlang/OTP R15B or higher. Libyaml 0.1.4 or higher OpenSSL 0.9.8 or higher, for STARTTLS, SASL and SSL encryption. Zlib 1.2.3 or higher, for Stream Compression support (XEP-01383
). Optional.
 PAM library. Optional. For Pluggable Authentication Modules (PAM). See section 3.1.5.
 GNU Iconv 1.8 or higher, for the IRC Transport (mod irc). Optional. Not needed on</description>
    </item>
    
    <item>
      <title>ejabberd 외부 인증 모듈</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-ec99b8ebb680-ec9db8eca69d-ebaaa8eb9388/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-ec99b8ebb680-ec9db8eca69d-ebaaa8eb9388/</guid>
      <description>ejabberd 외부 인증 모듈  참고문서  개요 외부 인증 스크립트는 erlang port driver API를 따릅니다.
스크립트는 다음과 같은 일을 수행하는 무한 루프로 구성해야 합니다:
 stdin에서 AABBBBBB&amp;#8230;.형식의 byte stream을 읽는다.  A: 데이터의 길이를 의미하는 2bytes 정수(네트워크 바이트 오더 사용) B: 다음과 같은 plain 텍스트 오퍼레이션을 포함  auth:User:Server:Password(username/password 검사) isuser:User:Server(유효한 user인지 검사) setpass:User:Server:Password(user의 암호 설정) tryregister:User:Server:Password(계정 등록 시도) removeuser:User:Server(계정 삭제) removeuser3:User:Server:Password(암호가 유효하면 계정 삭제)   stdout에 결과 출력: AABB  A: 다음 결과값에 대한 길이.</description>
    </item>
    
    <item>
      <title>ejabberd 외부 인증 모듈과 http 커스텀 모듈 연동</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberd-ec99b8ebb680-ec9db8eca69d-ebaaa8eb9388eab3bc-http-ecbba4ec8aa4ed8580-ebaaa8eb9388-ec97b0eb8f99/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberd-ec99b8ebb680-ec9db8eca69d-ebaaa8eb9388eab3bc-http-ecbba4ec8aa4ed8580-ebaaa8eb9388-ec97b0eb8f99/</guid>
      <description>ejabberd의 외부 인증 모듈을 사용해서 인증 처리를 할 경우, 기존 멤버쉽과 연동하는 방법을 찾아 보도록 한다.
우선 들어가기에 앞서 작업 개요를 살펴보면 다음과 같다.
 python으로 외부 인증 모듈 작성 ejabberd를 외부에서 제어할 수 있도록 mod_http_api.erl 을 작성해 커스텀 모듈 등록 mod_http_api에서 기존 멤버쉽의 회원 정보 조회(편의상 internal rest api가 존재한다고 가정한다.)  다음과 같은 로그인 처리 시나리오를 가정해 보자.
 로그인 할 경우 외부 인증 모듈에서 http://localhost:5280/api/auth?user=romeo&amp;amp;server=localhost&amp;amp;password=1234와 같은 형식으로 호출한다.</description>
    </item>
    
    <item>
      <title>ejabberd에 json 라이브러리(jiffy) 추가</title>
      <link>https://jeidee.github.io/2015/01/21/ejabberdec9790-json-eb9dbcec9db4ebb88ceb9faceba6acjiffy-ecb694eab080/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/2015/01/21/ejabberdec9790-json-eb9dbcec9db4ebb88ceb9faceba6acjiffy-ecb694eab080/</guid>
      <description>ejabberd에서 json 라이브러리를 사용하려면 jiffy를 사용하면 된다.
ejabberd가 설치될 때 의존성을 걸어 함께 설치되도록 하려면 다음과 같이 configure에서 &amp;#8211;enable-json을 추가해 주면 된다.
 ./configure &amp;amp;#8211;prefix={&amp;amp;#8230;} &amp;amp;#8211;enable-json  위와 같이 설치하려면 configure를 해 준 후에 rebar를 사용해 의존 라이브러리를 다운로드 받아야 하는데, 다음과 같이 처리한다.
 rebar get-deps rebar compile  그런 후 make &amp;amp; make install을 실행하자.
만약 jiffy.so 파일의 경로를 찾지 못하는 에러가 발생할 경우 다음과 같이 Makeifle.in 파일을 수정하면 된다.</description>
    </item>
    
  </channel>
</rss>