<!DOCTYPE html>
<html lang="ko-kr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Erlang &amp; Go  | ejabberd 외부 인증 모듈과 http 커스텀 모듈 연동</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.51" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="ejabberd 외부 인증 모듈과 http 커스텀 모듈 연동" />
<meta property="og:description" content="ejabberd의 외부 인증 모듈을 사용해서 인증 처리를 할 경우, 기존 멤버쉽과 연동하는 방법을 찾아 보도록 한다.
우선 들어가기에 앞서 작업 개요를 살펴보면 다음과 같다.
 python으로 외부 인증 모듈 작성 ejabberd를 외부에서 제어할 수 있도록 mod_http_api.erl 을 작성해 커스텀 모듈 등록 mod_http_api에서 기존 멤버쉽의 회원 정보 조회(편의상 internal rest api가 존재한다고 가정한다.)  다음과 같은 로그인 처리 시나리오를 가정해 보자.
 로그인 할 경우 외부 인증 모듈에서 http://localhost:5280/api/auth?user=romeo&amp;server=localhost&amp;password=1234와 같은 형식으로 호출한다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jeidee.github.io/2015/01/21/ejabberd-ec99b8ebb680-ec9db8eca69d-ebaaa8eb9388eab3bc-http-ecbba4ec8aa4ed8580-ebaaa8eb9388-ec97b0eb8f99/" /><meta property="article:published_time" content="2015-01-21T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2015-01-21T00:00:00&#43;00:00"/>

<meta itemprop="name" content="ejabberd 외부 인증 모듈과 http 커스텀 모듈 연동">
<meta itemprop="description" content="ejabberd의 외부 인증 모듈을 사용해서 인증 처리를 할 경우, 기존 멤버쉽과 연동하는 방법을 찾아 보도록 한다.
우선 들어가기에 앞서 작업 개요를 살펴보면 다음과 같다.
 python으로 외부 인증 모듈 작성 ejabberd를 외부에서 제어할 수 있도록 mod_http_api.erl 을 작성해 커스텀 모듈 등록 mod_http_api에서 기존 멤버쉽의 회원 정보 조회(편의상 internal rest api가 존재한다고 가정한다.)  다음과 같은 로그인 처리 시나리오를 가정해 보자.
 로그인 할 경우 외부 인증 모듈에서 http://localhost:5280/api/auth?user=romeo&amp;server=localhost&amp;password=1234와 같은 형식으로 호출한다.">


<meta itemprop="datePublished" content="2015-01-21T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2015-01-21T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="475">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ejabberd 외부 인증 모듈과 http 커스텀 모듈 연동"/>
<meta name="twitter:description" content="ejabberd의 외부 인증 모듈을 사용해서 인증 처리를 할 경우, 기존 멤버쉽과 연동하는 방법을 찾아 보도록 한다.
우선 들어가기에 앞서 작업 개요를 살펴보면 다음과 같다.
 python으로 외부 인증 모듈 작성 ejabberd를 외부에서 제어할 수 있도록 mod_http_api.erl 을 작성해 커스텀 모듈 등록 mod_http_api에서 기존 멤버쉽의 회원 정보 조회(편의상 internal rest api가 존재한다고 가정한다.)  다음과 같은 로그인 처리 시나리오를 가정해 보자.
 로그인 할 경우 외부 인증 모듈에서 http://localhost:5280/api/auth?user=romeo&amp;server=localhost&amp;password=1234와 같은 형식으로 호출한다."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://jeidee.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Erlang &amp; Go
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">ejabberd 외부 인증 모듈과 http 커스텀 모듈 연동</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2015-01-21T00:00:00Z">January 21, 2015</time>      
      
      
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<p>ejabberd의 외부 인증 모듈을 사용해서 인증 처리를 할 경우, 기존 멤버쉽과 연동하는 방법을 찾아 보도록 한다.</p>

<p>우선 들어가기에 앞서 작업 개요를 살펴보면 다음과 같다.</p>

<ul>
<li>python으로 외부 인증 모듈 작성</li>
<li>ejabberd를 외부에서 제어할 수 있도록 mod_http_api.erl 을 작성해 커스텀 모듈 등록</li>
<li>mod_http_api에서 기존 멤버쉽의 회원 정보 조회(편의상 internal rest api가 존재한다고 가정한다.)</li>
</ul>

<p>다음과 같은 로그인 처리 시나리오를 가정해 보자.</p>

<ol>
<li>로그인 할 경우 외부 인증 모듈에서 <a href="http://localhost:5280/api/auth?user=romeo&amp;server=localhost&amp;password=1234와">http://localhost:5280/api/auth?user=romeo&amp;server=localhost&amp;password=1234와</a> 같은 형식으로 호출한다.</li>
<li>mod_http_api에서 ejabberd 모듈을 사용해 유저를 로그인 처리한다.</li>
<li>ejabberd에 없을 경우, 멤버쉽에서 해당 유저를 조회한다.

<ol>
<li>멤버쉽에 해당 유저가 있을 경우, 가져와서 ejabberd에 등록한다.</li>
<li>멤버쉽에 해당 유저가 없다면 로그인 실패한다.</li>
</ol></li>
<li>ejabberd에 있을 경우, 암호를 확인해 로그인 처리한다.</li>
</ol>

<h2 id="mod-http-api-erl-작성">mod_http_api.erl 작성</h2>

<h3 id="기본-골격-코드-작성">기본 골격 코드 작성</h3>

<p>먼저 기본 골격 코드는 다음과 같다.</p>

<pre><code class="language-erlang">      
-module(mod\_http\_api).
      
-author('your@email.org').
      
-vsn('').
      
-define(ejabberd_debug, true).

-behaviour(gen_mod).

-export([
          
start/2,
          
stop/1,
          
process/2
          
]). 

-include(&quot;ejabberd.hrl&quot;).
      
-include(&quot;jlib.hrl&quot;).
      
-include(&quot;ejabberd_http.hrl&quot;).
      
-include(&quot;logger.hrl&quot;).
      
-include(&quot;http_bind.hrl&quot;).

%%%&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-
      
%%% REQUEST HANDLERS
      
%%%&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-

process([&lt;&gt;], _Request) -&gt;
          
?DEBUG(&quot;Hello Request: ~p&quot;, [_Request]),
          
{200, ?HEADER,
           
#xmlel{name = &lt;&gt;, children = [{xmlcdata, &lt;&gt;}]}}.

process(\_Path, \_Request) -&gt;
          
?DEBUG(&quot;Bad Request: ~p, ~p&quot;, [\_Path, \_Request]),
          
{400, ?HEADER,
           
#xmlel{name = &lt;&gt;, children = [{xmlcdata, &lt;&gt;}]}}.

%%%&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-
      
%%% BEHAVIOUR CALLBACKS
      
%%%&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-

start(\_Host, \_Opts) -&gt;
          
ok.

stop(_Host) -&gt;
          
ok.
  
</code></pre>

<p>ejabberd/src/ 밑에 mod_http_api.erl 파일명으로 저장한다.</p>

<p>위와 같이 작성한 후 ejabberd.yml을 다음과 같이 수정한다.</p>

<pre><code class="language-erlang">      
listen:
        
&amp;#8230;(중간 생략)
        
request_handlers:
          
&quot;/api&quot;: mod\_http\_api

&amp;#8230;(중간 생략)

modules:
        
&amp;#8230;(중간 생략)
        
mod_version: {}
        
mod\_http\_api: {}
  
</code></pre>

<p>make &amp; make install을 사용해서 다시 빌드한 후 ejabberd를 기동한다.</p>

<p>웹브라우저를 띄우고 <a href="http://localhost:5280/api/hello(편의상">http://localhost:5280/api/hello(편의상</a> 이후에는 /api/hello와 같이 줄여서 사용함)에 접속하면 &#8220;Hello World~!!!&#8221; XML 문자열이 브라우저에 출력된다.</p>

<p>여기까지 무사히 진행했다면 본격적으로 시작해 보자.</p>

<h3 id="auth-api-작성">auth api 작성</h3>

<p>/api/auth?user=romeo&amp;server=localhost&amp;password=1234와 같은 api 호출을 받아드리도록 process/2 함수를 확장한다.</p>

<pre><code class="language-erlang">      
process([&lt;&gt;], _Request) -&gt;
          
Args = element(4, _Request),
          
User = proplists:get_value(&lt;&gt;, Args),
          
Server = proplists:get_value(&lt;&gt;, Args),
          
Pwd = proplists:get_value(&lt;&gt;, Args),
          
IsExists = ejabberd\_auth\_internal:is\_user\_exists(User, Server),
          
Result = to\_bin(&quot;~p ~n user=~p, server=~p, pwd=~p is\_exists=~p ~n&quot;, [_Request, User, Server, Pwd, IsExists]),
          
?DEBUG(&quot;Auth Request: ~p&quot;, [Args]),
          
{200, ?HEADER,Result};

to_bin(Format, List) -&gt;
          
binary:list\_to\_bin(io_lib:format(Format, List)).
  
</code></pre>

<blockquote>
<p>to_bin/2 함수는 유틸 함수로 편의상 임의로 작성한 함수이다.</p>
</blockquote>

<p>_Request를 출력해보면 다음과 같은 튜플을 확인할 수 있다.</p>

<pre><code class="language-erlang">      
{request,'GET',
               
[&lt;&gt;,&lt;&gt;],
               
[{&lt;&gt;,&lt;&gt;},
                
{&lt;&gt;,&lt;&gt;},
                
{&lt;&gt;,&lt;&gt;}],
               
{&lt;&gt;,&lt;&gt;},
               
{&lt;&gt;,&lt;&gt;},
               
&lt;&gt;,&lt;&gt;,
               
{ {10,0,2,2},53260},
               
&lt;&gt;,5280,http,
               
[{'Accept-Language',&lt;&gt;},
                
{'Accept-Encoding',&lt;&gt;},
                
{'User-Agent',&lt;&gt;},
                
{'Accept',&lt;&gt;},
                
{'Authorization',&lt;&gt;},
                
{'Cache-Control',&lt;&gt;},
                
{'Connection',&lt;&gt;},
                
{'Host',&lt;&gt;}]}
  
</code></pre>

<p>위의 튜플 요소 중에 중요한 것은 네 번째 요소인 query string을 파싱한 결과인 파라미터 튜플 리스트이다.</p>

<pre><code class="language-erlang">      
[{&lt;&gt;,&lt;&gt;},
       
{&lt;&gt;,&lt;&gt;},
       
{&lt;&gt;,&lt;&gt;}]
  
</code></pre>

<p>_Request에서 해당 요소만 추출하기 위해서 element/2 함수를 다음과 같이 사용한다.</p>

<pre><code class="language-erlang">      
Args = element(4, _Request),
  
</code></pre>

<p>Args에 원하는 파라미터 튜플 리스트가 매치되고, Args에서 &ldquo;user&rdquo;, &ldquo;server&rdquo;, &ldquo;password&rdquo; 파라미터에 해당하는 값을 다음과 같이 추출할 수 있다.</p>

<pre><code class="language-erlang">      
User = proplists:get_value(&lt;&gt;, Args),
      
Server = proplists:get_value(&lt;&gt;, Args),
      
Pwd = proplists:get_value(&lt;&gt;, Args),
  
</code></pre>

<p>proplists 모듈의 get_value/2 함수를 사용하면 튜플 리스트에서 key/value로 값을 조회할 수 있다.</p>

<p>위의 과정을 거치면 User, Server, Pwd 변수에 각각 &lt;&lt;&ldquo;romeo&rdquo;&gt;&gt;, &lt;&lt;&ldquo;localhost&rdquo;&gt;&gt;, &lt;&lt;&ldquo;1234&rdquo;&gt;&gt; 바이너리 리스트가 할당된다.</p>

<p>이제 이 값을 가지고 이후의 과정을 처리하면 된다.</p>

<h4 id="ejabberd-유저-체크">ejabberd 유저 체크</h4>

<p>해당 유저가 ejabberd에 등록된 유저인지 확인해 보자.</p>

<p>다음과 같이 ejabberd_auth_internal 모듈의 is_user_exists/2 함수를 사용한다.</p>

<pre><code class="language-erlang">      
IsExists = ejabberd\_auth\_internal:is\_user\_exists(User, Server),
  
</code></pre>

<p>user가 존재한다면 IsExists 변수에는 true가, 아닐 경우 false가 바운드된다.</p>

<p><strong>ejabberd에 등록되지 않은 유저일 경우</strong></p>

<p>이 부분 이후는 다음 글에서 이어서 작성하도록 한다.</p>
<ul class="pa0">
  
</ul>
<div class="mt6">
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-erlnote-wordpress-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://jeidee.github.io/" >
    &copy; 2018 Erlang &amp; Go
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
