<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Elixir IO and the file system (#12/21)</title>
	
	
	<link rel="stylesheet" href="https://jeidee.github.io/css/style.css">
	
	<meta name="generator" content="Hugo 0.31.1" />
</head>
<body>
	<header>
		<a href="https://jeidee.github.io/">Erlang &amp; Go</a>
		<nav>
			<ul>
				
			</ul>
		</nav>
	</header>
	<main>
		<article>
			<h1>Elixir IO and the file system (#12/21)</h1>
			<time>17.06.2015 00:00</time>
			<div>
				

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>이번 챕터에서는 IO, File, Path 모듈과 관련된 입/출력 매커니즘과 파일 시스템 관련 태스크를 소개하도록 한다.</p>

<h2 id="the-io-module">The IO module</h2>

<p>elixir의 IO 모듈은 표준 입출력, 표준 에러, 파일과 다른 IO 장치들을 읽고 쓸 수 있도록 해주는 주요 매커니즘이다. 모듈의 사용법은 꽤 직관적이다.</p>

<pre><code>  
iex&gt; IO.puts &quot;hello world&quot;
  
hello world
  
:ok
  
iex&gt; IO.gets &quot;yes or no? &quot;
  
yes or no? yes
  
&quot;yesn&quot;
  
</code></pre>

<p>기본적으로, IO 모듈의 함수는 표준 입력에서 읽고 표준 출력에 쓴다. 우리는 다른 장치를 사용할 수도 있다. 예를 들어 매개변수로 :stderr를 사용하는 것으로 표준 출력 장치를 사용할 수 있다.</p>

<pre><code>  
iex&gt; IO.puts :stderr, &quot;hello world&quot;
  
hello world
  
:ok
  
</code></pre>

<h2 id="the-file-module">The File module</h2>

<p>File 모듈은 IO 장치로 파일을 처리할 수 있는 여러 함수들을 포함한다. 기본적으로, 파일은 바이너리 모드로 열리고, IO 모듈의 IO.binread/2와 IO.binwrite/2 함수를 사용하도록 요구한다.</p>

<pre><code>  
iex&gt; {:ok, file} = File.open &quot;hello&quot;, [:write]
  
{:ok, #PID&lt;0.47.0&gt;}
  
iex&gt; IO.binwrite file, &quot;world&quot;
  
:ok
  
iex&gt; File.close file
  
:ok
  
iex&gt; File.read &quot;hello&quot;
  
{:ok, &quot;world&quot;}
  
</code></pre>

<p>파일은 :utf8 인코딩을 명시해서 열 수 있고, File 모듈에 UTF-8 인코딩된 바이트를 읽도록 알려줄 수 있다.</p>

<p>파일을 열고/읽고/쓰는 함수들 외에도, File 모듈은 파일 시스템을 처리하는 많은 함수들을 포함한다. 그러한 함수들은 UNIX와 동등한 이름을 갖고 있다. 예를 들어, File.rm/1 함수는 파일을 삭제할 수 있고, File.mkdir/1 함수는 디렉토리를 생성하며, File.mkdir_p/1 함수는 지정된 경로의 부모 디렉토리 체인(/path/to와 같을 경우 path도 없고 to도 없는 경우 path도 만들고 to도 만든다.)을 포함해 디렉토리를 생성한다. File.cp_r/2와 File.rm_rf/2 함수는 디렉토리를 재귀적으로 순환하면서 각각의 파일을 복사하거나 삭제한다.(파일 뿐 아니라 디렉토리를 포함한다.)</p>

<p>File 모듈의 함수는 두 개의 형태를 갖는다. !가 뒤에 붙는 것과 그렇지 않은 것인데, 예를 들어 파일을 읽기 위해 File.read/1함수를 사용할 수 있다면 File.read!/1 함수도 역시 다음과 같이 사용할 수 있다.</p>

<pre><code>  
iex&gt; File.read &quot;hello&quot;
  
{:ok, &quot;world&quot;}
  
iex&gt; File.read! &quot;hello&quot;
  
&quot;world&quot;
  
iex&gt; File.read &quot;unknown&quot;
  
{:error, :enoent}
  
iex&gt; File.read! &quot;unknown&quot;
  
** (File.Error) could not read file unknown: no such file or directory
  
</code></pre>

<p>!(bang) 함수의 경우 파일이 없다면 에러가 발생하지만, 일반적인 버전의 함수는 에러대신 튜플을 반환하며, 패턴매칭을 사용해 상황별 대처를 할 수 있다.</p>

<pre><code>  
case File.read(file) do
    
{:ok, body} -&gt; # do something with the \`body\`
    
{:error, reason} -&gt; # handle the error caused by \`reason\`
  
end
  
</code></pre>

<p>하지만, 파일이 존재할 것이라 기대하고 !함수를 사용하게 되면 의미 있는 에러 메세지가 발생하게 되고, 잘못된 쓰기를 방지하는데 좀 더 유용하게 사용할 수 있다.</p>

<pre><code>  
{:ok, body} = File.read(file)
  
</code></pre>

<p>위의 예제에서 에러가 발생할 경우 {:error, reason}이 반환되므로 패턴 매칭에 실패하게 된다. 패턴 매칭 실패에 에러 상황을 의존하게될 경우 애매해지게 되며 실제 에러가 어떤 것인지 알 수 없게 된다.</p>

<p>명확한 에러가 발생하길 원한다면 File.read!/1 함수를 사용하는 것이 더 좋다.</p>

<h2 id="the-path-module">The Path module</h2>

<p>File 모듈의 함수들은 대부분 경로를 매개변수로 원한다. 가장 일반적으로, 이들 경로는 정규 바이너리이다. Path 모듈은 이러한 경로를 쉽게 처리하는 기능들을 제공한다.</p>

<pre><code>  
iex&gt; Path.join(&quot;foo&quot;, &quot;bar&quot;)
  
&quot;foo/bar&quot;
  
iex&gt; Path.expand(&quot;~/hello&quot;)
  
&quot;/Users/jose/hello&quot;
  
</code></pre>

<p>바이너리를 직접 처리하는 대신에 Path 모듈의 함수들을 사용는 것이 더 좋은데, 이유는 Path 모듈이 제공하는 함수들이 OS에 맞게 처리되기 때문이다. 예를 들어, Path.join/2 함수는 Unix 시스템의 경우 (/)를 사용하며 윈도우 시스템의 경우 (&#092;&#092;)를 사용한다.</p>

<p>elixir는 메인 모듈에서 IO와 파일 시스템을 처리하는 기능을 제공한다. 다음 섹션에서 우리는, IO에 관한 좀 더 전문적인 내용을 살펴볼 것이다. elixir 코드를 작성하기 위해 이러한 전문적인 내용이 필요하진 않으므로, 필요하다면 무시해도 좋다. 그러나 IO 시스템이 VM에서 어떻게 구현되었는지 궁금하다면 훑어볼 것을 권장한다.</p>

<h2 id="processes-and-group-leaders">Processes and group leaders</h2>

<p>File.open/2 함수는 {:ok, pid} 튜플을 반환한다는 것을 알고 있을 것이다.</p>

<pre><code>  
iex&gt; {:ok, file} = File.open &quot;hello&quot;, [:write]
  
{:ok, #PID}
  
</code></pre>

<p>이와 같은 이유는 IO 모듈이 프로세스와 함께 동작하기 때문이다. 우리가 IO.write(pid, binary)를 작성할 때, IO 모듈은 pid로 식별되는 프로세스에 지정된 동작을 수행하라고 메세지를 전송하게 된다. 우리의 프로세스에서 어떤 일이 일어나는지 살펴보자.</p>

<pre><code>  
iex&gt; pid = spawn fn -&gt;
  
&amp;#8230;&gt; receive do: (msg -&gt; IO.inspect msg)
  
&amp;#8230;&gt; end
  
#PID
  
iex&gt; IO.write(pid, &quot;hello&quot;)
  
{:io\_request, #PID, #PID, {:put\_chars, :unicode, &quot;hello&quot;}}
  
** (ErlangError) erlang error: :terminated
  
</code></pre>

<p>IO.write/2함수를 사용한 후에, 우리는 IO 모듈에 의해 보내진 요청(4개의 요소를 갖는 튜플)을 볼 수 있다. 그런 후에, 우리는 IO 모듈이 기대하는 어떤 값을 제공해 주지 않았기 때문에 실패했음을 볼 수 있다.</p>

<p>StringIO 모듈은 문자열 처리를 위해 IO 장치의 메세지 구현을 제공한다.</p>

<pre><code>  
iex&gt; {:ok, pid} = StringIO.open(&quot;hello&quot;)
  
{:ok, #PID}
  
iex&gt; IO.read(pid, 2)
  
&quot;he&quot;
  
</code></pre>

<p>프로세스에 IO 장치를 처리하도록 설계되었기 때문에, Erlang VM은 같은 네트워크 상에서 서로 다른 프로세스간 파일 처리를 가능하도록 허용한다. 모든 IO 장치의 각 프로세스는 특별한 프로세스가 하나 있는데, 그룹리더라고 부른다.</p>

<p>우리가 :stdio에 쓸때, 실제로는 표준 출력 파일 디스크립터를 사용하는 그룹 리더에 메세지를 보내는 것이다.</p>

<pre><code>  
iex&gt; IO.puts :stdio, &quot;hello&quot;
  
hello
  
:ok
  
iex&gt; IO.puts Process.group_leader, &quot;hello&quot;
  
hello
  
:ok
  
</code></pre>

<p>그룹 리더는 프로세스 마다 설정될 수 있고, 다른 상황에서 사용될 수 있다. 예를 들어, 원격 터미널에서 코드가 실행될 때, 원격 노드에 있는 메세지가 요청이 이뤄진 터미널에 재전송되어 출력될 것임을 보장한다.</p>

<h2 id="iodata-and-chardata">iodata and chardata</h2>

<p>위의 모든 예제에서, 우리는 파일을 쓸때 바이너리를 사용했다. &ldquo;Binaries, strings and char lists&rdquo; 챕터에서 우리는, 문자열이 단순히 코드 포인트로 이뤄진 문자 리스트임을 언급했었다.</p>

<p>IO와 File 모듈의 함수들 역시 매개변수로 리스트를 허용한다. 그 뿐 아니라, 리스트, 정수, 바이너리 등의 조합으로 이뤄진 리스트도 허용한다.</p>

<pre><code>  
iex&gt; IO.puts 'hello world'
  
hello world
  
:ok
  
iex&gt; IO.puts ['hello', ?\s, &quot;world&quot;]
  
hello world
  
:ok
  
</code></pre>

<p>하지만, 이것은 약간의 주의를 필요로한다. 리스트는 바이트나 IO 장치의 인코딩에 의존하는 문자들의 모음이다. 파일이 인코딩 없이 열려있다면, 파일은 raw 모드로 열린 것이고 IO 모듈의 bin* 으로 시작하는 함수가 사용되어야 한다. 이러한 함수들은 매개변수로 iodata를 요구한다. iodata는 바이트와 바이너리를 표현하기 위해 정수로 표현되는 리스트이다.</p>

<p>이와 달리, :stdio와 파일이 :utf8 인코딩으로 열린 경우 IO 모듈의 나머지 함수들(bin*이외의)을 사용할 수 있다. 이러한 함수들은 매개변수로 문자들의 리스트나 문자열인 char_data를 요구한다.</p>

<p>비록 이것이 미묘한 차이일지라도, 함수에 리스트를 넘길 때 이러한 차이에 신경을 써야할 필요가 있다. 바이너리는 이미 바이트 기반으로 표현되고 항상 raw로 처리된다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/io-and-the-file-system.html">Elixir IO and the file system</a></li>
</ul>

			</div>
			<div>
				<ul id="tags">
					
					<li><a href="/tags/tutorial">tutorial</a> </li>
					
				</ul>
			</div>
			<div>
				
			</div>
		</article>
	</main>
	<aside>
		<div>
			<div>
				<h3>LATEST POSTS</h3>
			</div>
			<div>
				<ul>
					
					<li><a href="https://jeidee.github.io/2017/08/31/upstart-ec84a4eca095/">upstart 설정</a></li>
					
					<li><a href="https://jeidee.github.io/2017/06/08/centosec9790ec849c-mongodb-ec84a4ecb998ec9980-service-eb93b1eba19d/">CentOS에서 MongoDB 설치와 Service 등록</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/couchbase-cberlec9790-lcb_cntl-ed95a8ec8898-ecb694eab080/">couchbase cberl에 lcb_cntl 함수 추가</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/couchbase-cberlec9d98io-pluginec9d84-libeventeba19c-ebb380eab2bd/">couchbase cberl의IO Plugin을 libevent로 변경</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/ejabberdec9d98-deps-eb9dbcec9db4ebb88ceb9faceba6ac-ec8898eca095-ed9b84-ecbbb4ed8c8cec9dbcec9790ec849c-eb8884eb9dbdeb90a0-eb958c/">ejabberd의 deps 라이브러리 수정 후 컴파일에서 누락될 때</a></li>
					
				</ul>
			</div>
		</div>
	</aside>

	<footer>
		<p>&copy; 2017 <a href="https://jeidee.github.io/">Erlang &amp; Go</a></p>
	</footer>
</body>
</html>