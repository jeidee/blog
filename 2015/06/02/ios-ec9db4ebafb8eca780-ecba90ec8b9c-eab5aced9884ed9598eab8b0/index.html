<!DOCTYPE html>
<html lang="ko-kr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Erlang &amp; Go  | ios 이미지 캐시 구현하기</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.51" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="ios 이미지 캐시 구현하기" />
<meta property="og:description" content="URL에서 이미지를 가져와 출력하는 것은 매우 성능이 좋지 않다. 상황에 따라서는 수 초간(또는 그 이상) 이미지를 불러오지 못하는 경우도 생길 수 있고, 비동기로 많은 이미지를 가져올 경우 상황은 더욱 좋지 않게 된다.
이런 경우 대부분 이미지를 캐시해 놓고 이후 요청에서는 캐시에서 이미지를 불러오도록 하는데, 메모리와 디스크를 병행해서 캐시해야 프로세스를 재시작해도 캐시를 지속적으로 사용할 수 있는 이득을 볼 수 있다.
간단한 플로우는 다음과 같다.
1) 메모리 캐시에서 이미지를 검색한다.
2) 없을 경우, 디스크 캐시에서 이미지를 검색한다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jeidee.github.io/2015/06/02/ios-ec9db4ebafb8eca780-ecba90ec8b9c-eab5aced9884ed9598eab8b0/" /><meta property="article:published_time" content="2015-06-02T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2015-06-02T00:00:00&#43;00:00"/>

<meta itemprop="name" content="ios 이미지 캐시 구현하기">
<meta itemprop="description" content="URL에서 이미지를 가져와 출력하는 것은 매우 성능이 좋지 않다. 상황에 따라서는 수 초간(또는 그 이상) 이미지를 불러오지 못하는 경우도 생길 수 있고, 비동기로 많은 이미지를 가져올 경우 상황은 더욱 좋지 않게 된다.
이런 경우 대부분 이미지를 캐시해 놓고 이후 요청에서는 캐시에서 이미지를 불러오도록 하는데, 메모리와 디스크를 병행해서 캐시해야 프로세스를 재시작해도 캐시를 지속적으로 사용할 수 있는 이득을 볼 수 있다.
간단한 플로우는 다음과 같다.
1) 메모리 캐시에서 이미지를 검색한다.
2) 없을 경우, 디스크 캐시에서 이미지를 검색한다.">


<meta itemprop="datePublished" content="2015-06-02T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2015-06-02T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="571">



<meta itemprop="keywords" content="cache,image cache,md5,NSURL,thumbnail," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ios 이미지 캐시 구현하기"/>
<meta name="twitter:description" content="URL에서 이미지를 가져와 출력하는 것은 매우 성능이 좋지 않다. 상황에 따라서는 수 초간(또는 그 이상) 이미지를 불러오지 못하는 경우도 생길 수 있고, 비동기로 많은 이미지를 가져올 경우 상황은 더욱 좋지 않게 된다.
이런 경우 대부분 이미지를 캐시해 놓고 이후 요청에서는 캐시에서 이미지를 불러오도록 하는데, 메모리와 디스크를 병행해서 캐시해야 프로세스를 재시작해도 캐시를 지속적으로 사용할 수 있는 이득을 볼 수 있다.
간단한 플로우는 다음과 같다.
1) 메모리 캐시에서 이미지를 검색한다.
2) 없을 경우, 디스크 캐시에서 이미지를 검색한다."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://jeidee.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Erlang &amp; Go
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">ios 이미지 캐시 구현하기</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2015-06-02T00:00:00Z">June 2, 2015</time>      
      
      
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>URL에서 이미지를 가져와 출력하는 것은 매우 성능이 좋지 않다. 상황에 따라서는 수 초간(또는 그 이상) 이미지를 불러오지 못하는 경우도 생길 수 있고, 비동기로 많은 이미지를 가져올 경우 상황은 더욱 좋지 않게 된다.</p>

<p>이런 경우 대부분 이미지를 캐시해 놓고 이후 요청에서는 캐시에서 이미지를 불러오도록 하는데, 메모리와 디스크를 병행해서 캐시해야 프로세스를 재시작해도 캐시를 지속적으로 사용할 수 있는 이득을 볼 수 있다.</p>

<p>간단한 플로우는 다음과 같다.</p>

<p>1) 메모리 캐시에서 이미지를 검색한다.</p>

<p>2) 없을 경우, 디스크 캐시에서 이미지를 검색한다.</p>

<p>3) 없을 경우, URL에서 이미지를 비동기 로드한다.</p>

<p>4) 메모리 캐시와 디스크 캐시에 해당 이미지를 저장한다.</p>

<p>5) 다음 번 요청시에는 메모리 캐시에서 이미지를 불러온다.</p>

<p>6) 프로세스 재지작 이후 요청시에는 디스크 캐시에서 불러온 후 메모리 캐시에 추가한다.</p>

<p>캐시키는 URL 문자열을 md5 해시 문자열로 변환해 사용한다.</p>

<p>소스코드는 다음과 같고 캐시의 최대 사이즈 제한 기능이 빠져있으므로 실제로 사용할 경우 해당 기능을 추가 구현해야 한다.</p>

<p>ImageCache.h</p>

<pre><code class="language-objc">  
#import &lt;UIKit/UIKit.h&gt;

@interface ImageCache : NSObject
  
{
      
NSMutableDictionary* mMemCache;
  
}

+(ImageCache*)getInstance;

-(void) loadFromUrl: (NSURL\*) url callback:(void (^)(UIImage \*image))callback;

-(NSString\*)md5:(NSString \*)str;

-(UIImage\*)saveToDisk:(UIImage\*)image withKey:(NSString*)key;
  
-(UIImage\*)loadFromDisk:(NSString\*)key;

-(UIImage\*)saveToMemory:(UIImage\*)image withKey:(NSString*)key;
  
-(UIImage\*)loadFromMemory:(NSString\*)key;

-(UIImage\*)makeThumbnail:(UIImage\*)image;

@end
  
</code></pre>

<p>ImageCache.m</p>

<pre><code class="language-objc">  
#import &quot;ImageCache.h&quot;
  
#import &lt;CommonCrypto/CommonDigest.h&gt;

@implementation ImageCache

// 싱글턴
  
+(ImageCache*)getInstance {
      
static dispatch\_once\_t pred;
      
static ImageCache* instance = nil;

dispatch_once(&amp;pred, ^{
          
instance = [[ImageCache alloc] init];
      
});

return instance;
  
}

-(id)init {
      
self = [super init];

if (self) {
          
// url 캐시 설정
          
// 메모리 : 10MB, 디스크 : 50MB
          
NSURLCache \*urlCache = [[NSURLCache alloc] initWithMemoryCapacity:10 \* 1024 \* 1024 diskCapacity:50 \* 1024 * 1024 diskPath:nil];
          
[NSURLCache setSharedURLCache:urlCache];

// 메모리 캐시 설정
          
// @todo : 최대 사이즈와 적정 사이즈 조절 기능 필요
          
mMemCache = [[NSMutableDictionary alloc] initWithCapacity:100];
      
}

return self;
  
}

&amp;#8211; (void) loadFromUrl: (NSURL\*) url callback:(void (^)(UIImage \*image))callback {
      
dispatch\_queue\_t queue = dispatch\_get\_global\_queue(DISPATCH\_QUEUE\_PRIORITY\_HIGH, 0ul);
      
dispatch_async(queue, ^{

UIImage* image = nil;

if (url != nil) {
              
NSString* key = [self md5:[url absoluteString]];

// 메모리 캐시에서 먼저 검색
              
UIImage* cachedImage = [self loadFromMemory:key];

// 메모리 캐시에 없을 경우 디스크 캐시에서 검색
              
if (cachedImage == nil) {
                  
cachedImage = [self loadFromDisk:key];
                  
// 메모리 캐시에 추가
                  
[self saveToMemory:cachedImage withKey:key];
              
}

// 캐시된 이미지가 없을 경우 url에서 직접 가져옴
              
if (cachedImage != nil) {
                  
image = cachedImage;
              
} else {
                  
NSData * imageData = [NSData dataWithContentsOfURL:url];
                  
image = [UIImage imageWithData:imageData];
                  
// 썸네일 이미지로 변환
                  
image = [self makeThumbnail:image];

// 메모리와 디스크 캐시에 추가
                  
[self saveToMemory:image withKey:key];
                  
[self saveToDisk:image withKey:key];
              
}
          
}

if (image == nil) {
              
image = [UIImage imageNamed:@&quot;unnamed&quot;];
          
}

dispatch\_async(dispatch\_get\_main\_queue(), ^{
              
callback(image);
          
});
      
});
  
}

// url을 사용해서 md5 해시 문자열 생성
  
-(NSString\*)md5:(NSString \*)str {
      
const char *cStr = [str UTF8String];
      
unsigned char result[CC\_MD5\_DIGEST_LENGTH];
      
CC_MD5( cStr, strlen(cStr), result );
      
return [NSString stringWithFormat:@&quot;%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X&quot;,
              
result[0], result[1],
              
result[2], result[3],
              
result[4], result[5],
              
result[6], result[7],
              
result[8], result[9],
              
result[10], result[11],
              
result[12], result[13],
              
result[14], result[15]
              
];
  
}

-(UIImage\*)saveToDisk:(UIImage\*)image withKey:(NSString*)key {
      
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
      
NSString *documentsDirectory = [paths objectAtIndex:0];

NSString *path = [NSString stringWithFormat:@&quot;%@/%@&quot;, documentsDirectory, key];

UIImage* thumbnail = [self makeThumbnail:image];

[UIImagePNGRepresentation(thumbnail) writeToFile:path atomically:YES];

return thumbnail;
  
}

-(UIImage\*)loadFromDisk:(NSString\*)key {
      
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
      
NSString *documentsDirectory = [paths objectAtIndex:0];

NSString *path = [NSString stringWithFormat:@&quot;%@/%@&quot;, documentsDirectory, key];

UIImage* image = [[UIImage alloc] initWithContentsOfFile:path];
      
return image;
  
}

-(UIImage\*)loadFromMemory:(NSString \*)key {
      
if (mMemCache == nil) return nil;

UIImage* cachedImage = [mMemCache objectForKey:key];
      
return cachedImage;
  
}

-(UIImage\*)saveToMemory:(UIImage\*)image withKey:(NSString*)key {
      
if (mMemCache == nil) {
          
mMemCache = [[NSMutableDictionary alloc] initWithCapacity:100];
      
}

UIImage* thumbnail = [self makeThumbnail:image];

[mMemCache setObject:thumbnail forKey:key];

return thumbnail;
  
}

-(UIImage\*)makeThumbnail:(UIImage\*)image {
      
// 썸네일을 먼저 만들어서 저장한다.
      
// @todo: 썸네일 이미지 사이즈는 별도 정책에 따를 것!
      
CGSize destSize = CGSizeMake(150.0f, 150.0f);
      
UIGraphicsBeginImageContext(destSize);
      
[image drawInRect:CGRectMake(0, 0, destSize.width, destSize.height)];

UIImage* thumbnail = UIGraphicsGetImageFromCurrentImageContext();

UIGraphicsEndImageContext();

return thumbnail;
  
}

@end
  
</code></pre>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/cache" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">cache</a>
   </li>
  
   <li class="list">
     <a href="/tags/image-cache" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">image cache</a>
   </li>
  
   <li class="list">
     <a href="/tags/md5" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">md5</a>
   </li>
  
   <li class="list">
     <a href="/tags/nsurl" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">NSURL</a>
   </li>
  
   <li class="list">
     <a href="/tags/thumbnail" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">thumbnail</a>
   </li>
  
</ul>
<div class="mt6">
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-erlnote-wordpress-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </main>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/2015/06/02/ios-md5-ed95b4ec8b9c-ed82a4-ec839dec84b1/">ios md5 해시 키 생성</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/02/ios-uiimage-ec8db8eb84a4ec9dbc-ec9db4ebafb8eca780-eba78ceb93a4eab8b0/">ios UIImage 썸네일 이미지 만들기</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/05/19/ios-ebb984eb8f99eab8b0eba19c-ec9db4ebafb8eca780-eb8ba4ec9ab4eba19ceb939c/">ios 비동기로 이미지 다운로드</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://jeidee.github.io/" >
    &copy; 2018 Erlang &amp; Go
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
