<!DOCTYPE html>
<html lang="ko-kr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Erlang &amp; Go  | Elixir case, cond and if (#5/21)</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.51" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="Elixir case, cond and if (#5/21)" />
<meta property="og:description" content="본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 이번 챕터에서는 흐름 제어에 사용되는 case, cond, if에 대해 알아본다.
case case는 매치되는 하나를 찾기 위해 많은 패턴과 값을 비교할 때 사용한다.
 iex&gt; case {1, 2, 3} do &amp;#8230;&gt; {4, 5, 6} -&gt; &amp;#8230;&gt; &quot;This clause won&#39;t match&quot; &amp;#8230;&gt; {1, x, 3} -&gt; &amp;#8230;&gt; &quot;This clause will match and bind x to 2 in this clause&quot; &amp;#8230;&gt; _ -&gt; &amp;#8230;&gt; &quot;This clause would match any value&quot; &amp;#8230;&gt; end &quot;This clause will match and bind x to 2 in this clause&quot;  기존의 변수에 패턴매치를 사용하고 싶다면 핀 연산자(^)를 사용해야 한다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jeidee.github.io/2015/06/11/elixir-case-cond-and-if-521/" /><meta property="article:published_time" content="2015-06-11T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2015-06-11T00:00:00&#43;00:00"/>

<meta itemprop="name" content="Elixir case, cond and if (#5/21)">
<meta itemprop="description" content="본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 이번 챕터에서는 흐름 제어에 사용되는 case, cond, if에 대해 알아본다.
case case는 매치되는 하나를 찾기 위해 많은 패턴과 값을 비교할 때 사용한다.
 iex&gt; case {1, 2, 3} do &amp;#8230;&gt; {4, 5, 6} -&gt; &amp;#8230;&gt; &quot;This clause won&#39;t match&quot; &amp;#8230;&gt; {1, x, 3} -&gt; &amp;#8230;&gt; &quot;This clause will match and bind x to 2 in this clause&quot; &amp;#8230;&gt; _ -&gt; &amp;#8230;&gt; &quot;This clause would match any value&quot; &amp;#8230;&gt; end &quot;This clause will match and bind x to 2 in this clause&quot;  기존의 변수에 패턴매치를 사용하고 싶다면 핀 연산자(^)를 사용해야 한다.">


<meta itemprop="datePublished" content="2015-06-11T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2015-06-11T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="908">



<meta itemprop="keywords" content="tutorial," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Elixir case, cond and if (#5/21)"/>
<meta name="twitter:description" content="본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 이번 챕터에서는 흐름 제어에 사용되는 case, cond, if에 대해 알아본다.
case case는 매치되는 하나를 찾기 위해 많은 패턴과 값을 비교할 때 사용한다.
 iex&gt; case {1, 2, 3} do &amp;#8230;&gt; {4, 5, 6} -&gt; &amp;#8230;&gt; &quot;This clause won&#39;t match&quot; &amp;#8230;&gt; {1, x, 3} -&gt; &amp;#8230;&gt; &quot;This clause will match and bind x to 2 in this clause&quot; &amp;#8230;&gt; _ -&gt; &amp;#8230;&gt; &quot;This clause would match any value&quot; &amp;#8230;&gt; end &quot;This clause will match and bind x to 2 in this clause&quot;  기존의 변수에 패턴매치를 사용하고 싶다면 핀 연산자(^)를 사용해야 한다."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://jeidee.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Erlang &amp; Go
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Elixir case, cond and if (#5/21)</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2015-06-11T00:00:00Z">June 11, 2015</time>      
      
      
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>이번 챕터에서는 흐름 제어에 사용되는 case, cond, if에 대해 알아본다.</p>

<h2 id="case">case</h2>

<p>case는 매치되는 하나를 찾기 위해 많은 패턴과 값을 비교할 때 사용한다.</p>

<pre><code>  
iex&gt; case {1, 2, 3} do
  
&amp;#8230;&gt; {4, 5, 6} -&gt;
  
&amp;#8230;&gt; &quot;This clause won't match&quot;
  
&amp;#8230;&gt; {1, x, 3} -&gt;
  
&amp;#8230;&gt; &quot;This clause will match and bind x to 2 in this clause&quot;
  
&amp;#8230;&gt; _ -&gt;
  
&amp;#8230;&gt; &quot;This clause would match any value&quot;
  
&amp;#8230;&gt; end
  
&quot;This clause will match and bind x to 2 in this clause&quot;
  
</code></pre>

<p>기존의 변수에 패턴매치를 사용하고 싶다면 핀 연산자(^)를 사용해야 한다.</p>

<pre><code>  
iex&gt; x = 1
  
1
  
iex&gt; case 10 do
  
&amp;#8230;&gt; ^x -&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; _ -&gt; &quot;Will match&quot;
  
&amp;#8230;&gt; end
  
&quot;Will match&quot;
  
</code></pre>

<p>가드(guards)를 사용해서 추가 조건식을 사용할 수 있다.</p>

<pre><code>  
iex&gt; case {1, 2, 3} do
  
&amp;#8230;&gt; {1, x, 3} when x &gt; 0 -&gt;
  
&amp;#8230;&gt; &quot;Will match&quot;
  
&amp;#8230;&gt; _ -&gt;
  
&amp;#8230;&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; end
  
&quot;Will match&quot;
  
</code></pre>

<p>(가드는 매치를 먼저 수행한후 when 뒤에 추가 조건식을 작성하는 것을 말한다.)</p>

<h2 id="가드-절-guard-clauses-에서의-표현식">가드 절(guard clauses)에서의 표현식</h2>

<p>Erlang VM은 가드에서 사용할 표현식을 다음과 같이 제한하고 있다.</p>

<ul>
<li>비교 연산자(==, !=, ===, !==, &lt;, &gt;, &lt;=, &gt;=)</li>
<li>boolean 연산자(and, or)와 부정 연산자(not, !)</li>
<li>산술 연산자(+, -, *, /)</li>
<li>좌측 값으로 사용되는 &lgt;&gt;와 ++</li>
<li>in 연산자</li>
<li>다음의 타입 검사 함수들

<ul>
<li>is_atom/1</li>
<li>is_binary/1</li>
<li>is_bitstring/1</li>
<li>is_boolean/1</li>
<li>is_float/1</li>
<li>is_function/1</li>
<li>is_function/2</li>
<li>is_integer/1</li>
<li>is_list/1</li>
<li>is_map/1</li>
<li>is_nil/1</li>
<li>is_number/1</li>
<li>is_pid/1</li>
<li>is_port/1</li>
<li>is_reference/1</li>
<li>is_tuple/1</li>
</ul></li>
<li>다음 함수들도 가능하다.

<ul>
<li>abs(number)</li>
<li>bit_size(bitstring)</li>
<li>byte_size(bitstring)</li>
<li>div(integer, integer)</li>
<li>elem(tuple, n)</li>
<li>hd(list)</li>
<li>length(list)</li>
<li>map_size(map)</li>
<li>node()</li>
<li>node(pid | ref | port)</li>
<li>rem(integer, integer)</li>
<li>round(number)</li>
<li>self()</li>
<li>tl(list)</li>
<li>trunc(number)</li>
<li>tuple_size(tuple)</li>
</ul></li>
</ul>

<p>유저가 자신의 가드 함수를 작성한다면 일반적으로 &#8220;is_&#8221;로 시작하는 이름을 사용하도록 한다.</p>

<p>가드 안에서 에러가 발생하면 예외가 발생하지 않고 가드가 실패할 뿐이다.</p>

<pre><code>  
iex&gt; hd(1)
  
** (ArgumentError) argument error
      
:erlang.hd(1)
  
iex&gt; case 1 do
  
&amp;#8230;&gt; x when hd(x) -&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; x -&gt; &quot;Got: #{x}&quot;
  
&amp;#8230;&gt; end
  
&quot;Got 1&quot;
  
</code></pre>

<p>매치하는 절이 없을 경우 에러가 발생한다.(case 절에는 반드시 매치하는 절이 포함되어야 한다.)</p>

<pre><code>  
iex&gt; case :ok do
  
&amp;#8230;&gt; :error -&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; end
  
** (CaseClauseError) no case clause matching: :ok
  
</code></pre>

<p>익명 함수 역시 가드를 사용해 다음과 같이 작성할 수 있다.</p>

<pre><code>  
iex&gt; f = fn
  
&amp;#8230;&gt; x, y when x &gt; 0 -&gt; x + y
  
&amp;#8230;&gt; x, y -&gt; x * y
  
&amp;#8230;&gt; end
  
#Function&lt;12.71889879/2 in :erl_eval.expr/5&gt;
  
iex&gt; f.(1, 3)
  
4
  
iex&gt; f.(-1, 3)
  
-3
  
</code></pre>

<p>익명함수의 매개변수 개수는 각 절(clause)마다 동일해야하고, 그렇지 않을 경우 에러가 발생한다.</p>

<h2 id="cond">cond</h2>

<p>case의 경우 특정 값 기준으로 정확히 매치되는 절을 수행하는데 유용하지만, 많은 경우 여러 조건 중에 첫 번째로 true인 경우(뒤 이은 조건들 중에 true로 평가되는 경우가 있다 하더라도)만 찾기를 원하는 경우가 있다.</p>

<p>이럴 경우 case 대신 다음과 같이 cond를 사용한다.</p>

<pre><code>  
iex&gt; cond do
  
&amp;#8230;&gt; 2 + 2 == 5 -&gt;
  
&amp;#8230;&gt; &quot;This will not be true&quot;
  
&amp;#8230;&gt; 2 * 2 == 3 -&gt;
  
&amp;#8230;&gt; &quot;Nor this&quot;
  
&amp;#8230;&gt; 1 + 1 == 2 -&gt;
  
&amp;#8230;&gt; &quot;But this will&quot;
  
&amp;#8230;&gt; end
  
&quot;But this will&quot;
  
</code></pre>

<p>cond는 일반적인 언어에 있는 else if 구문과 동일하다.</p>

<p>cond의 조건식 중 true인 경우가 없다면 에러가 발생한다. 이런 상황을 방지하려면 항상 마지막 조건으로 true -&gt;를 사용해야 한다.</p>

<pre><code>  
iex&gt; cond do
  
&amp;#8230;&gt; 2 + 2 == 5 -&gt;
  
&amp;#8230;&gt; &quot;This is never true&quot;
  
&amp;#8230;&gt; 2 * 2 == 3 -&gt;
  
&amp;#8230;&gt; &quot;Nor this&quot;
  
&amp;#8230;&gt; true -&gt;
  
&amp;#8230;&gt; &quot;This is always true (equivalent to else)&quot;
  
&amp;#8230;&gt; end
  
&quot;This is always true (equivalent to else)&quot;
  
</code></pre>

<p>cond의 조건식은 nil이나 false가 아닌 경우 모두 true로 평가함을 주의하자.</p>

<pre><code>  
iex&gt; cond do
  
&amp;#8230;&gt; hd([1,2,3]) -&gt;
  
&amp;#8230;&gt; &quot;1 is considered as true&quot;
  
&amp;#8230;&gt; end
  
&quot;1 is considered as true&quot;
  
</code></pre>

<h2 id="if와-unless">if와 unless</h2>

<p>elixir는 case와 cond이외에 단 하나의 조건을 평가하기 위한 용도로 if/2와 unless/2 매크로를 제공한다.</p>

<pre><code>  
iex&gt; if true do
  
&amp;#8230;&gt; &quot;This works!&quot;
  
&amp;#8230;&gt; end
  
&quot;This works!&quot;
  
iex&gt; unless true do
  
&amp;#8230;&gt; &quot;This will never be seen&quot;
  
&amp;#8230;&gt; end
  
nil
  
</code></pre>

<p>if/2 매크로에 주어진 조건식이 false나 nil을 반환하면, body에 해당하는 do/end 블럭의 코드는 실행되지 않고, nil을 리턴한다. (unless/2는 반대)</p>

<p>if/2와 unless/2는 else 블록을 지원한다.</p>

<pre><code>  
iex&gt; if nil do
  
&amp;#8230;&gt; &quot;This won't be seen&quot;
  
&amp;#8230;&gt; else
  
&amp;#8230;&gt; &quot;This will&quot;
  
&amp;#8230;&gt; end
  
&quot;This will&quot;
  
</code></pre>

<blockquote>
<p>if/2와 unless/2는 매크로임을 주목하자. kernel 모듈에서 if/2 소스를 확인할 수 있다. kernel 모듈에는 +/2 연산자와 is_function/2 함수도 정의되어 있고, 별도의 import과정없이 기본적으로 모든 코드에서 사용할 수 있다.</p>
</blockquote>

<h2 id="do-end-블럭">do/end 블럭</h2>

<p>이 시점에서, case, cond, if, unless는 do/end 블럭을 갖는다는 사실을 알게되었을 것이다. 하지만 do/end 블럭 없이 다음과 같이 작성할 수도 있다.</p>

<pre><code>  
iex&gt; if true, do: 1 + 2
  
3
  
</code></pre>

<p>elixir에서 do/end 블럭은 표현식의 그룹(여러 표현식들)을 do:에 편하게 전달하게 도와준다. 다음은 동등한 구문이다.</p>

<pre><code>  
iex&gt; if true do
  
&amp;#8230;&gt; a = 1 + 2
  
&amp;#8230;&gt; a + 10
  
&amp;#8230;&gt; end
  
13
  
iex&gt; if true, do: (
  
&amp;#8230;&gt; a = 1 + 2
  
&amp;#8230;&gt; a + 10
  
&amp;#8230;&gt; )
  
13
  
</code></pre>

<p>두 번째 구문은 키워드 리스트(do/end 블럭 대신 소괄호를 사용)를 사용한다고 말할 수 있다. 다음 구문을 사용해서 else 절을 실행할 수 있다.</p>

<pre><code>  
iex&gt; if false, do: :this, else: :that
  
:that
  
</code></pre>

<p>do/end 블럭을 사용할 때 다음의 경우를 주의해야 한다.</p>

<pre><code>  
iex&gt; is_number if true do
  
&amp;#8230;&gt; 1 + 2
  
&amp;#8230;&gt; end
  
** (RuntimeError) undefined function: if/1
  
</code></pre>

<p>위의 구문은 다음과 같이 해석된다.</p>

<pre><code>  
iex&gt; is_number(if true) do
  
&amp;#8230;&gt; 1 + 2
  
&amp;#8230;&gt; end
  
** (RuntimeError) undefined function: if/1
  
</code></pre>

<p>즉, 의도한 바가 is_number/1의 매개변수로 if 절의 do/end 블럭의 값이 되기를 기대하지만, 위와 같이 작성해서는 원하는 결과를 얻을 수 없고 대신 다음과 같이 작성해야 한다.</p>

<pre><code>  
iex&gt; is_number(if true do
  
&amp;#8230;&gt; 1 + 2
  
&amp;#8230;&gt; end)
  
true
  
</code></pre>

<p>키워드 리스트를 사용해서 모호한 표현(잘못 해석될 수 있는)의 가능성을 제거할 수 있다.</p>

<p>키워드 리스트는 언어에서 중요한 역할을 수행하고, 많은 함수와 매크로에서 매우 일반적이으로 사용된다. 키워드 리스트에 대해서는 다른 챕터에서 더 자세히 살펴볼 기회가 있을 것이다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/case-cond-and-if.html">Elixir case, cond and if</a></li>
</ul>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/tutorial" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">tutorial</a>
   </li>
  
</ul>
<div class="mt6">
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-erlnote-wordpress-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </main>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/2015/06/11/elixir-pattern-matching-421/">Elixir Pattern matching (#4/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/11/elixir-basic-operators/">Elixir Basic operators (#3/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/10/elixir-basic-types/">Elixir Basic types (#2/21)</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://jeidee.github.io/" >
    &copy; 2018 Erlang &amp; Go
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
