<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Elixir case, cond and if (#5/21)</title>
	
	
	<link rel="stylesheet" href="https://jeidee.github.io/css/style.css">
	
	<meta name="generator" content="Hugo 0.31.1" />
</head>
<body>
	<header>
		<a href="https://jeidee.github.io/">Erlang &amp; Go</a>
		<nav>
			<ul>
				
			</ul>
		</nav>
	</header>
	<main>
		<article>
			<h1>Elixir case, cond and if (#5/21)</h1>
			<time>11.06.2015 00:00</time>
			<div>
				

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>이번 챕터에서는 흐름 제어에 사용되는 case, cond, if에 대해 알아본다.</p>

<h2 id="case">case</h2>

<p>case는 매치되는 하나를 찾기 위해 많은 패턴과 값을 비교할 때 사용한다.</p>

<pre><code>  
iex&gt; case {1, 2, 3} do
  
&amp;#8230;&gt; {4, 5, 6} -&gt;
  
&amp;#8230;&gt; &quot;This clause won't match&quot;
  
&amp;#8230;&gt; {1, x, 3} -&gt;
  
&amp;#8230;&gt; &quot;This clause will match and bind x to 2 in this clause&quot;
  
&amp;#8230;&gt; _ -&gt;
  
&amp;#8230;&gt; &quot;This clause would match any value&quot;
  
&amp;#8230;&gt; end
  
&quot;This clause will match and bind x to 2 in this clause&quot;
  
</code></pre>

<p>기존의 변수에 패턴매치를 사용하고 싶다면 핀 연산자(^)를 사용해야 한다.</p>

<pre><code>  
iex&gt; x = 1
  
1
  
iex&gt; case 10 do
  
&amp;#8230;&gt; ^x -&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; _ -&gt; &quot;Will match&quot;
  
&amp;#8230;&gt; end
  
&quot;Will match&quot;
  
</code></pre>

<p>가드(guards)를 사용해서 추가 조건식을 사용할 수 있다.</p>

<pre><code>  
iex&gt; case {1, 2, 3} do
  
&amp;#8230;&gt; {1, x, 3} when x &gt; 0 -&gt;
  
&amp;#8230;&gt; &quot;Will match&quot;
  
&amp;#8230;&gt; _ -&gt;
  
&amp;#8230;&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; end
  
&quot;Will match&quot;
  
</code></pre>

<p>(가드는 매치를 먼저 수행한후 when 뒤에 추가 조건식을 작성하는 것을 말한다.)</p>

<h2 id="가드-절-guard-clauses-에서의-표현식">가드 절(guard clauses)에서의 표현식</h2>

<p>Erlang VM은 가드에서 사용할 표현식을 다음과 같이 제한하고 있다.</p>

<ul>
<li>비교 연산자(==, !=, ===, !==, &lt;, &gt;, &lt;=, &gt;=)</li>
<li>boolean 연산자(and, or)와 부정 연산자(not, !)</li>
<li>산술 연산자(+, -, *, /)</li>
<li>좌측 값으로 사용되는 &lgt;&gt;와 ++</li>
<li>in 연산자</li>
<li>다음의 타입 검사 함수들

<ul>
<li>is_atom/1</li>
<li>is_binary/1</li>
<li>is_bitstring/1</li>
<li>is_boolean/1</li>
<li>is_float/1</li>
<li>is_function/1</li>
<li>is_function/2</li>
<li>is_integer/1</li>
<li>is_list/1</li>
<li>is_map/1</li>
<li>is_nil/1</li>
<li>is_number/1</li>
<li>is_pid/1</li>
<li>is_port/1</li>
<li>is_reference/1</li>
<li>is_tuple/1</li>
</ul></li>
<li>다음 함수들도 가능하다.

<ul>
<li>abs(number)</li>
<li>bit_size(bitstring)</li>
<li>byte_size(bitstring)</li>
<li>div(integer, integer)</li>
<li>elem(tuple, n)</li>
<li>hd(list)</li>
<li>length(list)</li>
<li>map_size(map)</li>
<li>node()</li>
<li>node(pid | ref | port)</li>
<li>rem(integer, integer)</li>
<li>round(number)</li>
<li>self()</li>
<li>tl(list)</li>
<li>trunc(number)</li>
<li>tuple_size(tuple)</li>
</ul></li>
</ul>

<p>유저가 자신의 가드 함수를 작성한다면 일반적으로 &#8220;is_&#8221;로 시작하는 이름을 사용하도록 한다.</p>

<p>가드 안에서 에러가 발생하면 예외가 발생하지 않고 가드가 실패할 뿐이다.</p>

<pre><code>  
iex&gt; hd(1)
  
** (ArgumentError) argument error
      
:erlang.hd(1)
  
iex&gt; case 1 do
  
&amp;#8230;&gt; x when hd(x) -&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; x -&gt; &quot;Got: #{x}&quot;
  
&amp;#8230;&gt; end
  
&quot;Got 1&quot;
  
</code></pre>

<p>매치하는 절이 없을 경우 에러가 발생한다.(case 절에는 반드시 매치하는 절이 포함되어야 한다.)</p>

<pre><code>  
iex&gt; case :ok do
  
&amp;#8230;&gt; :error -&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; end
  
** (CaseClauseError) no case clause matching: :ok
  
</code></pre>

<p>익명 함수 역시 가드를 사용해 다음과 같이 작성할 수 있다.</p>

<pre><code>  
iex&gt; f = fn
  
&amp;#8230;&gt; x, y when x &gt; 0 -&gt; x + y
  
&amp;#8230;&gt; x, y -&gt; x * y
  
&amp;#8230;&gt; end
  
#Function&lt;12.71889879/2 in :erl_eval.expr/5&gt;
  
iex&gt; f.(1, 3)
  
4
  
iex&gt; f.(-1, 3)
  
-3
  
</code></pre>

<p>익명함수의 매개변수 개수는 각 절(clause)마다 동일해야하고, 그렇지 않을 경우 에러가 발생한다.</p>

<h2 id="cond">cond</h2>

<p>case의 경우 특정 값 기준으로 정확히 매치되는 절을 수행하는데 유용하지만, 많은 경우 여러 조건 중에 첫 번째로 true인 경우(뒤 이은 조건들 중에 true로 평가되는 경우가 있다 하더라도)만 찾기를 원하는 경우가 있다.</p>

<p>이럴 경우 case 대신 다음과 같이 cond를 사용한다.</p>

<pre><code>  
iex&gt; cond do
  
&amp;#8230;&gt; 2 + 2 == 5 -&gt;
  
&amp;#8230;&gt; &quot;This will not be true&quot;
  
&amp;#8230;&gt; 2 * 2 == 3 -&gt;
  
&amp;#8230;&gt; &quot;Nor this&quot;
  
&amp;#8230;&gt; 1 + 1 == 2 -&gt;
  
&amp;#8230;&gt; &quot;But this will&quot;
  
&amp;#8230;&gt; end
  
&quot;But this will&quot;
  
</code></pre>

<p>cond는 일반적인 언어에 있는 else if 구문과 동일하다.</p>

<p>cond의 조건식 중 true인 경우가 없다면 에러가 발생한다. 이런 상황을 방지하려면 항상 마지막 조건으로 true -&gt;를 사용해야 한다.</p>

<pre><code>  
iex&gt; cond do
  
&amp;#8230;&gt; 2 + 2 == 5 -&gt;
  
&amp;#8230;&gt; &quot;This is never true&quot;
  
&amp;#8230;&gt; 2 * 2 == 3 -&gt;
  
&amp;#8230;&gt; &quot;Nor this&quot;
  
&amp;#8230;&gt; true -&gt;
  
&amp;#8230;&gt; &quot;This is always true (equivalent to else)&quot;
  
&amp;#8230;&gt; end
  
&quot;This is always true (equivalent to else)&quot;
  
</code></pre>

<p>cond의 조건식은 nil이나 false가 아닌 경우 모두 true로 평가함을 주의하자.</p>

<pre><code>  
iex&gt; cond do
  
&amp;#8230;&gt; hd([1,2,3]) -&gt;
  
&amp;#8230;&gt; &quot;1 is considered as true&quot;
  
&amp;#8230;&gt; end
  
&quot;1 is considered as true&quot;
  
</code></pre>

<h2 id="if와-unless">if와 unless</h2>

<p>elixir는 case와 cond이외에 단 하나의 조건을 평가하기 위한 용도로 if/2와 unless/2 매크로를 제공한다.</p>

<pre><code>  
iex&gt; if true do
  
&amp;#8230;&gt; &quot;This works!&quot;
  
&amp;#8230;&gt; end
  
&quot;This works!&quot;
  
iex&gt; unless true do
  
&amp;#8230;&gt; &quot;This will never be seen&quot;
  
&amp;#8230;&gt; end
  
nil
  
</code></pre>

<p>if/2 매크로에 주어진 조건식이 false나 nil을 반환하면, body에 해당하는 do/end 블럭의 코드는 실행되지 않고, nil을 리턴한다. (unless/2는 반대)</p>

<p>if/2와 unless/2는 else 블록을 지원한다.</p>

<pre><code>  
iex&gt; if nil do
  
&amp;#8230;&gt; &quot;This won't be seen&quot;
  
&amp;#8230;&gt; else
  
&amp;#8230;&gt; &quot;This will&quot;
  
&amp;#8230;&gt; end
  
&quot;This will&quot;
  
</code></pre>

<blockquote>
<p>if/2와 unless/2는 매크로임을 주목하자. kernel 모듈에서 if/2 소스를 확인할 수 있다. kernel 모듈에는 +/2 연산자와 is_function/2 함수도 정의되어 있고, 별도의 import과정없이 기본적으로 모든 코드에서 사용할 수 있다.</p>
</blockquote>

<h2 id="do-end-블럭">do/end 블럭</h2>

<p>이 시점에서, case, cond, if, unless는 do/end 블럭을 갖는다는 사실을 알게되었을 것이다. 하지만 do/end 블럭 없이 다음과 같이 작성할 수도 있다.</p>

<pre><code>  
iex&gt; if true, do: 1 + 2
  
3
  
</code></pre>

<p>elixir에서 do/end 블럭은 표현식의 그룹(여러 표현식들)을 do:에 편하게 전달하게 도와준다. 다음은 동등한 구문이다.</p>

<pre><code>  
iex&gt; if true do
  
&amp;#8230;&gt; a = 1 + 2
  
&amp;#8230;&gt; a + 10
  
&amp;#8230;&gt; end
  
13
  
iex&gt; if true, do: (
  
&amp;#8230;&gt; a = 1 + 2
  
&amp;#8230;&gt; a + 10
  
&amp;#8230;&gt; )
  
13
  
</code></pre>

<p>두 번째 구문은 키워드 리스트(do/end 블럭 대신 소괄호를 사용)를 사용한다고 말할 수 있다. 다음 구문을 사용해서 else 절을 실행할 수 있다.</p>

<pre><code>  
iex&gt; if false, do: :this, else: :that
  
:that
  
</code></pre>

<p>do/end 블럭을 사용할 때 다음의 경우를 주의해야 한다.</p>

<pre><code>  
iex&gt; is_number if true do
  
&amp;#8230;&gt; 1 + 2
  
&amp;#8230;&gt; end
  
** (RuntimeError) undefined function: if/1
  
</code></pre>

<p>위의 구문은 다음과 같이 해석된다.</p>

<pre><code>  
iex&gt; is_number(if true) do
  
&amp;#8230;&gt; 1 + 2
  
&amp;#8230;&gt; end
  
** (RuntimeError) undefined function: if/1
  
</code></pre>

<p>즉, 의도한 바가 is_number/1의 매개변수로 if 절의 do/end 블럭의 값이 되기를 기대하지만, 위와 같이 작성해서는 원하는 결과를 얻을 수 없고 대신 다음과 같이 작성해야 한다.</p>

<pre><code>  
iex&gt; is_number(if true do
  
&amp;#8230;&gt; 1 + 2
  
&amp;#8230;&gt; end)
  
true
  
</code></pre>

<p>키워드 리스트를 사용해서 모호한 표현(잘못 해석될 수 있는)의 가능성을 제거할 수 있다.</p>

<p>키워드 리스트는 언어에서 중요한 역할을 수행하고, 많은 함수와 매크로에서 매우 일반적이으로 사용된다. 키워드 리스트에 대해서는 다른 챕터에서 더 자세히 살펴볼 기회가 있을 것이다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/case-cond-and-if.html">Elixir case, cond and if</a></li>
</ul>

			</div>
			<div>
				<ul id="tags">
					
					<li><a href="/tags/tutorial">tutorial</a> </li>
					
				</ul>
			</div>
			<div>
				
			</div>
		</article>
	</main>
	<aside>
		<div>
			<div>
				<h3>LATEST POSTS</h3>
			</div>
			<div>
				<ul>
					
					<li><a href="https://jeidee.github.io/2017/08/31/upstart-ec84a4eca095/">upstart 설정</a></li>
					
					<li><a href="https://jeidee.github.io/2017/06/08/centosec9790ec849c-mongodb-ec84a4ecb998ec9980-service-eb93b1eba19d/">CentOS에서 MongoDB 설치와 Service 등록</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/couchbase-cberlec9790-lcb_cntl-ed95a8ec8898-ecb694eab080/">couchbase cberl에 lcb_cntl 함수 추가</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/couchbase-cberlec9d98io-pluginec9d84-libeventeba19c-ebb380eab2bd/">couchbase cberl의IO Plugin을 libevent로 변경</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/ejabberdec9d98-deps-eb9dbcec9db4ebb88ceb9faceba6ac-ec8898eca095-ed9b84-ecbbb4ed8c8cec9dbcec9790ec849c-eb8884eb9dbdeb90a0-eb958c/">ejabberd의 deps 라이브러리 수정 후 컴파일에서 누락될 때</a></li>
					
				</ul>
			</div>
		</div>
	</aside>

	<footer>
		<p>&copy; 2017 <a href="https://jeidee.github.io/">Erlang &amp; Go</a></p>
	</footer>
</body>
</html>