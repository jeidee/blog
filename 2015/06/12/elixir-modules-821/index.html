<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Elixir Modules (#8/21)</title>
	
	
	<link rel="stylesheet" href="https://jeidee.github.io/css/style.css">
	
	<meta name="generator" content="Hugo 0.31.1" />
</head>
<body>
	<header>
		<a href="https://jeidee.github.io/">Erlang &amp; Go</a>
		<nav>
			<ul>
				
			</ul>
		</nav>
	</header>
	<main>
		<article>
			<h1>Elixir Modules (#8/21)</h1>
			<time>12.06.2015 00:00</time>
			<div>
				

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>elixir에서 우리는 모듈에 여러 함수를 그룹지을 수 있다. 우리는 이전 챕터에서 String 모듈 같은 여러 다른 모듈들을 사용했다.</p>

<pre><code>  
iex&gt; String.length &quot;hello&quot;
  
5
  
</code></pre>

<p>elixir에서 우리만의 모듈을 만들기 위해, 우리는 defmodule 매크로를 사용해야 한다. 우리는 우리의 모듈에서 함수를 정의하기 위해 def 매크로를 사용할 수 있다.</p>

<pre><code>  
iex&gt; defmodule Math do
  
&amp;#8230;&gt; def sum(a, b) do
  
&amp;#8230;&gt; a + b
  
&amp;#8230;&gt; end
  
&amp;#8230;&gt; end

iex&gt; Math.sum(1, 2)
  
3
  
</code></pre>

<p>다음 섹션에서, 우리의 예제는 좀 더 복잡해질 것이고, 쉘에서 그 모듈이 마치 타입 처럼 동작하는 것을 보게 될 것이다. 이쯤에서 elixir 코드를 어떻게 컴파일하고 elixir 스크립트를 어떻게 실행할 수 있는지 배워보자.</p>

<h2 id="compilation">Compilation</h2>

<p>모듈을 파일에 작성하면 컴파일하고 재사용할 수 있기 때문에 매우 편리하다. 우리가 만들 모듈이 다음과 같은 내용을 포함하며 파일명이 math.ex라고 가정하자.</p>

<pre><code>  
defmodule Math do
    
def sum(a, b) do
      
a + b
    
end
  
end
  
</code></pre>

<p>이 파일은 elixirc를 사용해 다음과 같이 컴파일할 수 있다.</p>

<pre><code>  
$ elixirc math.ex
  
</code></pre>

<p>컴파일 결과로 해당 모듈의 바이트코드를 포함하는 Elixir.Math.beam 파일이 생성될 것이다. iex를 다시 시작하고, 우리의 모듈이 잘 작동하는지 확인해 보자.(iex는 beam파일이 있는 디렉토리에서 실행해야 한다.)</p>

<pre><code>  
iex&gt; Math.sum(1, 2)
  
3
  
</code></pre>

<p>elixir 프로젝트는 일반적으로 다음 세개의 디렉토리로 구성된다.</p>

<ul>
<li>ebin &#8211; 컴파일된 바이트코드를 포함</li>
<li>lib &#8211; elixir 코드(일반적으로 .ex 파일들)를 포함</li>
<li>test &#8211; 테스트 코드를 포함(일반적으로 .exs 파일들)</li>
</ul>

<p>실제 프로젝트로 작업할 때에는, mix라고 불리는 빌드 툴을 사용해 적합한 경로를 구성하고 컴파일하게 될 것이다.</p>

<p>배움의 목적으로, elixir가 컴파일 과정 없이 좀 더 유연하게 사용할 수 있는 스크립트 모드를 지원한다는 것을 알아두자.</p>

<h2 id="scripted-mode">Scripted mode</h2>

<p>.ex 파일에 더해, elixir는 스크립팅을 위한 .exs 파일을 지원한다. elixir는 정확히 같은 방식으로 두 파일을 처리하는데, 차이는 단지 목적(용도)에 있다. .ex 파일은 컴파일 목적이고, .exs 파일은 컴파일 과정이 필요없는 스크립팅 목적으로 사용한다. 예를 들어, 우리가 다음과 같은 math.exs라는 파일을 만들었다고 보자.</p>

<pre><code>  
defmodule Math do
    
def sum(a, b) do
      
a + b
    
end
  
end

IO.puts Math.sum(1, 2)
  
</code></pre>

<p>이 파일은 다음과 같이 실행할 수 있다.</p>

<pre><code>  
$ elixir math.exs
  
</code></pre>

<p>해당 파일은 메모리상에서 컴파일되고 실행되어 결과로 &#8220;3&#8221;을 출력할 것이다. 어떤 바이트코드도 생성되지 않는다.</p>

<h2 id="named-functions">Named functions</h2>

<p>모듈안에서, 우리는 def/2(매개변수 2개를 갖는) public 함수를 정의하고 defp/2 private 함수를 정의할 수 있다. def/2 함수는 다른 모듈에서 호출할 수 있지만, defp/2 함수는 동일 모듈(invoked locally)에서만 호출할 수 있다.</p>

<pre><code>  
defmodule Math do
    
def sum(a, b) do
      
do_sum(a, b)
    
end

defp do_sum(a, b) do
      
a + b
    
end
  
end

Math.sum(1, 2) #=&gt; 3
  
Math.do_sum(1, 2) #=&gt; ** (UndefinedFunctionError)
  
</code></pre>

<p>함수 선언 역시 복수의 절(clauses)과 가드(guards)를 지원한다. 함수가 여러 절을 갖는다면, elixir는 매치하는 절을 찾을 때까지 각 절을 평가할 것이다.</p>

<p>여기에 주어진 숫자가 0인지 아닌지 검사하는 함수 구현이 있다.</p>

<pre><code>  
defmodule Math do
    
def zero?(0) do
      
true
    
end

def zero?(x) when is_number(x) do
      
false
    
end
  
end

Math.zero?(0) #=&gt; true
  
Math.zero?(1) #=&gt; false

Math.zero?([1,2,3])
  
#=&gt; ** (FunctionClauseError)
  
</code></pre>

<p>주어진 매개변수와 일치하는 절을 갖는 함수가 없을 경우 에러가 발생할 것이다.</p>

<h2 id="function-capturing">Function capturing</h2>

<p>지금까지 우리는 함수의 표기법을 name/arity와 같이 표기해 왔다. 이 표기는 함수 타입으로 이름 있는 함수를 받을때 사용할 수 있다. 위에서 사용한 math.exs를 iex를 사용해서 시작해 보자.</p>

<pre><code>  
$ iex math.exs
  
</code></pre>

<pre><code>  
iex&gt; Math.zero?(0)
  
true
  
iex&gt; fun = &amp;Math.zero?/1
  
&amp;Math.zero?/1
  
iex&gt; is_function fun
  
true
  
iex&gt; fun.(0)
  
true
  
</code></pre>

<p>지역 함수나 이미 포함된(imported) 함수(is_function/1 같은)는 모듈명 없이 캡춰할 수 있다.</p>

<pre><code>  
iex&gt; &amp;is_function/1
  
&amp;:erlang.is_function/1
  
iex&gt; (&amp;is_function/1).(fun)
  
true
  
</code></pre>

<p>캡춰 구문은 또한 함수를 생성하는 축약된 형태로 사용될 수도 있음을 명심한다.</p>

<pre><code>  
iex&gt; fun = &amp;(&amp;1 + 1)
  
#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;
  
iex&gt; fun.(1)
  
2
  
</code></pre>

<p>&amp;1은 함수에 전달된 첫 번째 매개변수를 표현한다. &amp;(&amp;1 + 1)은 정확히 fn x -&gt; x + 1 end 와 동일하다. 위 구문은 함수 정의를 축약하는데 도움을 준다.</p>

<p>같은 방법으로 모듈에서 함수를 호출하고 싶다면, &amp;Module.function() 구문을 사용할 수 있다.</p>

<pre><code>  
iex&gt; fun = &amp;List.flatten(&amp;1, &amp;2)
  
&amp;List.flatten/2
  
iex&gt; fun.([1, [[2], 3]], [4, 5])
  
[1, 2, 3, 4, 5]
  
</code></pre>

<p>&amp;List.flatten(&amp;1, &amp;2)은 fn(list, tail) -&gt; List.flatten(list, tail) end와 동일하다. 캡춰 연산자에 대해 더 자세히 알고 싶다면 &#8220;<a href="http://elixir-lang.org/docs/stable/elixir/#!Kernel.SpecialForms.html#&amp;/1">kernel.SpecialForms 문서</a>&#8220;를 참고하도록 한다.</p>

<h2 id="default-arguments">Default arguments</h2>

<p>elixir에서 이름있는 함수는 기본 매개변수를 지원한다.</p>

<pre><code>  
defmodule Concat do
    
def join(a, b, sep \ &quot; &quot;) do
      
a &lt;&gt; sep &lt;&gt; b
    
end
  
end

IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;) #=&gt; Hello world
  
IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;, &quot;\_&quot;) #=&gt; Hello\_world
  
</code></pre>

<p>어떤 표현식도 기본 값으로 사용할 수 있지만, 함수가 정의되는 동안 평가되진 않을 것이다; 단지 나중에 사용되기 위해 저장될 뿐이다. 매번 함수가 호출될때마다 기본 값은 사용되며, 기본 값이 평가된다.</p>

<pre><code>  
defmodule DefaultTest do
    
def dowork(x \ IO.puts &quot;hello&quot;) do
      
x
    
end
  
end
  
</code></pre>

<pre><code>  
iex&gt; DefaultTest.dowork
  
hello
  
:ok
  
iex&gt; DefaultTest.dowork 123
  
123
  
iex&gt; DefaultTest.dowork
  
hello
  
:ok
  
</code></pre>

<p>기본 값이 있는 함수가 복수의 절을 갖을 경우에는 함수의 선언부(구현부가 없는)가 있어야 하고 기본값을 선언하기 위한 용도로만 사용된다.</p>

<pre><code>  
defmodule Concat do
    
def join(a, b \ nil, sep \ &quot; &quot;)

def join(a, b, \_sep) when is\_nil(b) do
      
a
    
end

def join(a, b, sep) do
      
a &lt;&gt; sep &lt;&gt; b
    
end
  
end

IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;) #=&gt; Hello world
  
IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;, &quot;\_&quot;) #=&gt; Hello\_world
  
IO.puts Concat.join(&quot;Hello&quot;) #=&gt; Hello
  
</code></pre>

<p>기본 값을 사용할 때, 함수 정의가 중복되지 않도록 주의해야 한다. 다음 예를 보자.</p>

<pre><code>  
defmodule Concat do
    
def join(a, b) do
      
IO.puts &quot;\***First join&quot;
      
a &lt;&gt; b
    
end

def join(a, b, sep \ &quot; &quot;) do
      
IO.puts &quot;\***Second join&quot;
      
a &lt;&gt; sep &lt;&gt; b
    
end
  
end
  
</code></pre>

<p>위 내용을 &#8220;concat.ex&#8221;라는 파일명으로 저장하고 컴파일 하면 elixir는 다음과 같은 경고를 출력한다.</p>

<pre><code>  
concat.ex:7: this clause cannot match because a previous clause at line 2 always matches
  
</code></pre>

<p>컴파일러는 두 개의 매개변수를 사용한 join 함수 호출시에는 항상 첫 번째 정의된 join/2함수가 호출되면 기본값이 사용된 두 번째 join/3 함수는 3개의 매개변수를 사용할 때만 호출된다고 알려준다.</p>

<pre><code>  
$ iex concat.exs
  
</code></pre>

<pre><code>  
iex&gt; Concat.join &quot;Hello&quot;, &quot;world&quot;
  
\***First join
  
&quot;Helloworld&quot;
  
</code></pre>

<pre><code>  
iex&gt; Concat.join &quot;Hello&quot;, &quot;world&quot;, &quot;_&quot;
  
\***Second join
  
&quot;Hello_world&quot;
  
</code></pre>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/modules.html">Elixir Modules</a></li>
</ul>

			</div>
			<div>
				<ul id="tags">
					
					<li><a href="/tags/tutorial">tutorial</a> </li>
					
				</ul>
			</div>
			<div>
				<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-erlnote-wordpress-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
			</div>
		</article>
	</main>
	<aside>
		<div>
			<div>
				<h3>LATEST POSTS</h3>
			</div>
			<div>
				<ul>
					
					<li><a href="https://jeidee.github.io/2017/08/31/upstart-ec84a4eca095/">upstart 설정</a></li>
					
					<li><a href="https://jeidee.github.io/2017/06/08/centosec9790ec849c-mongodb-ec84a4ecb998ec9980-service-eb93b1eba19d/">CentOS에서 MongoDB 설치와 Service 등록</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/couchbase-cberlec9790-lcb_cntl-ed95a8ec8898-ecb694eab080/">couchbase cberl에 lcb_cntl 함수 추가</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/couchbase-cberlec9d98io-pluginec9d84-libeventeba19c-ebb380eab2bd/">couchbase cberl의IO Plugin을 libevent로 변경</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/ejabberdec9d98-deps-eb9dbcec9db4ebb88ceb9faceba6ac-ec8898eca095-ed9b84-ecbbb4ed8c8cec9dbcec9790ec849c-eb8884eb9dbdeb90a0-eb958c/">ejabberd의 deps 라이브러리 수정 후 컴파일에서 누락될 때</a></li>
					
				</ul>
			</div>
		</div>
	</aside>

	<footer>
		<p>&copy; 2017 <a href="https://jeidee.github.io/">Erlang &amp; Go</a></p>
	</footer>
</body>
</html>