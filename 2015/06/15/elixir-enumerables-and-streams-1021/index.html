<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Elixir Enumerables and Streams (#10/21)</title>
	
	
	<link rel="stylesheet" href="https://jeidee.github.io/css/style.css">
	
	<meta name="generator" content="Hugo 0.31.1" />
</head>
<body>
	<header>
		<a href="https://jeidee.github.io/">Erlang &amp; Go</a>
		<nav>
			<ul>
				
			</ul>
		</nav>
	</header>
	<main>
		<article>
			<h1>Elixir Enumerables and Streams (#10/21)</h1>
			<time>15.06.2015 00:00</time>
			<div>
				

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<h2 id="enumerables">Enumerables</h2>

<p>elixir는 열거가능한 자료구조(enumerables) 컨셉과 그들을 처리하기 위한 Enum 모듈을 제공한다. 우리는 이미 두 개의 열거가능한 자료구조(lists and maps)를 배웠다.</p>

<pre><code>  
iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end)
  
[2, 4, 6]
  
iex&gt; Enum.map(%{1 =&gt; 2, 3 =&gt; 4}, fn {k, v} -&gt; k * v end)
  
[2, 12]
  
</code></pre>

<p>Enum 모듈은 열거가능한 자료구조에서 transform(변형), sort(정렬), group, filter등의 처리를 통해 아이템을 얻을 수 있는 수많은 함수들을 제공한다. Enum 모듈은 elixir 코드에서 개발자들이 자주 자용하는 모듈 중 하나이다.</p>

<p>elixir는 범위 표현을 위해 다음 구문을 제공한다:</p>

<pre><code>  
iex&gt; Enum.map(1..3, fn x -&gt; x * 2 end)
  
[2, 4, 6]
  
iex&gt; Enum.reduce(1..3, 0, &amp;+/2)
  
6
  
</code></pre>

<p>Enum 모듈은 서로 다른 데이터 타입을 처리하기 위해 설계되었으므로, Enum 모듈의 API는 많은 데이터 타입을 함께 처리하기 위해 함수를 제한적으로 사용한다. 특정 동작들의 경우, 모듈에 접근할 때 데이터타입을 명시해야 한다. 예를 들어, 리스트의 특정 위치에 요소를 삽입하고자 할 때, List 모듈의 List.insert_at/3 함수를 사용해야 하는데, 해당 함수는 범위에 값을 삽입하는 동작을 수행한다.</p>

<p>Enum 모듈의 함수는 서로 다른 데이터 타입을 처리할 수 있어야 하기 때문에, 다형성을 갖는다고 할 수 있다. 특히, Enum 모듈의 함수는 Enumerable 프로토콜을 구현하는 어떤 데이터 타입이라도 취급할 수 있다. 이 프로토콜에 대해서는 다음 챕터에서 살펴보도록 하고 먼저 스트림이라 불리는 특수한 열거형에 대해 살펴보도록 한다.</p>

<h2 id="eager-vs-lazy">Eager vs Lazy</h2>

<p>Enum 모듈의 모든 함수는 즉시(eager) 평가된다. 많은 함수들은 열거한 후 리스트를 반환하기를 기대한다.</p>

<pre><code>  
iex&gt; odd? = &amp;(rem(&amp;1, 2) != 0)
  
#Function&lt;6.80484245/1 in :erl_eval.expr/5&gt;
  
iex&gt; Enum.filter(1..3, odd?)
  
[1, 3]
  
</code></pre>

<p>이것은 Enum모듈과 여러 동작을 수행할 때, 각 동작은 우리가 결과를 얻을 때까지 임시 리스트를 생성하다는 것을 의미한다.</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Enum.map(&amp;(&amp;1 * 3)) |&gt; Enum.filter(odd?) |&gt; Enum.sum
  
7500000000
  
</code></pre>

<p>위의 예는 동작의 파이프라인을 갖는다. 우리는 숫자의 범위에서 시작해서 각 요소에 3을 곱한다. 이 첫 번째 동작의 결과로 100_000개의 아이템을 갖는 리스트를 반환할 것이다. 그런 후 우리는 그 리스트에서 홀수만 취하는 50_000 개의 아이템을 갖는 리스트를 새로 만들고, 각 엔트리(요소)를 모두 더한 결과를 반환한다.</p>

<h2 id="the-pipe-operator">The pipe operator</h2>

<p>|&gt; 기호는 파이프 연산자이다. 이 연산자는 단순히 왼쪽 연산의 결과를 오른쪽 표현식의 입력으로 건네주는 역할을 수행한다. 이 연산자는 유닉스의 | 연산자와 유사하다. 이 예제의 목적은 연속적인 함수에 의해 변형되는 데이터의 흐름을 강조하기 위한 것이다. 이 연산자가 어떻게 코드를 깨끗하게 만들어주는지, 위의 예제와 똑같이 동작하는 아래 예제와 비교해 보도록 하자.</p>

<pre><code>  
iex&gt; Enum.sum(Enum.filter(Enum.map(1..100_000, &amp;(&amp;1 * 3)), odd?))
  
7500000000
  
</code></pre>

<p>파이프 연산자에 대해 더 알고 싶다면, <a href="http://elixir-lang.org/docs/stable/elixir/#!Kernel.html#%7C%3E/2">이 문서</a>를 읽어보도록 한다.</p>

<h2 id="streams">Streams</h2>

<p>elixir에서 Enum 모듈을 대체하는 Stream 모듈을 제공하는데, 게으른 평가(Lazy operations)을 지원한다.</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) |&gt; Stream.filter(odd?) |&gt; Enum.sum
  
7500000000
  
</code></pre>

<p>스트림은 게으르고 구성가능한 열거형이다. 즉시 리스트를 생성하지 않고, 연속된 계산만 만들어 둔 후 Enum 모듈에서 사용될 때에만 비로소 평가된다. 스트림은 큰(어쩌면 무한대의) 컬렉션에 사용하면 유용하다.</p>

<p>위의 예제에서 보여 주듯이, 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) 표현식은 스트림의 데이터타입을 반환하고 단지 1..100_000 사이의 map 계산만 표현하게 된다.(이 시점에 실제 계산은 수행되지 않는다.)</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3))
  
#Stream&lt;[enum: 1..100000, funs: [#Function&lt;34.16982430/1 in Stream.map/2&gt;]]&gt;
  
</code></pre>

<p>게다가 스트림은 파이프 연산자를 통해 여러 개의 스트림을 하나의 스트림으로 구성(composable)할 수 있다.</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) |&gt; Stream.filter(odd?)
  
#Stream&lt;[enum: 1..100000, funs: [&amp;#8230;]]&gt;
  
</code></pre>

<p>Stream 모듈의 많은 함수가 매개변수로 어떤 열거형도 받을 수 있고 결과로 스트림을 반환한다. 무한대의 스트림을 생성하는 함수도 있다. 예를 들어, Stream.cycle/1 함수는 주어진 열거형을 무한히 순환할 수 있는 스트림을 생성한다. 그런 스트림에 Enum.map/2 함수를 호출하면 영원히 순환에 빠지므로 조심해서 사용해야 한다.</p>

<pre><code>  
iex&gt; stream = Stream.cycle([1, 2, 3])
  
#Function&lt;15.16982430/2 in Stream.cycle/1&gt;
  
iex&gt; Enum.take(stream, 10)
  
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1]
  
</code></pre>

<p>Stream.unfold/2 함수는 주어진 초기 값으로부터 여러 값들을 생성하는데 사용할 수 있다.</p>

<pre><code>  
iex&gt; stream = Stream.unfold(&quot;hełło&quot;, &amp;String.next_codepoint/1)
  
#Function&lt;39.75994740/2 in Stream.unfold/2&gt;
  
iex&gt; Enum.take(stream, 3)
  
[&quot;h&quot;, &quot;e&quot;, &quot;ł&quot;]
  
</code></pre>

<p>또다른 재밌는 함수로 리소스를 감싸는데 사용되는 Stream.resource/3의 경우 열거하기 전에 올바르게 열려 있음을 보장하고 실패가 발생할 경우 닫힘을 보장한다. 예를 들어, 우리는 파일 스트림을 위해 다음과 같이 사용할 수 있다.</p>

<pre><code>  
iex&gt; stream = File.stream!(&quot;path/to/file&quot;)
  
#Function&lt;18.16982430/2 in Stream.resource/3&gt;
  
iex&gt; Enum.take(stream, 10)
  
</code></pre>

<p>위의 예제는 선택된 파일에서 먼저 10 줄을 가져온다. 이것은 큰 파일이나 네트워크같이 느린 리소스를 처리하는데 스트림이 매우 유용함을 뜻한다.</p>

<p>Enum과 Stream 모듈의 많은 양의 함수의 기능들에 압도될 수 있지만, 개별 케이스별로 매우 유사하기 때문에, 먼저 Enum 모듈에 집중하고 추후에 크고 느린 리소스를 처리할 때 Stream 모듈로 관심을 옮기는 것이 좋다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/enumerables-and-streams.html">Elixir Enumerables and Streams</a></li>
</ul>

			</div>
			<div>
				<ul id="tags">
					
					<li><a href="/tags/tutorial">tutorial</a> </li>
					
				</ul>
			</div>
			<div>
				<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-erlnote-wordpress-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
			</div>
		</article>
	</main>
	<aside>
		<div>
			<div>
				<h3>LATEST POSTS</h3>
			</div>
			<div>
				<ul>
					
					<li><a href="https://jeidee.github.io/2017/08/31/upstart-ec84a4eca095/">upstart 설정</a></li>
					
					<li><a href="https://jeidee.github.io/2017/06/08/centosec9790ec849c-mongodb-ec84a4ecb998ec9980-service-eb93b1eba19d/">CentOS에서 MongoDB 설치와 Service 등록</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/couchbase-cberlec9790-lcb_cntl-ed95a8ec8898-ecb694eab080/">couchbase cberl에 lcb_cntl 함수 추가</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/couchbase-cberlec9d98io-pluginec9d84-libeventeba19c-ebb380eab2bd/">couchbase cberl의IO Plugin을 libevent로 변경</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/ejabberdec9d98-deps-eb9dbcec9db4ebb88ceb9faceba6ac-ec8898eca095-ed9b84-ecbbb4ed8c8cec9dbcec9790ec849c-eb8884eb9dbdeb90a0-eb958c/">ejabberd의 deps 라이브러리 수정 후 컴파일에서 누락될 때</a></li>
					
				</ul>
			</div>
		</div>
	</aside>

	<footer>
		<p>&copy; 2017 <a href="https://jeidee.github.io/">Erlang &amp; Go</a></p>
	</footer>
</body>
</html>