<!DOCTYPE html>
<html lang="ko-kr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Erlang &amp; Go  | Elixir Enumerables and Streams (#10/21)</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.51" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="Elixir Enumerables and Streams (#10/21)" />
<meta property="og:description" content="본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 Enumerables elixir는 열거가능한 자료구조(enumerables) 컨셉과 그들을 처리하기 위한 Enum 모듈을 제공한다. 우리는 이미 두 개의 열거가능한 자료구조(lists and maps)를 배웠다.
 iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end) [2, 4, 6] iex&gt; Enum.map(%{1 =&gt; 2, 3 =&gt; 4}, fn {k, v} -&gt; k * v end) [2, 12]  Enum 모듈은 열거가능한 자료구조에서 transform(변형), sort(정렬), group, filter등의 처리를 통해 아이템을 얻을 수 있는 수많은 함수들을 제공한다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jeidee.github.io/2015/06/15/elixir-enumerables-and-streams-1021/" /><meta property="article:published_time" content="2015-06-15T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2015-06-15T00:00:00&#43;00:00"/>

<meta itemprop="name" content="Elixir Enumerables and Streams (#10/21)">
<meta itemprop="description" content="본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 Enumerables elixir는 열거가능한 자료구조(enumerables) 컨셉과 그들을 처리하기 위한 Enum 모듈을 제공한다. 우리는 이미 두 개의 열거가능한 자료구조(lists and maps)를 배웠다.
 iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end) [2, 4, 6] iex&gt; Enum.map(%{1 =&gt; 2, 3 =&gt; 4}, fn {k, v} -&gt; k * v end) [2, 12]  Enum 모듈은 열거가능한 자료구조에서 transform(변형), sort(정렬), group, filter등의 처리를 통해 아이템을 얻을 수 있는 수많은 함수들을 제공한다.">


<meta itemprop="datePublished" content="2015-06-15T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2015-06-15T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="676">



<meta itemprop="keywords" content="tutorial," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Elixir Enumerables and Streams (#10/21)"/>
<meta name="twitter:description" content="본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 Enumerables elixir는 열거가능한 자료구조(enumerables) 컨셉과 그들을 처리하기 위한 Enum 모듈을 제공한다. 우리는 이미 두 개의 열거가능한 자료구조(lists and maps)를 배웠다.
 iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end) [2, 4, 6] iex&gt; Enum.map(%{1 =&gt; 2, 3 =&gt; 4}, fn {k, v} -&gt; k * v end) [2, 12]  Enum 모듈은 열거가능한 자료구조에서 transform(변형), sort(정렬), group, filter등의 처리를 통해 아이템을 얻을 수 있는 수많은 함수들을 제공한다."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://jeidee.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Erlang &amp; Go
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Elixir Enumerables and Streams (#10/21)</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2015-06-15T00:00:00Z">June 15, 2015</time>      
      
      
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<h2 id="enumerables">Enumerables</h2>

<p>elixir는 열거가능한 자료구조(enumerables) 컨셉과 그들을 처리하기 위한 Enum 모듈을 제공한다. 우리는 이미 두 개의 열거가능한 자료구조(lists and maps)를 배웠다.</p>

<pre><code>  
iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end)
  
[2, 4, 6]
  
iex&gt; Enum.map(%{1 =&gt; 2, 3 =&gt; 4}, fn {k, v} -&gt; k * v end)
  
[2, 12]
  
</code></pre>

<p>Enum 모듈은 열거가능한 자료구조에서 transform(변형), sort(정렬), group, filter등의 처리를 통해 아이템을 얻을 수 있는 수많은 함수들을 제공한다. Enum 모듈은 elixir 코드에서 개발자들이 자주 자용하는 모듈 중 하나이다.</p>

<p>elixir는 범위 표현을 위해 다음 구문을 제공한다:</p>

<pre><code>  
iex&gt; Enum.map(1..3, fn x -&gt; x * 2 end)
  
[2, 4, 6]
  
iex&gt; Enum.reduce(1..3, 0, &amp;+/2)
  
6
  
</code></pre>

<p>Enum 모듈은 서로 다른 데이터 타입을 처리하기 위해 설계되었으므로, Enum 모듈의 API는 많은 데이터 타입을 함께 처리하기 위해 함수를 제한적으로 사용한다. 특정 동작들의 경우, 모듈에 접근할 때 데이터타입을 명시해야 한다. 예를 들어, 리스트의 특정 위치에 요소를 삽입하고자 할 때, List 모듈의 List.insert_at/3 함수를 사용해야 하는데, 해당 함수는 범위에 값을 삽입하는 동작을 수행한다.</p>

<p>Enum 모듈의 함수는 서로 다른 데이터 타입을 처리할 수 있어야 하기 때문에, 다형성을 갖는다고 할 수 있다. 특히, Enum 모듈의 함수는 Enumerable 프로토콜을 구현하는 어떤 데이터 타입이라도 취급할 수 있다. 이 프로토콜에 대해서는 다음 챕터에서 살펴보도록 하고 먼저 스트림이라 불리는 특수한 열거형에 대해 살펴보도록 한다.</p>

<h2 id="eager-vs-lazy">Eager vs Lazy</h2>

<p>Enum 모듈의 모든 함수는 즉시(eager) 평가된다. 많은 함수들은 열거한 후 리스트를 반환하기를 기대한다.</p>

<pre><code>  
iex&gt; odd? = &amp;(rem(&amp;1, 2) != 0)
  
#Function&lt;6.80484245/1 in :erl_eval.expr/5&gt;
  
iex&gt; Enum.filter(1..3, odd?)
  
[1, 3]
  
</code></pre>

<p>이것은 Enum모듈과 여러 동작을 수행할 때, 각 동작은 우리가 결과를 얻을 때까지 임시 리스트를 생성하다는 것을 의미한다.</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Enum.map(&amp;(&amp;1 * 3)) |&gt; Enum.filter(odd?) |&gt; Enum.sum
  
7500000000
  
</code></pre>

<p>위의 예는 동작의 파이프라인을 갖는다. 우리는 숫자의 범위에서 시작해서 각 요소에 3을 곱한다. 이 첫 번째 동작의 결과로 100_000개의 아이템을 갖는 리스트를 반환할 것이다. 그런 후 우리는 그 리스트에서 홀수만 취하는 50_000 개의 아이템을 갖는 리스트를 새로 만들고, 각 엔트리(요소)를 모두 더한 결과를 반환한다.</p>

<h2 id="the-pipe-operator">The pipe operator</h2>

<p>|&gt; 기호는 파이프 연산자이다. 이 연산자는 단순히 왼쪽 연산의 결과를 오른쪽 표현식의 입력으로 건네주는 역할을 수행한다. 이 연산자는 유닉스의 | 연산자와 유사하다. 이 예제의 목적은 연속적인 함수에 의해 변형되는 데이터의 흐름을 강조하기 위한 것이다. 이 연산자가 어떻게 코드를 깨끗하게 만들어주는지, 위의 예제와 똑같이 동작하는 아래 예제와 비교해 보도록 하자.</p>

<pre><code>  
iex&gt; Enum.sum(Enum.filter(Enum.map(1..100_000, &amp;(&amp;1 * 3)), odd?))
  
7500000000
  
</code></pre>

<p>파이프 연산자에 대해 더 알고 싶다면, <a href="http://elixir-lang.org/docs/stable/elixir/#!Kernel.html#%7C%3E/2">이 문서</a>를 읽어보도록 한다.</p>

<h2 id="streams">Streams</h2>

<p>elixir에서 Enum 모듈을 대체하는 Stream 모듈을 제공하는데, 게으른 평가(Lazy operations)을 지원한다.</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) |&gt; Stream.filter(odd?) |&gt; Enum.sum
  
7500000000
  
</code></pre>

<p>스트림은 게으르고 구성가능한 열거형이다. 즉시 리스트를 생성하지 않고, 연속된 계산만 만들어 둔 후 Enum 모듈에서 사용될 때에만 비로소 평가된다. 스트림은 큰(어쩌면 무한대의) 컬렉션에 사용하면 유용하다.</p>

<p>위의 예제에서 보여 주듯이, 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) 표현식은 스트림의 데이터타입을 반환하고 단지 1..100_000 사이의 map 계산만 표현하게 된다.(이 시점에 실제 계산은 수행되지 않는다.)</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3))
  
#Stream&lt;[enum: 1..100000, funs: [#Function&lt;34.16982430/1 in Stream.map/2&gt;]]&gt;
  
</code></pre>

<p>게다가 스트림은 파이프 연산자를 통해 여러 개의 스트림을 하나의 스트림으로 구성(composable)할 수 있다.</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) |&gt; Stream.filter(odd?)
  
#Stream&lt;[enum: 1..100000, funs: [&amp;#8230;]]&gt;
  
</code></pre>

<p>Stream 모듈의 많은 함수가 매개변수로 어떤 열거형도 받을 수 있고 결과로 스트림을 반환한다. 무한대의 스트림을 생성하는 함수도 있다. 예를 들어, Stream.cycle/1 함수는 주어진 열거형을 무한히 순환할 수 있는 스트림을 생성한다. 그런 스트림에 Enum.map/2 함수를 호출하면 영원히 순환에 빠지므로 조심해서 사용해야 한다.</p>

<pre><code>  
iex&gt; stream = Stream.cycle([1, 2, 3])
  
#Function&lt;15.16982430/2 in Stream.cycle/1&gt;
  
iex&gt; Enum.take(stream, 10)
  
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1]
  
</code></pre>

<p>Stream.unfold/2 함수는 주어진 초기 값으로부터 여러 값들을 생성하는데 사용할 수 있다.</p>

<pre><code>  
iex&gt; stream = Stream.unfold(&quot;hełło&quot;, &amp;String.next_codepoint/1)
  
#Function&lt;39.75994740/2 in Stream.unfold/2&gt;
  
iex&gt; Enum.take(stream, 3)
  
[&quot;h&quot;, &quot;e&quot;, &quot;ł&quot;]
  
</code></pre>

<p>또다른 재밌는 함수로 리소스를 감싸는데 사용되는 Stream.resource/3의 경우 열거하기 전에 올바르게 열려 있음을 보장하고 실패가 발생할 경우 닫힘을 보장한다. 예를 들어, 우리는 파일 스트림을 위해 다음과 같이 사용할 수 있다.</p>

<pre><code>  
iex&gt; stream = File.stream!(&quot;path/to/file&quot;)
  
#Function&lt;18.16982430/2 in Stream.resource/3&gt;
  
iex&gt; Enum.take(stream, 10)
  
</code></pre>

<p>위의 예제는 선택된 파일에서 먼저 10 줄을 가져온다. 이것은 큰 파일이나 네트워크같이 느린 리소스를 처리하는데 스트림이 매우 유용함을 뜻한다.</p>

<p>Enum과 Stream 모듈의 많은 양의 함수의 기능들에 압도될 수 있지만, 개별 케이스별로 매우 유사하기 때문에, 먼저 Enum 모듈에 집중하고 추후에 크고 느린 리소스를 처리할 때 Stream 모듈로 관심을 옮기는 것이 좋다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/enumerables-and-streams.html">Elixir Enumerables and Streams</a></li>
</ul>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/tutorial" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">tutorial</a>
   </li>
  
</ul>
<div class="mt6">
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-erlnote-wordpress-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </main>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/2015/06/12/elixir-recursion-921/">Elixir Recursion (#9/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/12/elixir-binaries-strings-and-char-lists-621/">Elixir Binaries, strings and char lists (#6/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/12/elixir-modules-821/">Elixir Modules (#8/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/12/elixir-keywords-maps-and-dicts-721/">Elixir Keywords, maps and dicts (#7/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/11/elixir-case-cond-and-if-521/">Elixir case, cond and if (#5/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/11/elixir-pattern-matching-421/">Elixir Pattern matching (#4/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/11/elixir-basic-operators/">Elixir Basic operators (#3/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/10/elixir-basic-types/">Elixir Basic types (#2/21)</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://jeidee.github.io/" >
    &copy; 2018 Erlang &amp; Go
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
