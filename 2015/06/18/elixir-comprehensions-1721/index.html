<!DOCTYPE html>
<html lang="ko-kr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Erlang &amp; Go  | Elixir Comprehensions (#17/21)</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.51" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="Elixir Comprehensions (#17/21)" />
<meta property="og:description" content="본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 elixir에서는, 열거형을 반복문에서 열거하고 요소를 필터링해 다른 리스트로 반환하는 일이 매우 일반적이다. 해석식(Comprehensions)은 그러한 패턴을 쉽게 하도록 도와준다. 해석식은 for와 같은 특별한 형태를 사용해 그러한 작업을 처리할 수 있다.
예를 들면, 정수 리스트에서 각 요소의 제곱을 구해 새로운 리스트를 반환하는 작업은 다음과 같이 구현할 수 있다.
 iex&gt; for n &lt;- [1, 2, 3, 4], do: n * n [1, 4, 9, 16]  해석식은 세 부분으로 구성된다: 발생기(generator), 필터, 수집자(collectables)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jeidee.github.io/2015/06/18/elixir-comprehensions-1721/" /><meta property="article:published_time" content="2015-06-18T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2015-06-18T00:00:00&#43;00:00"/>

<meta itemprop="name" content="Elixir Comprehensions (#17/21)">
<meta itemprop="description" content="본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 elixir에서는, 열거형을 반복문에서 열거하고 요소를 필터링해 다른 리스트로 반환하는 일이 매우 일반적이다. 해석식(Comprehensions)은 그러한 패턴을 쉽게 하도록 도와준다. 해석식은 for와 같은 특별한 형태를 사용해 그러한 작업을 처리할 수 있다.
예를 들면, 정수 리스트에서 각 요소의 제곱을 구해 새로운 리스트를 반환하는 작업은 다음과 같이 구현할 수 있다.
 iex&gt; for n &lt;- [1, 2, 3, 4], do: n * n [1, 4, 9, 16]  해석식은 세 부분으로 구성된다: 발생기(generator), 필터, 수집자(collectables).">


<meta itemprop="datePublished" content="2015-06-18T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2015-06-18T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="534">



<meta itemprop="keywords" content="tutorial," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Elixir Comprehensions (#17/21)"/>
<meta name="twitter:description" content="본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 elixir에서는, 열거형을 반복문에서 열거하고 요소를 필터링해 다른 리스트로 반환하는 일이 매우 일반적이다. 해석식(Comprehensions)은 그러한 패턴을 쉽게 하도록 도와준다. 해석식은 for와 같은 특별한 형태를 사용해 그러한 작업을 처리할 수 있다.
예를 들면, 정수 리스트에서 각 요소의 제곱을 구해 새로운 리스트를 반환하는 작업은 다음과 같이 구현할 수 있다.
 iex&gt; for n &lt;- [1, 2, 3, 4], do: n * n [1, 4, 9, 16]  해석식은 세 부분으로 구성된다: 발생기(generator), 필터, 수집자(collectables)."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://jeidee.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Erlang &amp; Go
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Elixir Comprehensions (#17/21)</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2015-06-18T00:00:00Z">June 18, 2015</time>      
      
      
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>elixir에서는, 열거형을 반복문에서 열거하고 요소를 필터링해 다른 리스트로 반환하는 일이 매우 일반적이다. 해석식(Comprehensions)은 그러한 패턴을 쉽게 하도록 도와준다. 해석식은 for와 같은 특별한 형태를 사용해 그러한 작업을 처리할 수 있다.</p>

<p>예를 들면, 정수 리스트에서 각 요소의 제곱을 구해 새로운 리스트를 반환하는 작업은 다음과 같이 구현할 수 있다.</p>

<pre><code>  
iex&gt; for n &lt;- [1, 2, 3, 4], do: n * n
  
[1, 4, 9, 16]
  
</code></pre>

<p>해석식은 세 부분으로 구성된다: 발생기(generator), 필터, 수집자(collectables).</p>

<h2 id="generators-and-filters">Generators and filters</h2>

<p>위의 표현식에서, n &lt;- [1, 2, 3, 4] 부분이 발생기이다. 발생기는 말 그대로 해석을 위한 값을 생성한다. 어떤 열거형도 발생기 표현식(generator expression)의 우측 값으로 사용할 수 있다.</p>

<pre><code>  
iex&gt; for n &lt;- 1..4, do: n * n
  
[1, 4, 9, 16]
  
</code></pre>

<p>발생기 표현식은 좌측 값으로 패턴 매칭을 지원하는데 매치하지 않는 패턴은 무시(ignored) 된다. 범위 값 대신에, 우리는 :good과 :bad atom을 키로 갖는 키워드 리스트를 받아, :good 값만 제곱하기를 원한다고 상상해 보자.</p>

<pre><code>  
iex&gt; values = [good: 1, good: 2, bad: 3, good: 4]
  
iex&gt; for {:good, n} &lt;- values, do: n * n
  
[1, 4, 16]
  
</code></pre>

<p>패턴 매칭 대신에, 필터를 사용할 수 있다. 예를 들어, 우리는 3의 배수를 구해 제곱하는 식을 다음과 같이 구현할 수 있다.</p>

<pre><code>  
iex&gt; multiple\_of\_3? = fn(n) -&gt; rem(n, 3) == 0 end
  
iex&gt; for n &lt;- 0..5, multiple\_of\_3?.(n), do: n * n
  
[0, 9]
  
</code></pre>

<p>필터가 false와 nil을 반환할 경우 해당 요소를 제거하고, 그 외의 요소만 유지한다.</p>

<p>해석식은 일반적으로 Enum과 Stream 모듈의 동등한 함수를 사용하는 것에 비해 훨씬 더 간결한 표현을 제공한다.</p>

<p>게다가, 해석식은 하나 이상의 발생기와 필터를 허용한다. 다음 예제는 디렉토리 리스트를 받아, 해당 디렉토리의 모든 파일을 삭제하는 예이다.</p>

<pre><code>  
for dir &lt;- dirs,
      
file &lt;- File.ls!(dir),
      
path = Path.join(dir, file),
      
File.regular?(path) do
    
File.rm!(path)
  
end
  
</code></pre>

<p>변수가 해석식 안에서 할당되며, 발생기와 필터, 또는 코드 블럭 안에서 사용되고, 해석식 밖에서 사용되지 않는 다는 것을 명심하자.</p>

<h2 id="bitstring-generators">Bitstring generators</h2>

<p>비트문자열 발생기 역시 지원되며, 비트문자열 스트림을 해석할 때 매우 유용하게 사용된다. 아래 예제는 Red,Green,Blue 색상을 갖는 바이너리 픽셀 리스트를 받아, R/G/B 세 개의 요소를 갖는 튜플 리스트로 변환한다.</p>

<pre><code>  
iex&gt; pixels = &lt;&lt;213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15&gt;&gt;
  
iex&gt; for &lt;&lt;r::8, g::8, b::8 &lt;- pixels&gt;&gt;, do: {r, g, b}
  
[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]
  
</code></pre>

<p>비트문자열 발생기는 &#8220;표준-reqular&#8221; 열거형 발생기와 함께 쓰일 수 있고 필터 역시 제공한다.</p>

<h2 id="results-other-than-lists">Results other than lists</h2>

<p>위의 예제에서, 모든 해석식은 결과로 리스트를 반환한다. 또한 해석식의 결과가 :into 옵션을 사용해 다른 데이터 구조에 삽입될 수도 있다.</p>

<p>예를 들어, 비트문자열 발생기는 문자열에서 모든 공백을 쉽게 제거하기 위해 :into 옵션과 함께 사용될 수 있다.</p>

<pre><code>  
iex&gt; for &lt;&lt;c &lt;- &quot; hello world &quot;&gt;&gt;, c != ?s, into: &quot;&quot;, do: &lt;&lt;c&gt;&gt;
  
&quot;helloworld&quot;
  
</code></pre>

<dl>
<dt>셋(Sets), 맵(Maps) 그리고 사전(Dictionaries)는 :into 옵션에 사용할 수 있다. 일반적으로, :into 옵션은 Collectable 프로토콜을 구현한 어떤 데이터 구조도 사용할 수 있다.</dt>
</dl>

<p>:into의 일반적인 용도는 키를 사용하지 않고 맵의 값을 변형하는데 있다.</p>

<pre><code>  
iex&gt; for {key, val} &lt;- %{&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2}, into: %{}, do: {key, val * val}
  
%{&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 4}
  
</code></pre>

<p>스트림을 사용한 예를 보자. IO 모듈은 스트림(Enumeralbe과 Collectable 프로토콜을 구현한)을 제공하기때문에, 해석식을 사용해 입력되는 어떤 문자도 대문자로 변경해 출력하는 에코 터미널을 만들 수 있다.</p>

<pre><code>  
iex&gt; stream = IO.stream(:stdio, :line)
  
iex&gt; for line &lt;- stream, into: stream do
  
&amp;#8230;&gt; String.upcase(line) &lt;&gt; &quot;n&quot;
  
&amp;#8230;&gt; end
  
</code></pre>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/comprehensions.html">Elixir Comprehensions</a></li>
</ul>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/tutorial" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">tutorial</a>
   </li>
  
</ul>
<div class="mt6">
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-erlnote-wordpress-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </main>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/2015/06/18/elixir-protocols-1621/">Elixir Protocols (#16/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/17/elixir-structs-1521/">Elixir Structs (#15/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/17/elixir-alias-require-and-import-1321/">Elixir alias, require and import (#13/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/17/elixir-module-attributes-1421/">Elixir Module attributes (#14/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/17/elixir-io-and-the-file-system-1221/">Elixir IO and the file system (#12/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/16/elixir-processes-1121/">Elixir Processes (#11/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/15/elixir-enumerables-and-streams-1021/">Elixir Enumerables and Streams (#10/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/12/elixir-binaries-strings-and-char-lists-621/">Elixir Binaries, strings and char lists (#6/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/12/elixir-modules-821/">Elixir Modules (#8/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/12/elixir-keywords-maps-and-dicts-721/">Elixir Keywords, maps and dicts (#7/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/12/elixir-recursion-921/">Elixir Recursion (#9/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/11/elixir-basic-operators/">Elixir Basic operators (#3/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/11/elixir-pattern-matching-421/">Elixir Pattern matching (#4/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/11/elixir-case-cond-and-if-521/">Elixir case, cond and if (#5/21)</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/2015/06/10/elixir-basic-types/">Elixir Basic types (#2/21)</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://jeidee.github.io/" >
    &copy; 2018 Erlang &amp; Go
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
