<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Elixir Comprehensions (#17/21)</title>
	
	
	<link rel="stylesheet" href="https://jeidee.github.io/css/style.css">
	
	<meta name="generator" content="Hugo 0.31.1" />
</head>
<body>
	<header>
		<a href="https://jeidee.github.io/">Erlang &amp; Go</a>
		<nav>
			<ul>
				
			</ul>
		</nav>
	</header>
	<main>
		<article>
			<h1>Elixir Comprehensions (#17/21)</h1>
			<time>18.06.2015 00:00</time>
			<div>
				

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>elixir에서는, 열거형을 반복문에서 열거하고 요소를 필터링해 다른 리스트로 반환하는 일이 매우 일반적이다. 해석식(Comprehensions)은 그러한 패턴을 쉽게 하도록 도와준다. 해석식은 for와 같은 특별한 형태를 사용해 그러한 작업을 처리할 수 있다.</p>

<p>예를 들면, 정수 리스트에서 각 요소의 제곱을 구해 새로운 리스트를 반환하는 작업은 다음과 같이 구현할 수 있다.</p>

<pre><code>  
iex&gt; for n &lt;- [1, 2, 3, 4], do: n * n
  
[1, 4, 9, 16]
  
</code></pre>

<p>해석식은 세 부분으로 구성된다: 발생기(generator), 필터, 수집자(collectables).</p>

<h2 id="generators-and-filters">Generators and filters</h2>

<p>위의 표현식에서, n &lt;- [1, 2, 3, 4] 부분이 발생기이다. 발생기는 말 그대로 해석을 위한 값을 생성한다. 어떤 열거형도 발생기 표현식(generator expression)의 우측 값으로 사용할 수 있다.</p>

<pre><code>  
iex&gt; for n &lt;- 1..4, do: n * n
  
[1, 4, 9, 16]
  
</code></pre>

<p>발생기 표현식은 좌측 값으로 패턴 매칭을 지원하는데 매치하지 않는 패턴은 무시(ignored) 된다. 범위 값 대신에, 우리는 :good과 :bad atom을 키로 갖는 키워드 리스트를 받아, :good 값만 제곱하기를 원한다고 상상해 보자.</p>

<pre><code>  
iex&gt; values = [good: 1, good: 2, bad: 3, good: 4]
  
iex&gt; for {:good, n} &lt;- values, do: n * n
  
[1, 4, 16]
  
</code></pre>

<p>패턴 매칭 대신에, 필터를 사용할 수 있다. 예를 들어, 우리는 3의 배수를 구해 제곱하는 식을 다음과 같이 구현할 수 있다.</p>

<pre><code>  
iex&gt; multiple\_of\_3? = fn(n) -&gt; rem(n, 3) == 0 end
  
iex&gt; for n &lt;- 0..5, multiple\_of\_3?.(n), do: n * n
  
[0, 9]
  
</code></pre>

<p>필터가 false와 nil을 반환할 경우 해당 요소를 제거하고, 그 외의 요소만 유지한다.</p>

<p>해석식은 일반적으로 Enum과 Stream 모듈의 동등한 함수를 사용하는 것에 비해 훨씬 더 간결한 표현을 제공한다.</p>

<p>게다가, 해석식은 하나 이상의 발생기와 필터를 허용한다. 다음 예제는 디렉토리 리스트를 받아, 해당 디렉토리의 모든 파일을 삭제하는 예이다.</p>

<pre><code>  
for dir &lt;- dirs,
      
file &lt;- File.ls!(dir),
      
path = Path.join(dir, file),
      
File.regular?(path) do
    
File.rm!(path)
  
end
  
</code></pre>

<p>변수가 해석식 안에서 할당되며, 발생기와 필터, 또는 코드 블럭 안에서 사용되고, 해석식 밖에서 사용되지 않는 다는 것을 명심하자.</p>

<h2 id="bitstring-generators">Bitstring generators</h2>

<p>비트문자열 발생기 역시 지원되며, 비트문자열 스트림을 해석할 때 매우 유용하게 사용된다. 아래 예제는 Red,Green,Blue 색상을 갖는 바이너리 픽셀 리스트를 받아, R/G/B 세 개의 요소를 갖는 튜플 리스트로 변환한다.</p>

<pre><code>  
iex&gt; pixels = &lt;&lt;213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15&gt;&gt;
  
iex&gt; for &lt;&lt;r::8, g::8, b::8 &lt;- pixels&gt;&gt;, do: {r, g, b}
  
[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]
  
</code></pre>

<p>비트문자열 발생기는 &#8220;표준-reqular&#8221; 열거형 발생기와 함께 쓰일 수 있고 필터 역시 제공한다.</p>

<h2 id="results-other-than-lists">Results other than lists</h2>

<p>위의 예제에서, 모든 해석식은 결과로 리스트를 반환한다. 또한 해석식의 결과가 :into 옵션을 사용해 다른 데이터 구조에 삽입될 수도 있다.</p>

<p>예를 들어, 비트문자열 발생기는 문자열에서 모든 공백을 쉽게 제거하기 위해 :into 옵션과 함께 사용될 수 있다.</p>

<pre><code>  
iex&gt; for &lt;&lt;c &lt;- &quot; hello world &quot;&gt;&gt;, c != ?s, into: &quot;&quot;, do: &lt;&lt;c&gt;&gt;
  
&quot;helloworld&quot;
  
</code></pre>

<dl>
<dt>셋(Sets), 맵(Maps) 그리고 사전(Dictionaries)는 :into 옵션에 사용할 수 있다. 일반적으로, :into 옵션은 Collectable 프로토콜을 구현한 어떤 데이터 구조도 사용할 수 있다.</dt>
</dl>

<p>:into의 일반적인 용도는 키를 사용하지 않고 맵의 값을 변형하는데 있다.</p>

<pre><code>  
iex&gt; for {key, val} &lt;- %{&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2}, into: %{}, do: {key, val * val}
  
%{&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 4}
  
</code></pre>

<p>스트림을 사용한 예를 보자. IO 모듈은 스트림(Enumeralbe과 Collectable 프로토콜을 구현한)을 제공하기때문에, 해석식을 사용해 입력되는 어떤 문자도 대문자로 변경해 출력하는 에코 터미널을 만들 수 있다.</p>

<pre><code>  
iex&gt; stream = IO.stream(:stdio, :line)
  
iex&gt; for line &lt;- stream, into: stream do
  
&amp;#8230;&gt; String.upcase(line) &lt;&gt; &quot;n&quot;
  
&amp;#8230;&gt; end
  
</code></pre>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/comprehensions.html">Elixir Comprehensions</a></li>
</ul>

			</div>
			<div>
				<ul id="tags">
					
					<li><a href="/tags/tutorial">tutorial</a> </li>
					
				</ul>
			</div>
			<div>
				
			</div>
		</article>
	</main>
	<aside>
		<div>
			<div>
				<h3>LATEST POSTS</h3>
			</div>
			<div>
				<ul>
					
					<li><a href="https://jeidee.github.io/2017/08/31/upstart-ec84a4eca095/">upstart 설정</a></li>
					
					<li><a href="https://jeidee.github.io/2017/06/08/centosec9790ec849c-mongodb-ec84a4ecb998ec9980-service-eb93b1eba19d/">CentOS에서 MongoDB 설치와 Service 등록</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/couchbase-cberlec9790-lcb_cntl-ed95a8ec8898-ecb694eab080/">couchbase cberl에 lcb_cntl 함수 추가</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/couchbase-cberlec9d98io-pluginec9d84-libeventeba19c-ebb380eab2bd/">couchbase cberl의IO Plugin을 libevent로 변경</a></li>
					
					<li><a href="https://jeidee.github.io/2017/01/25/ejabberdec9d98-deps-eb9dbcec9db4ebb88ceb9faceba6ac-ec8898eca095-ed9b84-ecbbb4ed8c8cec9dbcec9790ec849c-eb8884eb9dbdeb90a0-eb958c/">ejabberd의 deps 라이브러리 수정 후 컴파일에서 누락될 때</a></li>
					
				</ul>
			</div>
		</div>
	</aside>

	<footer>
		<p>&copy; 2017 <a href="https://jeidee.github.io/">Erlang &amp; Go</a></p>
	</footer>
</body>
</html>