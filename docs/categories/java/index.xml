<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Erlang &amp; Go</title>
    <link>https://jeidee.github.io/blog/categories/java/</link>
    <description>Recent content in Java on Erlang &amp; Go</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 May 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jeidee.github.io/blog/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Backoff 알고리즘</title>
      <link>https://jeidee.github.io/blog/2015/05/13/backoff-ec958ceab3a0eba6aceca698/</link>
      <pubDate>Wed, 13 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/blog/2015/05/13/backoff-ec958ceab3a0eba6aceca698/</guid>
      <description>연결 재접속이나 데이터 재전송을 위한 Backoff 알고리즘을 java로 구현해 본다.
&amp;lt;br /&amp;gt;public class BackoffManager { private int mMaxRetryCount = 10; // 최대 재시도 횟수 private int mInitWaitBackoffSeconds = 2; // 현재 재시도 간격(단위: 초) private boolean mNoGiveupAndRepeat = false; // 최대 재시도 횟수를 초과할 경우 재시도 포기여부 private int mRetryCount; private int mWaitBackoffSeconds; private int mRepeatCycle; // 최대 재시도횟수를 초과한 횟수 public void init(int maxRetryCount, int initWaitBackoffSeconds, boolean noGiveupAndRepeat) { mMaxRetryCount = maxRetryCount; mInitWaitBackoffSeconds = initWaitBackoffSeconds; mNoGiveupAndRepeat = noGiveupAndRepeat; mRetryCount = 0; mWaitBackoffSeconds = mInitWaitBackoffSeconds; } // 연결이 완료되면 백오프 리셋 public void reset() { mRetryCount = 0; mWaitBackoffSeconds = mInitWaitBackoffSeconds; } public boolean retry() throws InterruptedException { if (mNoGiveupAndRepeat == false &amp;amp;&amp;amp; mRepeatCycle &amp;gt; 0) { return false; } mRetryCount++; mWaitBackoffSeconds *= 2; if (mRetryCount &amp;gt; mMaxRetryCount) { mRetryCount = 0; mWaitBackoffSeconds = mInitWaitBackoffSeconds; mRepeatCycle++; } // 대기 Thread.</description>
    </item>
    
    <item>
      <title>java generic에서 T.class 사용하기</title>
      <link>https://jeidee.github.io/blog/2015/05/05/java-genericec9790ec849c-t-class-ec82acec9aa9ed9598eab8b0/</link>
      <pubDate>Tue, 05 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://jeidee.github.io/blog/2015/05/05/java-genericec9790ec849c-t-class-ec82acec9aa9ed9598eab8b0/</guid>
      <description>Class 클래스는 T 클래스의 메타정보를 갖는 클래스이다.
T가 Temp라는 사용자 정의 클래스라고 할 때,
Temp.class와 Class.forName(&amp;#8220;com.example.Temp&amp;#8221;)은 Class 오브젝트를 반환한다.
이 Class 오브젝트를 사용해 Temp 클래스의 인스턴스를 생성할 수 있고, 메소드와 필드를 Reflection할 수 있다.
Class를 사용해 T의 새로운 인스턴스를 생성하고자 할 때는 다음과 같이 newInstance()를 사용할 수 있다.
Temp temp = (Temp) Temp.class.newInstance(); Temp temp2 = (Temp) Class.forName(&amp;quot;com.example.Temp&amp;quot;).newInstance();  문제는 다음과 같은 Generic 클래스를 정의할 때 타입 T의 Class 오브젝트를 T.</description>
    </item>
    
  </channel>
</rss>