<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Erlang &amp; Go  | Tutorial</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.31.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    <link href='http://jeidee.github.io/blog/dist/main.css' rel='stylesheet' type="text/css" />
    
      
    

    
      <link href="http://jeidee.github.io/blog/tags/tutorial/index.xml" rel="alternate" type="application/rss+xml" title="Erlang &amp; Go" />
      <link href="http://jeidee.github.io/blog/tags/tutorial/index.xml" rel="feed" type="application/rss+xml" title="Erlang &amp; Go" />
    

    <meta property="og:title" content="Tutorial" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://jeidee.github.io/blog/tags/tutorial/" />



<meta property="og:updated_time" content="2015-06-21T00:00:00&#43;00:00"/>










<meta itemprop="name" content="Tutorial">
<meta itemprop="description" content="">

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Tutorial"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  
  
  <header class="cover bg-top" style="background-image: url('http://jeidee.github.io/blog/images/gohugo-default-sample-hero-image.jpg');">
    <div class="bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://jeidee.github.io/blog" class="f3 fw2 hover-white no-underline white-90 dib">
      Erlang &amp; Go
    </a>
    <div class="flex-l items-center">
      
      








    </div>
  </div>
</nav>

      <div class="tc-l pv4 pv6-l ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 white-90 mb0 lh-title">
          Tutorial
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links nested-img mid-gray">
      <p>Below you will find pages that utilize the taxonomy term “Tutorial”</p>
    </div>
  </article>
  <div class="mw8 center">
    
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/21/elixir-where-to-go-next-2121" class="link black dim">
        Elixir Where to go next (#21/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 더 배우고 싶은가? 그럼 계속 읽어보자.
Build your first Elixir project 우리의 첫 프로젝트를 시작하기 위해, elixir는 Mix라는 빌드 툴을 제공한다. 우리는 다음과 같이 간단하게 첫 프로젝트를 만들 수 있다.
 mix new path/to/new/project  위의 과정을 통해 우리는 슈퍼비전 트리, 설정, 테스트등을 갖는 elixir 응용프로그램을 만들 수 있다. 다음 가이드를 통해 우리는 분산된 노드에 분산된 key-value 저장소를 갖는 응용프로그램을 만드는 방법을 배울 수 있다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/19/elixir-sigils-1821" class="link black dim">
        Elixir Sigils (#18/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 우리는 이미 elixir의 문자열과 문자 리스트를 배웠다. 하지만, 언어에 있어 텍스트의 표현을 위한 구조의 겉면만 다루었을 뿐이다. atom을 예로 들면, 대부분 :atom 형식으로 표현되는 식이다.
elixir의 목표 중 하나는 확장성이다: elixir를 사용하면 개발자가 어떤 도메인에도 꼭 맞도록 언어를 확장할 수 있다. 개발자나, 회사, 또는 커뮤티니들이 그들과 관련된 도메인안에서 언어를 확장할 수 있도록 만들어졌다는 말이다.
이번 챕터에서 우리는, 텍스트 처리에 사용하는 매커니즘 중 하나인 sigil &#8211; $foo에서 $와 같은 기호에 대해서 알아볼 것이다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/19/elixir-try-catch-and-rescue-1921" class="link black dim">
        Elixir try, catch and rescue (#19/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 elixir는 세 개의 에러 매커니즘을 갖는다: errors, throws, exits. 이번 챕터에서 우리는 이들 각각을 살펴보도록 한다.
Errors 에러(또는 예외)는 코드에서 예외적인 상황이 발생할 때 사용된다. 숫자를 atom에 더할 때 발생할 수 있는 에러를 살펴보자.
 iex&gt; :foo + 1 ** (ArithmeticError) bad argument in arithmetic expression :erlang.+(:foo, 1)  raise/1 함수를 사용하면 아무 때나 런타임에 에러를 발생시킬 수 있다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/18/elixir-comprehensions-1721" class="link black dim">
        Elixir Comprehensions (#17/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 elixir에서는, 열거형을 반복문에서 열거하고 요소를 필터링해 다른 리스트로 반환하는 일이 매우 일반적이다. 해석식(Comprehensions)은 그러한 패턴을 쉽게 하도록 도와준다. 해석식은 for와 같은 특별한 형태를 사용해 그러한 작업을 처리할 수 있다.
예를 들면, 정수 리스트에서 각 요소의 제곱을 구해 새로운 리스트를 반환하는 작업은 다음과 같이 구현할 수 있다.
 iex&gt; for n &lt;- [1, 2, 3, 4], do: n * n [1, 4, 9, 16]  해석식은 세 부분으로 구성된다: 발생기(generator), 필터, 수집자(collectables).
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/18/elixir-protocols-1621" class="link black dim">
        Elixir Protocols (#16/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 프로토콜은 elixir에서 다형성을 구현하는 매커니즘이다. 프로토콜은 어떤 데이터 타입에서도 사용할 수 있다. 예제를 보도록 하자.
elixir에서는 false와 nil만이 false처럼 처리된다. 그 외에는 모든 것이 true로 평가된다. 응용프로그램에 따라, blank로 처리되는 데이터타입을 위해 boolean값을 반환하는 blank? 프로토콜을 명시하는 것이 중요할 수도 있다. 예를 들어, 빈 리스트나 빈 바이너리는 blank로 간주될 수 있다.
우리는 이러한 프로토콜을 다음과 같이 정의할 수 있다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/17/elixir-io-and-the-file-system-1221" class="link black dim">
        Elixir IO and the file system (#12/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 이번 챕터에서는 IO, File, Path 모듈과 관련된 입/출력 매커니즘과 파일 시스템 관련 태스크를 소개하도록 한다.
The IO module elixir의 IO 모듈은 표준 입출력, 표준 에러, 파일과 다른 IO 장치들을 읽고 쓸 수 있도록 해주는 주요 매커니즘이다. 모듈의 사용법은 꽤 직관적이다.
 iex&gt; IO.puts &quot;hello world&quot; hello world :ok iex&gt; IO.gets &quot;yes or no? &quot; yes or no?
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/17/elixir-module-attributes-1421" class="link black dim">
        Elixir Module attributes (#14/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 elixir에서 모듈의 속성은 3개의 목적으로 제공된다.
 모듈에 주석을 제공한다. 사용자와 VM에 정보를 제공한다. 상수로 동작한다. 컴파일하는 동안 임시 모듈 저장공간으로 사용된다.  하나씩 살펴보자.
As annotations elixir는 모듈 속성 컨셉을 Erlang에서 가져왔다. 예를 보자.
 defmodule MyServer do @vsn 2 end  위의 예는, 모듈의 버전 속성을 명시적으로 설정한다. @vsn은 Erlang VM이 모듈이 수정되었는지 여부를 검사해서 코드를 리로딩할 지 결정하는 매커니즘으로 사용한다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/17/elixir-structs-1521" class="link black dim">
        Elixir Structs (#15/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 이전 챕터에서 우리는 맵에 대해 배웠다.
 iex&gt; map = %{a: 1, b: 2} %{a: 1, b: 2} iex&gt; map[:a] 1 iex&gt; %{map | a: 3} %{a: 3, b: 2}  구조체는 컴파일 타임 검사와 기본값을 제공하는 맵의 확장이다.
Defining structs 구조체를 정의하기 위해, defstruct를 사용한다.
 iex&gt; defmodule User do &amp;#8230;&gt; defstruct name: &quot;John&quot;, age: 27 &amp;#8230;&gt; end  defstruct에 사용된 키워드 리스트는, 어떤 필드가 어떤 기본값을 갖는지 정의한다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/17/elixir-alias-require-and-import-1321" class="link black dim">
        Elixir alias, require and import (#13/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 소프트웨어 재사용을 쉽게 하기 위해, elixir는 3개의 지시자(directives)를 제공한다. 이들 지시자는 정적 유효범위(lexical scope)를 갖는다.(일반적인 언어에서 변수의 선언과 유효범위는 대부분 lexical scope를 갖는다.)
alias alias는 모듈이름의 별칭을 허용한다. 우리가 만든 Math 모듈에 특별한 List가 있다고 가정해 보자.
 defmodule Math do alias Math.List, as: List end  이제 Math 모듈 안에서 List는 자동적으로 Math.List로 확장된다. 만약 본래의 List 모듈에 접근하고자 한다면, Elixir.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/16/elixir-processes-1121" class="link black dim">
        Elixir Processes (#11/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 elixir에서, 모든 코드는 프로세스 안에서 실행된다. 프로세스는 서로 분리되어 있고, 서로 동시에(concurrent) 실행되며, 메세지를 건네는 것을 통해 통신한다.
프로세스는 elixir의 동시성 뿐만 아니라, 분산 된 구조와 결함 내구성(fault-tolerant) 역시 제공한다.
elixir의 프로세스를 OS(운영체제)의 프로세스와 혼동하면 안된다. elixir의 프로세스는 메모리와 CPU에 있어 극단적으로 경량화되어 있다(다른 프로그래밍 언어의 쓰레드와 다르게). 이러한 이유로, 수백 수천의 프로세스가 동시에 수행되는 것이 일반적이다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/15/elixir-enumerables-and-streams-1021" class="link black dim">
        Elixir Enumerables and Streams (#10/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 Enumerables elixir는 열거가능한 자료구조(enumerables) 컨셉과 그들을 처리하기 위한 Enum 모듈을 제공한다. 우리는 이미 두 개의 열거가능한 자료구조(lists and maps)를 배웠다.
 iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end) [2, 4, 6] iex&gt; Enum.map(%{1 =&gt; 2, 3 =&gt; 4}, fn {k, v} -&gt; k * v end) [2, 12]  Enum 모듈은 열거가능한 자료구조에서 transform(변형), sort(정렬), group, filter등의 처리를 통해 아이템을 얻을 수 있는 수많은 함수들을 제공한다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/12/elixir-binaries-strings-and-char-lists-621" class="link black dim">
        Elixir Binaries, strings and char lists (#6/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 &#8220;Basic types&#8221;에서 문자열에 대해 배웠고, 타입 검사를 위해 is_binary/1 함수를 사용했다.
 iex&gt; string = &quot;hello&quot; &quot;hello&quot; iex&gt; is_binary string true  이번 챕터에서는, 바이너리가 무엇인가를 이해하고, 문자열과 어떤 연관이 있으며, &#8221;(single-quoted value)값,&#8217;이런 값&#8217;,이 무엇을 의미하는지 살펴본다.
UTF-8과 유니코드 문자열은 UTF-8로 인코딩된 바이너리이다. 이것이 무엇을 의미하는지 정확히 이해하기 위해서는, 바이트와 코드 포인트(bytes and code-points)의 차이가 무엇인지 먼저 이해해야 한다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/12/elixir-keywords-maps-and-dicts-721" class="link black dim">
        Elixir Keywords, maps and dicts (#7/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 지금까지 자료구조와 관련된 논의는 하지 않았다. 예를 들어, 키에 특정 값을 연관시키는 자료구조 같은 것 등을 말이다. 다른 언어에서는 이러한 자료구조를 사전(Dictionary), 해시(Hash), 연관 배열(Associative Array), 맵(Map)등으로 부른다.
elixir에는 두 개의 주요 연관 자료구조가 있다: 키워드 리스트(keyword lists)와 맵(maps)이다. 이번에는 이들에 대해 배워보도록 한다.
Keyword lists 많은 함수형 프로그래밍 언어에서는, 연관 자료구조를 표현하는데 tuple 두 개를 사용한 리스트를 일반적으로 사용한다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/12/elixir-modules-821" class="link black dim">
        Elixir Modules (#8/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 elixir에서 우리는 모듈에 여러 함수를 그룹지을 수 있다. 우리는 이전 챕터에서 String 모듈 같은 여러 다른 모듈들을 사용했다.
 iex&gt; String.length &quot;hello&quot; 5  elixir에서 우리만의 모듈을 만들기 위해, 우리는 defmodule 매크로를 사용해야 한다. 우리는 우리의 모듈에서 함수를 정의하기 위해 def 매크로를 사용할 수 있다.
 iex&gt; defmodule Math do &amp;#8230;&gt; def sum(a, b) do &amp;#8230;&gt; a + b &amp;#8230;&gt; end &amp;#8230;&gt; end iex&gt; Math.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/12/elixir-recursion-921" class="link black dim">
        Elixir Recursion (#9/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 Loops through recursion 불변성때문에, elixir에서 loop는(모든 함수형 프로그래밍 언어에서 마찬가지로) 다른 언어들과 다르게 작성한다. 예를 들어, c 언어 같은 경우에는 다음과 같을 것이다.
 for(i = 0; i &lt; array.length; i++) { array[i] = array[i] * 2 }  위의 예제가 보여주는 바는, i와 array 둘 모두 값이 변경되는 가변성이다. 가변성은 elixir에서 가능하지 않다. 대신, 함수형 언어는 재귀(recursion)에 의존한다: 함수는 조건이 지속되는 상황에서 종료되는 상황에 이를때까지 재귀적으로 호출된다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/11/elixir-basic-operators" class="link black dim">
        Elixir Basic operators (#3/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 이전 챕터에서는 +, -, *, / 산술 연산자를 살펴보았다.
이 외에도 elixir는 리스트 연산을 위해 ++와 &#8212; 연산자를 제공한다.
 iex&gt; [1,2,3] ++ [4,5,6] [1,2,3,4,5,6] iex&gt; [1,2,3] &amp;#8212; [2] [1,3]  문자열의 결합에는 연산자를 사용한다.
 iex&gt; &quot;foo&quot; &lt;&gt; &quot;bar&quot; &quot;foobar&quot;  elixir는 논리 연산을 위해 or, and, not과 같은 논리 연산자를 제공한다. 연산의 결과는 true 또는 false값이며 연산자의 매개변수 역신 boolean타입(true or false)이어야 한다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/11/elixir-pattern-matching-421" class="link black dim">
        Elixir Pattern matching (#4/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 이번 챕터에서는 = 연산자가 매치 연산자로 어떻게 사용되는지와 자료구조안에서 패턴매치가 어떻게 이뤄지는지 살펴볼 것이다. 마지막으로 핀 연산자(^)를 알아본다.
매치 연산자 elixir에서 변수에 값을 할당하기 위해 = 연산자를 여러번 사용했다.
 iex&gt; x = 1 1 iex&gt; x 1  c/c++에서 = 연산자는 대입연산자(또는 할당연산자)라고 불리우지만 erlang과 elixir에서는 매치 연산자라고 부른다.
왜 그런지 살펴보자.
 iex&gt; 1 = x 1 iex&gt; 2 = x ** (MatchError) no match of right hand side value: 1  1 = x 표현식이 유효함을 주목한다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/11/elixir-case-cond-and-if-521" class="link black dim">
        Elixir case, cond and if (#5/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 이번 챕터에서는 흐름 제어에 사용되는 case, cond, if에 대해 알아본다.
case case는 매치되는 하나를 찾기 위해 많은 패턴과 값을 비교할 때 사용한다.
 iex&gt; case {1, 2, 3} do &amp;#8230;&gt; {4, 5, 6} -&gt; &amp;#8230;&gt; &quot;This clause won't match&quot; &amp;#8230;&gt; {1, x, 3} -&gt; &amp;#8230;&gt; &quot;This clause will match and bind x to 2 in this clause&quot; &amp;#8230;&gt; _ -&gt; &amp;#8230;&gt; &quot;This clause would match any value&quot; &amp;#8230;&gt; end &quot;This clause will match and bind x to 2 in this clause&quot;  기존의 변수에 패턴매치를 사용하고 싶다면 핀 연산자(^)를 사용해야 한다.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/2015/06/10/elixir-basic-types" class="link black dim">
        Elixir Basic types (#2/21)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      본 문서는 elixir-lang.org의 Getting Started문서의 한글 번역본입니다.
자세한 내용은 원문을 참조해 주세요.
 elixir의 기본 데이터 타입을 살펴보자.
기본 산술 표현식과 타입  iex&gt; 1 + 2 3 iex&gt; 5 * 5 25 iex&gt; 10 / 2 5.0  산술 연산자는 각각 +, -, *, / 연산자를 사용하면 된다.
주목할 것은 / 연산자인데, 결과값이 항상 float이다.
몫과 나머지를 각각 구하고자 한다면 다음과 같은 기본 산술 함수를 사용하도록 한다.
    </div>
  </div>
</div>

        </div>
      
    </section>
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://jeidee.github.io/blog" >
    &copy; 2017 Erlang &amp; Go
  </a>
  








  </div>
</footer>

    <script src="http://jeidee.github.io/blog/dist/app.bundle.js" async></script>

  </body>
</html>
