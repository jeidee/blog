<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backoff on Erlang &amp; Go</title>
    <link>http://jeidee.github.io/blog/tags/backoff/</link>
    <description>Recent content in Backoff on Erlang &amp; Go</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 May 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://jeidee.github.io/blog/tags/backoff/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Backoff 알고리즘</title>
      <link>http://jeidee.github.io/blog/2015/05/13/backoff-ec958ceab3a0eba6aceca698/</link>
      <pubDate>Wed, 13 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://jeidee.github.io/blog/2015/05/13/backoff-ec958ceab3a0eba6aceca698/</guid>
      <description>연결 재접속이나 데이터 재전송을 위한 Backoff 알고리즘을 java로 구현해 본다.
&amp;lt;br /&amp;gt;public class BackoffManager { private int mMaxRetryCount = 10; // 최대 재시도 횟수 private int mInitWaitBackoffSeconds = 2; // 현재 재시도 간격(단위: 초) private boolean mNoGiveupAndRepeat = false; // 최대 재시도 횟수를 초과할 경우 재시도 포기여부 private int mRetryCount; private int mWaitBackoffSeconds; private int mRepeatCycle; // 최대 재시도횟수를 초과한 횟수 public void init(int maxRetryCount, int initWaitBackoffSeconds, boolean noGiveupAndRepeat) { mMaxRetryCount = maxRetryCount; mInitWaitBackoffSeconds = initWaitBackoffSeconds; mNoGiveupAndRepeat = noGiveupAndRepeat; mRetryCount = 0; mWaitBackoffSeconds = mInitWaitBackoffSeconds; } // 연결이 완료되면 백오프 리셋 public void reset() { mRetryCount = 0; mWaitBackoffSeconds = mInitWaitBackoffSeconds; } public boolean retry() throws InterruptedException { if (mNoGiveupAndRepeat == false &amp;amp;&amp;amp; mRepeatCycle &amp;gt; 0) { return false; } mRetryCount++; mWaitBackoffSeconds *= 2; if (mRetryCount &amp;gt; mMaxRetryCount) { mRetryCount = 0; mWaitBackoffSeconds = mInitWaitBackoffSeconds; mRepeatCycle++; } // 대기 Thread.</description>
    </item>
    
  </channel>
</rss>