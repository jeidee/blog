<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" Tutorial &middot;  Erlang &amp; Go" />
  	<meta property="og:site_name" content="Erlang &amp; Go" />
  	<meta property="og:url" content="https://jeidee.github.io/tags/tutorial/" />
    
    
    <meta property="og:type" content="website" />
    

  <title>
     Tutorial &middot;  Erlang &amp; Go
  </title>

    <meta name="description" content="" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://jeidee.github.ioimages/favicon.ico">
	  <link rel="apple-touch-icon" href="https://jeidee.github.ioimages/apple-touch-icon.png" />
    
    <link rel="stylesheet" type="text/css" href="https://jeidee.github.iocss/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
      
          <link href="https://jeidee.github.ioindex.xml" rel="alternate" type="application/rss+xml" title="Erlang &amp; Go" />
      
      
        <link href="https://jeidee.github.io/tags/tutorial/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial &middot; Erlang &amp; Go" />
      
    
    <meta name="generator" content="Hugo 0.31.1" />

    <link rel="canonical" href="https://jeidee.github.io/tags/tutorial/" />

    
<div id="particles-js"></div>
<script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
<script src="https://jeidee.github.iojs/particles.js"></script>   
</head>
<body class="nav-closed">

  


 <div class="site-wrapper">




	<header class="main-header tag-head no-cover">

    <nav class="main-nav overlay clearfix">
      
      
        
          <a class="menu-button icon-feed" href="https://jeidee.github.io/tags/tutorial/index.xml">&nbsp;&nbsp;Subscribe</a>
        
      
    </nav>
    <div class="vertical">

        <div class="main-header-content inner">
            <h1 class="page-title">

              <a class="btn-bootstrap-2" href="#content">Erlang &amp; Go</a>
          </h1>
        </div>
</div>
    <a class="scroll-down icon-arrow-left" href="#content"><span class="hidden">Scroll Down</span></a>
</header>

<main id="content" class="content" role="main">
    

	<div class="extra-pagination inner">
    <nav class="pagination" role="navigation">
	
	    <a class="newer-posts" href="/tags/tutorial/">&larr; Newer Posts</a>
	
	<span class="page-number">Page 2 of 2</span>
	
</nav>

	</div>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/15/elixir-enumerables-and-streams-1021/">Elixir Enumerables and Streams (#10/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<h2 id="enumerables">Enumerables</h2>

<p>elixir는 열거가능한 자료구조(enumerables) 컨셉과 그들을 처리하기 위한 Enum 모듈을 제공한다. 우리는 이미 두 개의 열거가능한 자료구조(lists and maps)를 배웠다.</p>

<pre><code>  
iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end)
  
[2, 4, 6]
  
iex&gt; Enum.map(%{1 =&gt; 2, 3 =&gt; 4}, fn {k, v} -&gt; k * v end)
  
[2, 12]
  
</code></pre>

<p>Enum 모듈은 열거가능한 자료구조에서 transform(변형), sort(정렬), group, filter등의 처리를 통해 아이템을 얻을 수 있는 수많은 함수들을 제공한다. Enum 모듈은 elixir 코드에서 개발자들이 자주 자용하는 모듈 중 하나이다.</p>

<p>elixir는 범위 표현을 위해 다음 구문을 제공한다:</p>

<pre><code>  
iex&gt; Enum.map(1..3, fn x -&gt; x * 2 end)
  
[2, 4, 6]
  
iex&gt; Enum.reduce(1..3, 0, &amp;+/2)
  
6
  
</code></pre>

<p>Enum 모듈은 서로 다른 데이터 타입을 처리하기 위해 설계되었으므로, Enum 모듈의 API는 많은 데이터 타입을 함께 처리하기 위해 함수를 제한적으로 사용한다. 특정 동작들의 경우, 모듈에 접근할 때 데이터타입을 명시해야 한다. 예를 들어, 리스트의 특정 위치에 요소를 삽입하고자 할 때, List 모듈의 List.insert_at/3 함수를 사용해야 하는데, 해당 함수는 범위에 값을 삽입하는 동작을 수행한다.</p>

<p>Enum 모듈의 함수는 서로 다른 데이터 타입을 처리할 수 있어야 하기 때문에, 다형성을 갖는다고 할 수 있다. 특히, Enum 모듈의 함수는 Enumerable 프로토콜을 구현하는 어떤 데이터 타입이라도 취급할 수 있다. 이 프로토콜에 대해서는 다음 챕터에서 살펴보도록 하고 먼저 스트림이라 불리는 특수한 열거형에 대해 살펴보도록 한다.</p>

<h2 id="eager-vs-lazy">Eager vs Lazy</h2>

<p>Enum 모듈의 모든 함수는 즉시(eager) 평가된다. 많은 함수들은 열거한 후 리스트를 반환하기를 기대한다.</p>

<pre><code>  
iex&gt; odd? = &amp;(rem(&amp;1, 2) != 0)
  
#Function&lt;6.80484245/1 in :erl_eval.expr/5&gt;
  
iex&gt; Enum.filter(1..3, odd?)
  
[1, 3]
  
</code></pre>

<p>이것은 Enum모듈과 여러 동작을 수행할 때, 각 동작은 우리가 결과를 얻을 때까지 임시 리스트를 생성하다는 것을 의미한다.</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Enum.map(&amp;(&amp;1 * 3)) |&gt; Enum.filter(odd?) |&gt; Enum.sum
  
7500000000
  
</code></pre>

<p>위의 예는 동작의 파이프라인을 갖는다. 우리는 숫자의 범위에서 시작해서 각 요소에 3을 곱한다. 이 첫 번째 동작의 결과로 100_000개의 아이템을 갖는 리스트를 반환할 것이다. 그런 후 우리는 그 리스트에서 홀수만 취하는 50_000 개의 아이템을 갖는 리스트를 새로 만들고, 각 엔트리(요소)를 모두 더한 결과를 반환한다.</p>

<h2 id="the-pipe-operator">The pipe operator</h2>

<p>|&gt; 기호는 파이프 연산자이다. 이 연산자는 단순히 왼쪽 연산의 결과를 오른쪽 표현식의 입력으로 건네주는 역할을 수행한다. 이 연산자는 유닉스의 | 연산자와 유사하다. 이 예제의 목적은 연속적인 함수에 의해 변형되는 데이터의 흐름을 강조하기 위한 것이다. 이 연산자가 어떻게 코드를 깨끗하게 만들어주는지, 위의 예제와 똑같이 동작하는 아래 예제와 비교해 보도록 하자.</p>

<pre><code>  
iex&gt; Enum.sum(Enum.filter(Enum.map(1..100_000, &amp;(&amp;1 * 3)), odd?))
  
7500000000
  
</code></pre>

<p>파이프 연산자에 대해 더 알고 싶다면, <a href="http://elixir-lang.org/docs/stable/elixir/#!Kernel.html#%7C%3E/2">이 문서</a>를 읽어보도록 한다.</p>

<h2 id="streams">Streams</h2>

<p>elixir에서 Enum 모듈을 대체하는 Stream 모듈을 제공하는데, 게으른 평가(Lazy operations)을 지원한다.</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) |&gt; Stream.filter(odd?) |&gt; Enum.sum
  
7500000000
  
</code></pre>

<p>스트림은 게으르고 구성가능한 열거형이다. 즉시 리스트를 생성하지 않고, 연속된 계산만 만들어 둔 후 Enum 모듈에서 사용될 때에만 비로소 평가된다. 스트림은 큰(어쩌면 무한대의) 컬렉션에 사용하면 유용하다.</p>

<p>위의 예제에서 보여 주듯이, 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) 표현식은 스트림의 데이터타입을 반환하고 단지 1..100_000 사이의 map 계산만 표현하게 된다.(이 시점에 실제 계산은 수행되지 않는다.)</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3))
  
#Stream&lt;[enum: 1..100000, funs: [#Function&lt;34.16982430/1 in Stream.map/2&gt;]]&gt;
  
</code></pre>

<p>게다가 스트림은 파이프 연산자를 통해 여러 개의 스트림을 하나의 스트림으로 구성(composable)할 수 있다.</p>

<pre><code>  
iex&gt; 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) |&gt; Stream.filter(odd?)
  
#Stream&lt;[enum: 1..100000, funs: [&amp;#8230;]]&gt;
  
</code></pre>

<p>Stream 모듈의 많은 함수가 매개변수로 어떤 열거형도 받을 수 있고 결과로 스트림을 반환한다. 무한대의 스트림을 생성하는 함수도 있다. 예를 들어, Stream.cycle/1 함수는 주어진 열거형을 무한히 순환할 수 있는 스트림을 생성한다. 그런 스트림에 Enum.map/2 함수를 호출하면 영원히 순환에 빠지므로 조심해서 사용해야 한다.</p>

<pre><code>  
iex&gt; stream = Stream.cycle([1, 2, 3])
  
#Function&lt;15.16982430/2 in Stream.cycle/1&gt;
  
iex&gt; Enum.take(stream, 10)
  
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1]
  
</code></pre>

<p>Stream.unfold/2 함수는 주어진 초기 값으로부터 여러 값들을 생성하는데 사용할 수 있다.</p>

<pre><code>  
iex&gt; stream = Stream.unfold(&quot;hełło&quot;, &amp;String.next_codepoint/1)
  
#Function&lt;39.75994740/2 in Stream.unfold/2&gt;
  
iex&gt; Enum.take(stream, 3)
  
[&quot;h&quot;, &quot;e&quot;, &quot;ł&quot;]
  
</code></pre>

<p>또다른 재밌는 함수로 리소스를 감싸는데 사용되는 Stream.resource/3의 경우 열거하기 전에 올바르게 열려 있음을 보장하고 실패가 발생할 경우 닫힘을 보장한다. 예를 들어, 우리는 파일 스트림을 위해 다음과 같이 사용할 수 있다.</p>

<pre><code>  
iex&gt; stream = File.stream!(&quot;path/to/file&quot;)
  
#Function&lt;18.16982430/2 in Stream.resource/3&gt;
  
iex&gt; Enum.take(stream, 10)
  
</code></pre>

<p>위의 예제는 선택된 파일에서 먼저 10 줄을 가져온다. 이것은 큰 파일이나 네트워크같이 느린 리소스를 처리하는데 스트림이 매우 유용함을 뜻한다.</p>

<p>Enum과 Stream 모듈의 많은 양의 함수의 기능들에 압도될 수 있지만, 개별 케이스별로 매우 유사하기 때문에, 먼저 Enum 모듈에 집중하고 추후에 크고 느린 리소스를 처리할 때 Stream 모듈로 관심을 옮기는 것이 좋다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/enumerables-and-streams.html">Elixir Enumerables and Streams</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-15T00:00:00Z">
            15 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/12/elixir-binaries-strings-and-char-lists-621/">Elixir Binaries, strings and char lists (#6/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>&#8220;Basic types&#8221;에서 문자열에 대해 배웠고, 타입 검사를 위해 is_binary/1 함수를 사용했다.</p>

<pre><code>  
iex&gt; string = &quot;hello&quot;
  
&quot;hello&quot;
  
iex&gt; is_binary string
  
true
  
</code></pre>

<p>이번 챕터에서는, 바이너리가 무엇인가를 이해하고, 문자열과 어떤 연관이 있으며, &#8221;(single-quoted value)값,&#8217;이런 값&#8217;,이 무엇을 의미하는지 살펴본다.</p>

<h2 id="utf-8과-유니코드">UTF-8과 유니코드</h2>

<p>문자열은 UTF-8로 인코딩된 바이너리이다. 이것이 무엇을 의미하는지 정확히 이해하기 위해서는, 바이트와 코드 포인트(bytes and code-points)의 차이가 무엇인지 먼저 이해해야 한다.</p>

<p>유니코드 표준은 우리가 알고 있는 많은 문자들을 코드 포인트에 할당한다. 예를 들어, a 문자는 코드 포인트 97을 갖고, ł 문자는 코드 포인트 322를 갖는다. 문자열 &#8220;hełło&#8221; 를 디스크에 쓸 때, 우리는 코드 포인트를 바이트로 변환해야 한다. 하나의 바이트가 하나의 코드 포인트를 표현한다는 룰을 적용한다면, &#8220;hełło&#8221; 를 쓸 수 없을 것이다. 왜냐하면 ł 문자의 코드 포인트는 322이며 1 바이트는 0에서 255까지의 정수값을 갖기 때문이다. 하지만 우리는 &#8220;hełło&#8221;를 스크린에서 읽을 수 있어야 하므로, 어떻게든 표현되어야 한다. 인코딩이 필요한 이유가 바로 이 때문이다.</p>

<p>코드 포인트를 바이트로 표현할 때, 우리는 어떻게든 인코딩해야 한다. elixir는 기본 인코딩으로 UTF-8을 사용한다. 우리가 문자열을 말할 때, UTF-8로 인코딩된 바이너리를 의미하고, 문자열은 UTF-8로 명확하게 인코딩된 특정 코드 포인트로 표현된 바이트의 묶음이라고 볼 수 있다.</p>

<p>우리는 ł 문자에 할당된 숫자인 322와 같은 코드 포인트를 갖기 때문에, 그것을 표현하기 위해 1바이트 이상을 필요로 한다. 이것이 바로 byte_size/1와 String.length/1가 필요한 이유이다.</p>

<pre><code>  
iex&gt; string = &quot;hełło&quot;
  
&quot;hełło&quot;
  
iex&gt; byte_size string
  
7
  
iex&gt; String.length string
  
5
  
</code></pre>

<p>UTF-8은 h, e, o의 코드 포인트를 표현하기 위해 1 바이트만을 요구하지만, ł을 표현하기 위해서는 2 바이트를 요구한다. elixir에서는 코드 포인트를 얻기 위해 ?키워드를 사용할 수 있다.</p>

<pre><code>  
iex&gt; ?a
  
97
  
iex&gt; ?ł
  
322
  
</code></pre>

<p>String 모듈의 codepoints/1 함수를 사용해서 문자열을 코드 포인트별로 분리할 수 있다.</p>

<pre><code>  
iex&gt; String.codepoints(&quot;hełło&quot;)
  
[&quot;h&quot;, &quot;e&quot;, &quot;ł&quot;, &quot;ł&quot;, &quot;o&quot;]
  
</code></pre>

<p>elixir는 문자열 처리에 관련된 많은 뛰어난 기능을 지원한다.. 유니코드 처리를 위한 많은 기능 역시 제공한다. 사실, elixir는 &#8220;<a href="http://mortoray.com/2013/11/27/the-string-type-is-broken/">The string type is broken</a>&#8221; 아티클에서 보여주는 모든 테스트를 통과했다.</p>

<h2 id="binaries-and-bitstrings">Binaries (and bitstrings)</h2>

<p>elixir에서 바이너리는 &lt;&lt;&gt;&gt;를 사용해서 표현한다.</p>

<pre><code>  
iex&gt; &lt;&lt;0, 1, 2, 3&gt;&gt;
  
&lt;&lt;0, 1, 2, 3&gt;&gt;
  
iex&gt; byte_size &lt;&lt;0, 1, 2, 3&gt;&gt;
  
4
  
</code></pre>

<p>바이너리는 단순히 바이트의 순차배열이다. 바이트들은 어떤 식으로든 배열될 수 있는데, 꼭 유효한 문자열일 필요는 없다.</p>

<pre><code>  
iex&gt; String.valid?(&lt;&lt;239, 191, 191&gt;&gt;)
  
false
  
</code></pre>

<p>문자열 결합 동작은 사실 바이너리 결합 연산자를 사용하게 된다.</p>

<pre><code>  
iex&gt; &lt;&lt;0, 1&gt;&gt; &lt;&gt; &lt;&lt;2, 3&gt;&gt;
  
&lt;&lt;0, 1, 2, 3&gt;&gt;
  
</code></pre>

<p>elixir에서 일반적인 트릭으로 null 타입의 &lt;<0>&gt;을 결합해서 문자열 내부의 바이너리를 표현하는 방법이 있다.</p>

<pre><code>  
iex&gt; &quot;hełło&quot; &lt;&gt; &lt;&lt;0&gt;&gt;
  
&lt;&lt;104, 101, 197, 130, 197, 130, 111, 0&gt;&gt;
  
</code></pre>

<p>바이너리에서 각 숫자는 바이트의 표현이며, 0에서 255의 범위를 갖는다. 바이너리는 255보다 더 큰 숫자로 변경될 수 있는데, utf8로 코드 포인트가 자동 변경될 수 있다.</p>

<pre><code>  
iex&gt; &lt;&lt;255&gt;&gt;
  
&lt;&lt;255&gt;&gt;
  
iex&gt; &lt;&lt;256&gt;&gt; # truncated
  
&lt;&lt;0&gt;&gt;
  
iex&gt; &lt;&lt;256 :: size(16)&gt;&gt; # use 16 bits (2 bytes) to store the number
  
&lt;&lt;1, 0&gt;&gt;
  
iex&gt; &lt;&lt;256 :: utf8&gt;&gt; # the number is a code point
  
&quot;Ā&quot;
  
iex&gt; &lt;&lt;256 :: utf8, 0&gt;&gt;
  
&lt;&lt;196, 128, 0&gt;&gt;

</code></pre>

<p>바이트의 사이즈가 8bit일 때 1bit 크기의 값을 입력하면 어떻게 될까?</p>

<pre><code>  
iex&gt; &lt;&lt;1 :: size(1)&gt;&gt;
  
&lt;&lt;1::size(1)&gt;&gt;
  
iex&gt; &lt;&lt;2 :: size(1)&gt;&gt; # truncated
  
&lt;&lt;0::size(1)&gt;&gt;
  
iex&gt; is_binary(&lt;&lt; 1 :: size(1)&gt;&gt;)
  
false
  
iex&gt; is_bitstring(&lt;&lt; 1 :: size(1)&gt;&gt;)
  
true
  
iex&gt; bit_size(&lt;&lt; 1 :: size(1)&gt;&gt;)
  
1
  
</code></pre>

<p>값은 더이상 바이너리가 아니며, bitstring(단지 bit의 모음)이다! 그래서 바이너리는 비트의 개수가 8로 나누어떨어지는 bitstring이라고 할 수 있다.</p>

<p>바이너리와 bitstring에도 패턴 매치를 사용할 수 있다.</p>

<pre><code>  
iex&gt; &lt;&lt;0, 1, x&gt;&gt; = &lt;&lt;0, 1, 2&gt;&gt;
  
&lt;&lt;0, 1, 2&gt;&gt;
  
iex&gt; x
  
2
  
iex&gt; &lt;&lt;0, 1, x&gt;&gt; = &lt;&lt;0, 1, 2, 3&gt;&gt;
  
** (MatchError) no match of right hand side value: &lt;&lt;0, 1, 2, 3&gt;&gt;
  
</code></pre>

<p>바이너리의 각 요소(each entry)는 정확히 8bit이어야 한다. 그럼에도, 바이너리의 나머지 부분을 다음과 같이 매치할 수 있다.</p>

<pre><code>  
iex&gt; &lt;&lt;0, 1, x :: binary&gt;&gt; = &lt;&lt;0, 1, 2, 3&gt;&gt;
  
&lt;&lt;0, 1, 2, 3&gt;&gt;
  
iex&gt; x
  
&lt;&lt;2, 3&gt;&gt;
  
</code></pre>

<p>문자열에서도 &lt;&gt; 결합 연산자를 사용해 이와 유사한 처리를 할 수 있다.</p>

<pre><code>  
iex&gt; &quot;he&quot; &lt;&gt; rest = &quot;hello&quot;
  
&quot;hello&quot;
  
iex&gt; rest
  
&quot;llo&quot;
  
</code></pre>

<p>이것으로 문자열과 바이너리, bitstring에 대한 여정을 마친다. 문자열은 UTF-8로 인코딩된 바이너리이며, 바이너리는 8bit로 나누어 떨어지는 bitstring이다. 위의 내용들이 elixir가 비트와 바이트를 유연하게 처리한다는 것을 보여준다 하더라도, 대부분 is_binary/1와 byte_size/1 함수를 사용해서 바이너리를 처리하게 될 것이다.</p>

<h2 id="char-lists">Char lists</h2>

<p>문자 리스트(char list)는 문자들의 리스트 이상도 이하도 아니다.</p>

<pre><code>  
iex&gt; 'hełło'
  
[104, 101, 322, 322, 111]
  
iex&gt; is_list 'hełło'
  
true
  
iex&gt; 'hello'
  
'hello'
  
</code></pre>

<p>보시다시피, 문자 리스트는 바이트를 포함하는 대신 코드 포인트를 포함하며 &#8221;(single-quotes)에 묶어 표현할 수 있으며 리스트이다. &#8220;&#8221;(double-quotes)에 묶인 표현은 문자열(바이너리)이다.</p>

<p>실전에서 문자 리스트는 대부분 erlang과 인터페이싱할때 사용된다. 문자 리스트를 문자열로 변환할 때 to_string/1을 사용하고 반대의 경우 to_char_list/1를 사용한다.</p>

<pre><code>  
iex&gt; to\_char\_list &quot;hełło&quot;
  
[104, 101, 322, 322, 111]
  
iex&gt; to_string 'hełło'
  
&quot;hełło&quot;
  
iex&gt; to_string :hello
  
&quot;hello&quot;
  
iex&gt; to_string 1
  
&quot;1&quot;
  
</code></pre>

<p>이들 함수는 다형성을 지니고 있다. 단순히 문자 리스트를 문자열로 변환하는 것이 아니라 정수나 atom등을 문자열로 변환할 수 있다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html">Elixir Binaries, strings and char lists</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-12T00:00:00Z">
            12 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/12/elixir-keywords-maps-and-dicts-721/">Elixir Keywords, maps and dicts (#7/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>지금까지 자료구조와 관련된 논의는 하지 않았다. 예를 들어, 키에 특정 값을 연관시키는 자료구조 같은 것 등을 말이다. 다른 언어에서는 이러한 자료구조를 사전(Dictionary), 해시(Hash), 연관 배열(Associative Array), 맵(Map)등으로 부른다.</p>

<p>elixir에는 두 개의 주요 연관 자료구조가 있다: 키워드 리스트(keyword lists)와 맵(maps)이다. 이번에는 이들에 대해 배워보도록 한다.</p>

<h2 id="keyword-lists">Keyword lists</h2>

<p>많은 함수형 프로그래밍 언어에서는, 연관 자료구조를 표현하는데 tuple 두 개를 사용한 리스트를 일반적으로 사용한다. elixir에서는 첫 번째 요소가 atom이며 두 번째 요소가 값인 튜플을 갖는 리스트를 사용할 때, 이를 키워드 리스트라고 부른다.</p>

<pre><code>  
iex&gt; list = [{:a, 1}, {:b, 2}]
  
[a: 1, b: 2]
  
iex&gt; list == [a: 1, b: 2]
  
true
  
iex&gt; list[:a]
  
1
  
</code></pre>

<p>보다시피, elixir는 이러한 리스트를 정의하기 위한 특수한 구문을 가지고 있으며, 내부적으로 튜플의 리스트로 이뤄져 있다. 이들은 단순히 리스트이기때문에, 리스트와 관련된 모든 처리를 수행할 수 있고, 리스트의 성능 관련 특성이 키워드 리스트에도 그대로 적용된다.</p>

<p>예를 들어, 키워드 리스트에 ++ 연산자를 사용해 새로운 값을 추가할 수 있다.</p>

<pre><code>  
iex&gt; list ++ [c: 3]
  
[a: 1, b: 2, c: 3]
  
iex&gt; [a: 0] ++ list
  
[a: 0, a: 1, b: 2]
  
</code></pre>

<p>주목할 것은 두 번째 문장의 경우 리스트의 앞에 중복 추가되며(이미 a: 1 요소가 있지만), 조회를 하게 되면 첫 번째 요소(새로 추가된 a: 0)만 가져오게 된다.</p>

<pre><code>  
iex&gt; new_list = [a: 0] ++ list
  
[a: 0, a: 1, b: 2]
  
iex&gt; new_list[:a]
  

  
</code></pre>

<p>키워드 리스트는 다음의 세가지 특성때문에 매우 중요하다.</p>

<ul>
<li>키는 반드시 atom이어야 한다.</li>
<li>키는 개발자가 지정한대로 정렬되어 있다.</li>
<li>키는 한 번 이상 주어질 수 있다.</li>
</ul>

<p>예를 들어, <a href="https://github.com/elixir-lang/ecto">Ecto library</a>의 경우 이러한 특징을 데이터베이스 쿼리를 우아하게 작성하는데 사용하고 있다.</p>

<pre><code>  
query = from w in Weather,
        
where: w.prcp &gt; 0,
        
where: w.temp &lt; 20,
       
select: w
  
</code></pre>

<p>이러한 특징들로 인해 elixir에서는 함수에 옵션을 넘겨줄 때 사용하는 기본 매커니즘으로 키워드 리스트를 사용하고 있다. 챕터 5에서, if/2 매크로를 살펴보았는데, 다음 구문이 지원됨을 언급했었다.</p>

<pre><code>  
iex&gt; if false, do: :this, else: :that
  
:that
  
</code></pre>

<p>do:와 else: 쌍은 키워드 리스트이다! 사실, 위의 구문은 다음과 동일하다.</p>

<pre><code>  
iex&gt; if(false, [do: :this, else: :that])
  
:that
  
</code></pre>

<p>일반적으로, 키워드리스트가 함수의 마지막 매개변수일 때, 대괄호(square brackets)는 생략할 수 있다.</p>

<p>키워드 리스트를 처리하기 위해, elixir는 Keyword 모듈을 제공한다.</p>

<p>키워드 리스트가 단순히 리스트이기때문에, 리스트의 선형적인 성능 특성을 갖는다는 것을 명심해야 한다. 더 긴 리스트는 키를 찾기 위해 더 긴 시간이 필요하고, 아이템의 개수를 구하기 위해 더 긴 시간이 필요한 등등의 특징을 말한다. 이러한 이유로, 키워드 리스트는 elixir에서 주로 옵션을 표현할 때 사용한다. 만약 많은 수의 아이템을 key-value 방식으로 저장하고 싶다면 맵(maps)을 사용해야 한다.</p>

<p>키워드 리스트에 패턴 매치를 수행할 수 있긴 하지만, 실제로는 드물게 사용된다. 이유는 리스트의 패턴 매칭은 매치를 위해 아이템의 개수와 순서를 요구하기 때문이다.</p>

<pre><code>  
iex&gt; [a: a] = [a: 1]
  
[a: 1]
  
iex&gt; a
  
1
  
iex&gt; [a: a] = [a: 1, b: 2]
  
** (MatchError) no match of right hand side value: [a: 1, b: 2]
  
iex&gt; [b: b, a: a] = [a: 1, b: 2]
  
** (MatchError) no match of right hand side value: [a: 1, b: 2]
  
</code></pre>

<h2 id="maps">Maps</h2>

<p>key-value 저장이 필요할때마다, elixir에서는 맵을 사용하면 된다. 맵은 %{} 구문으로 생성할 수 있다.</p>

<pre><code>  
iex&gt; map = %{:a =&gt; 1, 2 =&gt; :b}
  
%{2 =&gt; :b, :a =&gt; 1}
  
iex&gt; map[:a]
  
1
  
iex&gt; map[2]
  
:b
  
iex&gt; map[:c]
  
nil
  
</code></pre>

<p>키워드 리스트와 비교해보면 다음과 같은 두 가지 차이점을 발견할 수 있다.</p>

<ul>
<li>맵은 키에 어떤 값이라도 사용할 수 있다.</li>
<li>맵의 키는 어떤 순서도 따르지 않는다.</li>
</ul>

<p>만약 맵을 만들 때 중복 키를 사용하면 마지막에 사용된 키가 사용된다.</p>

<pre><code>  
iex&gt; %{1 =&gt; 1, 1 =&gt; 2}
  
%{1 =&gt; 2}
  
</code></pre>

<p>맵에서 모든 키가 atom이라면, 편리하게 키워드 구문을 사용할 수 있다.</p>

<pre><code>  
iex&gt; map = %{a: 1, b: 2}
  
%{a: 1, b: 2}
  
</code></pre>

<p>키워드 리스트에 비해서, 맵은 패턴 매칭에 매우 유용하다.</p>

<pre><code>  
iex&gt; %{} = %{:a =&gt; 1, 2 =&gt; :b}
  
%{:a =&gt; 1, 2 =&gt; :b}
  
iex&gt; %{:a =&gt; a} = %{:a =&gt; 1, 2 =&gt; :b}
  
%{:a =&gt; 1, 2 =&gt; :b}
  
iex&gt; a
  
1
  
iex&gt; %{:c =&gt; c} = %{:a =&gt; 1, 2 =&gt; :b}
  
** (MatchError) no match of right hand side value: %{2 =&gt; :b, :a =&gt; 1}
  
</code></pre>

<p>보다시피, 맵은 주어진 맵보다 더 적은 키로 매치해도 잘 작동한다. 게다가 빈 맵은 모든 맵과 매치할 수 있다.</p>

<p>Map 모듈은 keyword 모듈과 매우 유사한 기능을 제공한다.</p>

<pre><code>  
iex&gt; Map.get(%{:a =&gt; 1, 2 =&gt; :b}, :a)
  
1
  
iex&gt; Map.to_list(%{:a =&gt; 1, 2 =&gt; :b})
  
[{2, :b}, {:a, 1}]
  
</code></pre>

<p>맵에서 흥미로운 속성 중 하나는 atom 키에 접근해서 값을 조회하거나 수정할 수 있는 특정 구문을 제공한다는 것이다.</p>

<pre><code>  
iex&gt; map = %{:a =&gt; 1, 2 =&gt; :b}
  
%{:a =&gt; 1, 2 =&gt; :b}

iex&gt; map.a
  
1
  
iex&gt; map.c
  
** (KeyError) key :c not found in: %{2 =&gt; :b, :a =&gt; 1}

iex&gt; %{map | :a =&gt; 2}
  
%{:a =&gt; 2, 2 =&gt; :b}
  
iex&gt; %{map | :c =&gt; 3}
  
** (ArgumentError) argument error
  
</code></pre>

<p>접근이나 수정 구문 모두 키가 존재해야 한다. 예르 들어, :c 키를 사용할 경우에는 맵에 존재하지 않기 때문에 에러가 발생한다.</p>

<p>elixir 개발자는 일반적으로 맵 처리를 할 때 Map 모듈의 함수를 사용하는 대신 map.field 구문이나 패턴 매치를 사용하는 것을 선호하는데, 이유는 단정적인 프로그래밍 스타일(Assertive style of programming)을 이끌어내기 때문이다. elixir에서 단정적인 코드를 작성하는 것으로 얼마나 간결하고 빠른 소프트웨어를 작성할 수 있는지에 대한 예제와 인사이트를 보고 싶다면 <a href="http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/">이 블로그 포스트</a>를 참고하면 된다.</p>

<blockquote>
<p>Map은 <a href="http://www.erlang.org/eeps/eep-0043.html">EEP 43</a>과 함께 erlang VM에 최근에 소개되었다. erlang 17은 EEP의 일부분인 &#8220;small maps&#8221;를 지원한다. 이것이 의미하는 것은 맵의 최대 키 저장개수가 수십개일 때에만 좋은 성능 특성을 보여준다는 것이다. 이러한 간극을 매우기 위해, elixir는 수백 수천의 키에도 좋은 성능을 제공하는 해시 알고리즘을 사용하는 HashDict 모듈을 제공한다.</p>
</blockquote>

<h2 id="dicts">Dicts</h2>

<p>elixir는 키워드 리스트와 맵 모두를 사전(Dictionary)이라 부른다. 다른 말로 말하자면, 사전은 인터페이스이고 키워드 리스트와 맵은 이 사전 인터페이스를 구현한 모듈이라고 할 수 있다.</p>

<p>이 사전 인터페이스는 구현에 구체적인 기능을 위임하는 API를 갖는 Dict 모듈에 정의되어 있다.(키워드 리스트와 맵이 공통으로 사용할 수 있는 API를 정의하고 있다)</p>

<pre><code>  
iex&gt; keyword = []
  
[]
  
iex&gt; map = %{}
  
%{}
  
iex&gt; Dict.put(keyword, :a, 1)
  
[a: 1]
  
iex&gt; Dict.put(map, :a, 1)
  
%{a: 1}
  
</code></pre>

<p>Dict 모듈은 어떤 개발자라도 개발자 자신의 특수한 특성을 갖고 elixir의 현존하는 코드를 후킹할 수 있는 Dict 변종을 구현할 수 있도록 허용한다. Dict 모듈은 또한 서로 다른 사전에서 동작하는 함수를 제공한다. 예를 들어, Dict.equal?/2 함수는 서로 다른 타입의 두 사전을 비교할 수 있다.</p>

<p>이쯤에서 궁금할 것이다. 우리의 코드에서 Keyword, Map, Dict중 어떤 것을 사용해야 할까? 대답은 &#8220;그때 그때 달라요 &#8211; it depends.&#8221; 이다.</p>

<p>우리의 코드가 매개변수로 특정한 자료구조를 기대한다면, 좀더 단정적인 코드를 유도하는 각각의 모듈을 사용해라. 예를 들어, 매개변수로 키워드를 기대한다면, Dict대신 Keyword 모듈을 사용하면 된다. 하지만, 우리의 API가 어떤 사전과도 잘 작동해야 한다면, Dict 모듈을 사용하면 된다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/maps-and-dicts.html">Elixir Keywords, maps and dicts</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-12T00:00:00Z">
            12 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/12/elixir-modules-821/">Elixir Modules (#8/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>elixir에서 우리는 모듈에 여러 함수를 그룹지을 수 있다. 우리는 이전 챕터에서 String 모듈 같은 여러 다른 모듈들을 사용했다.</p>

<pre><code>  
iex&gt; String.length &quot;hello&quot;
  
5
  
</code></pre>

<p>elixir에서 우리만의 모듈을 만들기 위해, 우리는 defmodule 매크로를 사용해야 한다. 우리는 우리의 모듈에서 함수를 정의하기 위해 def 매크로를 사용할 수 있다.</p>

<pre><code>  
iex&gt; defmodule Math do
  
&amp;#8230;&gt; def sum(a, b) do
  
&amp;#8230;&gt; a + b
  
&amp;#8230;&gt; end
  
&amp;#8230;&gt; end

iex&gt; Math.sum(1, 2)
  
3
  
</code></pre>

<p>다음 섹션에서, 우리의 예제는 좀 더 복잡해질 것이고, 쉘에서 그 모듈이 마치 타입 처럼 동작하는 것을 보게 될 것이다. 이쯤에서 elixir 코드를 어떻게 컴파일하고 elixir 스크립트를 어떻게 실행할 수 있는지 배워보자.</p>

<h2 id="compilation">Compilation</h2>

<p>모듈을 파일에 작성하면 컴파일하고 재사용할 수 있기 때문에 매우 편리하다. 우리가 만들 모듈이 다음과 같은 내용을 포함하며 파일명이 math.ex라고 가정하자.</p>

<pre><code>  
defmodule Math do
    
def sum(a, b) do
      
a + b
    
end
  
end
  
</code></pre>

<p>이 파일은 elixirc를 사용해 다음과 같이 컴파일할 수 있다.</p>

<pre><code>  
$ elixirc math.ex
  
</code></pre>

<p>컴파일 결과로 해당 모듈의 바이트코드를 포함하는 Elixir.Math.beam 파일이 생성될 것이다. iex를 다시 시작하고, 우리의 모듈이 잘 작동하는지 확인해 보자.(iex는 beam파일이 있는 디렉토리에서 실행해야 한다.)</p>

<pre><code>  
iex&gt; Math.sum(1, 2)
  
3
  
</code></pre>

<p>elixir 프로젝트는 일반적으로 다음 세개의 디렉토리로 구성된다.</p>

<ul>
<li>ebin &#8211; 컴파일된 바이트코드를 포함</li>
<li>lib &#8211; elixir 코드(일반적으로 .ex 파일들)를 포함</li>
<li>test &#8211; 테스트 코드를 포함(일반적으로 .exs 파일들)</li>
</ul>

<p>실제 프로젝트로 작업할 때에는, mix라고 불리는 빌드 툴을 사용해 적합한 경로를 구성하고 컴파일하게 될 것이다.</p>

<p>배움의 목적으로, elixir가 컴파일 과정 없이 좀 더 유연하게 사용할 수 있는 스크립트 모드를 지원한다는 것을 알아두자.</p>

<h2 id="scripted-mode">Scripted mode</h2>

<p>.ex 파일에 더해, elixir는 스크립팅을 위한 .exs 파일을 지원한다. elixir는 정확히 같은 방식으로 두 파일을 처리하는데, 차이는 단지 목적(용도)에 있다. .ex 파일은 컴파일 목적이고, .exs 파일은 컴파일 과정이 필요없는 스크립팅 목적으로 사용한다. 예를 들어, 우리가 다음과 같은 math.exs라는 파일을 만들었다고 보자.</p>

<pre><code>  
defmodule Math do
    
def sum(a, b) do
      
a + b
    
end
  
end

IO.puts Math.sum(1, 2)
  
</code></pre>

<p>이 파일은 다음과 같이 실행할 수 있다.</p>

<pre><code>  
$ elixir math.exs
  
</code></pre>

<p>해당 파일은 메모리상에서 컴파일되고 실행되어 결과로 &#8220;3&#8221;을 출력할 것이다. 어떤 바이트코드도 생성되지 않는다.</p>

<h2 id="named-functions">Named functions</h2>

<p>모듈안에서, 우리는 def/2(매개변수 2개를 갖는) public 함수를 정의하고 defp/2 private 함수를 정의할 수 있다. def/2 함수는 다른 모듈에서 호출할 수 있지만, defp/2 함수는 동일 모듈(invoked locally)에서만 호출할 수 있다.</p>

<pre><code>  
defmodule Math do
    
def sum(a, b) do
      
do_sum(a, b)
    
end

defp do_sum(a, b) do
      
a + b
    
end
  
end

Math.sum(1, 2) #=&gt; 3
  
Math.do_sum(1, 2) #=&gt; ** (UndefinedFunctionError)
  
</code></pre>

<p>함수 선언 역시 복수의 절(clauses)과 가드(guards)를 지원한다. 함수가 여러 절을 갖는다면, elixir는 매치하는 절을 찾을 때까지 각 절을 평가할 것이다.</p>

<p>여기에 주어진 숫자가 0인지 아닌지 검사하는 함수 구현이 있다.</p>

<pre><code>  
defmodule Math do
    
def zero?(0) do
      
true
    
end

def zero?(x) when is_number(x) do
      
false
    
end
  
end

Math.zero?(0) #=&gt; true
  
Math.zero?(1) #=&gt; false

Math.zero?([1,2,3])
  
#=&gt; ** (FunctionClauseError)
  
</code></pre>

<p>주어진 매개변수와 일치하는 절을 갖는 함수가 없을 경우 에러가 발생할 것이다.</p>

<h2 id="function-capturing">Function capturing</h2>

<p>지금까지 우리는 함수의 표기법을 name/arity와 같이 표기해 왔다. 이 표기는 함수 타입으로 이름 있는 함수를 받을때 사용할 수 있다. 위에서 사용한 math.exs를 iex를 사용해서 시작해 보자.</p>

<pre><code>  
$ iex math.exs
  
</code></pre>

<pre><code>  
iex&gt; Math.zero?(0)
  
true
  
iex&gt; fun = &amp;Math.zero?/1
  
&amp;Math.zero?/1
  
iex&gt; is_function fun
  
true
  
iex&gt; fun.(0)
  
true
  
</code></pre>

<p>지역 함수나 이미 포함된(imported) 함수(is_function/1 같은)는 모듈명 없이 캡춰할 수 있다.</p>

<pre><code>  
iex&gt; &amp;is_function/1
  
&amp;:erlang.is_function/1
  
iex&gt; (&amp;is_function/1).(fun)
  
true
  
</code></pre>

<p>캡춰 구문은 또한 함수를 생성하는 축약된 형태로 사용될 수도 있음을 명심한다.</p>

<pre><code>  
iex&gt; fun = &amp;(&amp;1 + 1)
  
#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;
  
iex&gt; fun.(1)
  
2
  
</code></pre>

<p>&amp;1은 함수에 전달된 첫 번째 매개변수를 표현한다. &amp;(&amp;1 + 1)은 정확히 fn x -&gt; x + 1 end 와 동일하다. 위 구문은 함수 정의를 축약하는데 도움을 준다.</p>

<p>같은 방법으로 모듈에서 함수를 호출하고 싶다면, &amp;Module.function() 구문을 사용할 수 있다.</p>

<pre><code>  
iex&gt; fun = &amp;List.flatten(&amp;1, &amp;2)
  
&amp;List.flatten/2
  
iex&gt; fun.([1, [[2], 3]], [4, 5])
  
[1, 2, 3, 4, 5]
  
</code></pre>

<p>&amp;List.flatten(&amp;1, &amp;2)은 fn(list, tail) -&gt; List.flatten(list, tail) end와 동일하다. 캡춰 연산자에 대해 더 자세히 알고 싶다면 &#8220;<a href="http://elixir-lang.org/docs/stable/elixir/#!Kernel.SpecialForms.html#&amp;/1">kernel.SpecialForms 문서</a>&#8220;를 참고하도록 한다.</p>

<h2 id="default-arguments">Default arguments</h2>

<p>elixir에서 이름있는 함수는 기본 매개변수를 지원한다.</p>

<pre><code>  
defmodule Concat do
    
def join(a, b, sep \ &quot; &quot;) do
      
a &lt;&gt; sep &lt;&gt; b
    
end
  
end

IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;) #=&gt; Hello world
  
IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;, &quot;\_&quot;) #=&gt; Hello\_world
  
</code></pre>

<p>어떤 표현식도 기본 값으로 사용할 수 있지만, 함수가 정의되는 동안 평가되진 않을 것이다; 단지 나중에 사용되기 위해 저장될 뿐이다. 매번 함수가 호출될때마다 기본 값은 사용되며, 기본 값이 평가된다.</p>

<pre><code>  
defmodule DefaultTest do
    
def dowork(x \ IO.puts &quot;hello&quot;) do
      
x
    
end
  
end
  
</code></pre>

<pre><code>  
iex&gt; DefaultTest.dowork
  
hello
  
:ok
  
iex&gt; DefaultTest.dowork 123
  
123
  
iex&gt; DefaultTest.dowork
  
hello
  
:ok
  
</code></pre>

<p>기본 값이 있는 함수가 복수의 절을 갖을 경우에는 함수의 선언부(구현부가 없는)가 있어야 하고 기본값을 선언하기 위한 용도로만 사용된다.</p>

<pre><code>  
defmodule Concat do
    
def join(a, b \ nil, sep \ &quot; &quot;)

def join(a, b, \_sep) when is\_nil(b) do
      
a
    
end

def join(a, b, sep) do
      
a &lt;&gt; sep &lt;&gt; b
    
end
  
end

IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;) #=&gt; Hello world
  
IO.puts Concat.join(&quot;Hello&quot;, &quot;world&quot;, &quot;\_&quot;) #=&gt; Hello\_world
  
IO.puts Concat.join(&quot;Hello&quot;) #=&gt; Hello
  
</code></pre>

<p>기본 값을 사용할 때, 함수 정의가 중복되지 않도록 주의해야 한다. 다음 예를 보자.</p>

<pre><code>  
defmodule Concat do
    
def join(a, b) do
      
IO.puts &quot;\***First join&quot;
      
a &lt;&gt; b
    
end

def join(a, b, sep \ &quot; &quot;) do
      
IO.puts &quot;\***Second join&quot;
      
a &lt;&gt; sep &lt;&gt; b
    
end
  
end
  
</code></pre>

<p>위 내용을 &#8220;concat.ex&#8221;라는 파일명으로 저장하고 컴파일 하면 elixir는 다음과 같은 경고를 출력한다.</p>

<pre><code>  
concat.ex:7: this clause cannot match because a previous clause at line 2 always matches
  
</code></pre>

<p>컴파일러는 두 개의 매개변수를 사용한 join 함수 호출시에는 항상 첫 번째 정의된 join/2함수가 호출되면 기본값이 사용된 두 번째 join/3 함수는 3개의 매개변수를 사용할 때만 호출된다고 알려준다.</p>

<pre><code>  
$ iex concat.exs
  
</code></pre>

<pre><code>  
iex&gt; Concat.join &quot;Hello&quot;, &quot;world&quot;
  
\***First join
  
&quot;Helloworld&quot;
  
</code></pre>

<pre><code>  
iex&gt; Concat.join &quot;Hello&quot;, &quot;world&quot;, &quot;_&quot;
  
\***Second join
  
&quot;Hello_world&quot;
  
</code></pre>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/modules.html">Elixir Modules</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-12T00:00:00Z">
            12 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/12/elixir-recursion-921/">Elixir Recursion (#9/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<h2 id="loops-through-recursion">Loops through recursion</h2>

<p>불변성때문에, elixir에서 loop는(모든 함수형 프로그래밍 언어에서 마찬가지로) 다른 언어들과 다르게 작성한다. 예를 들어, c 언어 같은 경우에는 다음과 같을 것이다.</p>

<pre><code>  
for(i = 0; i &lt; array.length; i++) {
    
array[i] = array[i] * 2
  
}
  
</code></pre>

<p>위의 예제가 보여주는 바는, i와 array 둘 모두 값이 변경되는 가변성이다. 가변성은 elixir에서 가능하지 않다. 대신, 함수형 언어는 재귀(recursion)에 의존한다: 함수는 조건이 지속되는 상황에서 종료되는 상황에 이를때까지 재귀적으로 호출된다. 이 처리 과정에서 어떤 데이터도 변경되지 않는다. 임의의 횟수동안 문자열을 출력하는 다음 예제를 살펴보자.</p>

<pre><code>  
defmodule Recursion do
    
def print\_multiple\_times(msg, n) when n &lt;= 1 do
      
IO.puts msg
    
end

def print\_multiple\_times(msg, n) do
      
IO.puts msg
      
print\_multiple\_times(msg, n &amp;#8211; 1)
    
end
  
end

Recursion.print\_multiple\_times(&quot;Hello!&quot;, 3)
  
\# Hello!
  
\# Hello!
  
\# Hello!

</code></pre>

<p>case와 유사하게 함수는 복수개의 절을 갖고 있다. 특정 절에 일치(매치)하고 해당 절의 가드가 true로 평가될 때에만, 해당 절이 실행된다.</p>

<p>print_multiple_times/2 함수가 처음 호출될 때 매개변수 n은 3의 값을 갖는다.</p>

<p>첫 번째 절의 가드는 입력 매개변수인 n이 1과 같거나 작은 경우에만 수행되도록 제한하고 있다. 따라서 초기 호출시 n은 3이므로 이 경우에 해당되지 않으므로 다음 함수 절로 처리가 넘겨진다.</p>

<p>두 번째 절의 정의는 패턴이 일치(매개변수의 개수가 동일)하고 가드가 없기 때문에 실행된다. 먼저 msg를 출력하고 재귀적으로 n의 값을 1 감소(n &#8211; 1, n == 2) 시키고 호출한다.</p>

<p>두 번째 함수 호출에서 n(2)의 값은 여전히 1보다 크기때문에 두 번째 함수 절이 실행되며, 마지막 호출에서 비로소 n(1)이 첫 번째 함수 절의 가드 조건에 부합하므로 msg를 출력하고 재귀를 종료한다.</p>

<h2 id="reduce-and-map-algorithms">Reduce and map algorithms</h2>

<p>자, 이제 숫자 리스트의 합계를 구하기 위해 재귀의 힘을 어떻게 사용하는지 살펴보도록 하자.</p>

<pre><code>  
defmodule Math do
    
def sum_list([head|tail], accumulator) do
      
sum_list(tail, head + accumulator)
    
end

def sum_list([], accumulator) do
      
accumulator
    
end
  
end

IO.puts Math.sum_list([1, 2, 3], 0) #=&gt; 6
  
</code></pre>

<p>먼저 리스트 [1, 2, 3]과 초기 누적값 0을 매개변수로 sum_list/2 함수를 호출한다. 우리는 정의된 함수 절과 일치하는 하나를 찾을 때까지 패턴 매치를 수행한다. 이 경우에는, 리스트 [1, 2, 3]이 [head | tail]과 일치하므로, head에 1, tail에 [2, 3], accumulator에 0이 바인드 된다.</p>

<p>그 후, head에 accumulator를 더한 후(1 + 0) sum_list를 재귀적으로 호출하는데, 이 때 tail과 head + accumulator를 매개변수로 전달하게 된다. tail은 다시 한 번 [head | tail]과 일치하고 첫 번째 매개변수인 리스트가 빈 리스트([])가 될 때까지 반복하게 된다.</p>

<pre><code>  
sum_list [1, 2, 3], 0
  
sum_list [2, 3], 1
  
sum_list [3], 3
  
sum_list [], 6
  
</code></pre>

<p>리스트가 빈 리스트가 되면, 마지막 절에 일치하게 되고 최종 결과인 6을 반환하게 된다.</p>

<p>리스트를 가져와 하나의 값으로 감소시키는 처리를 reduce algorithm이라고 하며 함수형 프로그래밍의 핵심이다.</p>

<p>만약 우리가 리스트의 각 값을 두 배로 만들길 원한다면?</p>

<pre><code>  
defmodule Math do
    
def double_each([head|tail]) do
      
[head * 2|double_each(tail)]
    
end

def double_each([]) do
      
[]
    
end
  
end
  
</code></pre>

<pre><code>  
iex math.exs
  
</code></pre>

<pre><code>  
iex&gt; Math.double_each([1, 2, 3]) #=&gt; [2, 4, 6]
  
</code></pre>

<p>위의 예는 리스트의 각 요소를 탐색하고, 값을 두배로 만들어 새로운 리스트를 반환하는 재귀함수를 보여준다. 리스트를 가져와 각 요소별로 맵핑하는(mapping over) 처리를 map algorithm이라고 한다.</p>

<p>재귀와 <a href="http://en.wikipedia.org/wiki/Tail_call">tail cal &#8211; 스택을 사용하지 않는 최적화된 재귀호출, 함수의 중간에서 재귀호출이 일어나선 안된다 &#8211;</a> 최적화는 elixir에서 중요한 부분이고 loop를 생성할 때 일반적으로 사용된다. 하지만, elixir에서 프로그래밍할 때 리스트를 처리하기 위해 위와 같은 재귀호출을 사용하는 것은 드물 것이다.</p>

<p>다음 챕터에서 살펴볼 Enum 모듈은 리스트를 편리하게 처리할 수 있는 많은 기능을 제공하고 있다. 일례로, 위의 예제는 다음과 같이 재작성할 수 있다.</p>

<pre><code>  
iex&gt; Enum.reduce([1, 2, 3], 0, fn(x, acc) -&gt; x + acc end)
  
6
  
iex&gt; Enum.map([1, 2, 3], fn(x) -&gt; x * 2 end)
  
[2, 4, 6]
  
</code></pre>

<p>또는 캡춰 구문을 사용할 수도 있다.</p>

<pre><code>  
iex&gt; Enum.reduce([1, 2, 3], 0, &amp;+/2)
  
6
  
iex&gt; Enum.map([1, 2, 3], &amp;(&amp;1 * 2))
  
[2, 4, 6]
  
</code></pre>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/recursion.html">Elixir Recursion</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-12T00:00:00Z">
            12 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/11/elixir-basic-operators/">Elixir Basic operators (#3/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>이전 챕터에서는 +, -, *, / 산술 연산자를 살펴보았다.</p>

<p>이 외에도 elixir는 리스트 연산을 위해 ++와 &#8212; 연산자를 제공한다.</p>

<pre><code>  
iex&gt; [1,2,3] ++ [4,5,6]
  
[1,2,3,4,5,6]
  
iex&gt; [1,2,3] &amp;#8212; [2]
  
[1,3]
  
</code></pre>

<p>문자열의 결합에는 연산자를 사용한다.</p>

<pre><code>  
iex&gt; &quot;foo&quot; &lt;&gt; &quot;bar&quot;
  
&quot;foobar&quot;
  
</code></pre>

<p>elixir는 논리 연산을 위해 or, and, not과 같은 논리 연산자를 제공한다. 연산의 결과는 true 또는 false값이며 연산자의 매개변수 역신 boolean타입(true or false)이어야 한다.</p>

<pre><code>  
iex&gt; true and true
  
true
  
iex&gt; false or is_atom(:example)
  
true
  
</code></pre>

<p>논리 연산자의 매개변수로 boolean타입이 제공되지 않으면 예외를 발생시킨다.</p>

<pre><code>  
iex&gt; 1 and true
  
** (ArgumentError) argument error
  
</code></pre>

<p>or 와 and 연산자는 short-circuit 연산자이다. short-circuit 연산은 좌측 연산의 결과에 따라 우측 연산의 수행을 결정(무시할지 말지)하는 연산을 말한다.</p>

<pre><code>  
iex&gt; false and error(&quot;This error will never be raised&quot;)
  
false

iex&gt; true or error(&quot;This error will never be raised&quot;)
  
true
  
</code></pre>

<blockquote>
<p>erlang에서는 elixir의 and와 or 연산자는 andalso와 orelse연산자와 동일하다.</p>
</blockquote>

<p>또한 ||, &amp;&amp;, ! 연산자도 제공하는데 이 연산자의 경우 어떤 타입도 매개변수로 올 수 있다. 이들 연산자에 사용되는 데이터 타입의 값은 false와 nil을 제외하고 모두 true로 평가된다.</p>

<pre><code>  
\# or
  
iex&gt; 1 || true
  
1
  
iex&gt; false || 11
  
11

\# and
  
iex&gt; nil &amp;&amp; 13
  
nil
  
iex&gt; true &amp;&amp; 17
  
17

\# !
  
iex&gt; !true
  
false
  
iex&gt; !1
  
false
  
iex&gt; !nil
  
true
  
</code></pre>

<p>||와 &amp;&amp; 연산의 결과sms true나 false가 아닌 short-circuit 규칙에 따른 결과가 출력됨을 유의해야 한다.</p>

<p>elixir는 비교 연산을 위해 ==, !=, ===, !==, =, 연산자도 제공한다.</p>

<pre><code>  
iex&gt; 1 == 1
  
true
  
iex&gt; 1 != 2
  
true
  
iex&gt; 1 &lt; 2
  
true
  
</code></pre>

<p>==와 ===연산자의 차이는 === 연산자가 integer와 float 연산에서 좀 더 정확한 연산을 수행한다는 것이다.</p>

<pre><code>  
iex&gt; 1 == 1.0
  
true
  
iex&gt; 1 === 1.0
  
false
  
</code></pre>

<p>elixir에서는 서로 다른 타입의 비교 연산도 가능하다.</p>

<pre><code>  
iex&gt; 1 &lt; :atom
  
true
  
</code></pre>

<p>이것이 가능한 이유는 서로 다른 데이터타입의 비교가 실용적이기 때문이다. 정렬 알고리즘을 사용할 때 데이터타입이 다르다고 해서 걱정할 필요가 없다. 타입별 정렬 우선순위는 다음과 같다.</p>

<pre><code>  
number &lt; atom &lt; reference &lt; functions &lt; port &lt; pid &lt; tuple &lt; maps &lt; list &lt; bitstring
  
</code></pre>

<p>위의 정렬순서를 기억할 필요는 없지만, 정렬 우선순위가 존재한다는 것은 기억하고 있어야 한다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/basic-operators.html">Elixir Basic Operators</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-11T00:00:00Z">
            11 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/11/elixir-pattern-matching-421/">Elixir Pattern matching (#4/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>이번 챕터에서는 = 연산자가 매치 연산자로 어떻게 사용되는지와 자료구조안에서 패턴매치가 어떻게 이뤄지는지 살펴볼 것이다. 마지막으로 핀 연산자(^)를 알아본다.</p>

<h2 id="매치-연산자">매치 연산자</h2>

<p>elixir에서 변수에 값을 할당하기 위해 = 연산자를 여러번 사용했다.</p>

<pre><code>  
iex&gt; x = 1
  
1
  
iex&gt; x
  
1
  
</code></pre>

<p>c/c++에서 = 연산자는 대입연산자(또는 할당연산자)라고 불리우지만 erlang과 elixir에서는 매치 연산자라고 부른다.</p>

<p>왜 그런지 살펴보자.</p>

<pre><code>  
iex&gt; 1 = x
  
1
  
iex&gt; 2 = x
  
** (MatchError) no match of right hand side value: 1
  
</code></pre>

<p>1 = x 표현식이 유효함을 주목한다. 현재 x에는 1이란 값이 할당되어 있고 좌측의 값(1)과 우측의 값(x)이 일치하기 때문에 예외가 발생하지 않는다.</p>

<p>2 = x 표현식은 좌/우측의 값이 매치하지 않으므로 MatchError 예외가 발생한다.</p>

<p>변수는 오직 = 연산자의 좌측에서만 값을 할당받을 수 있다.</p>

<pre><code>  
iex&gt; 1 = unknown
  
** (RuntimeError) undefined function: unknown/0
  
</code></pre>

<p>RuntimeError가 발생하는 이유는 unknown 변수가 이전에 정의(변수에 값이 할당되어 있지 않다)되어 있지 않기 때문이며, elixir는 변수가 아니라 함수호출이 아닐까 추측하고 unknown/0함수가 정의되어 있지 않다는 예외를 발생시킨다.</p>

<blockquote>
<p>erlang에서 변수는 한 번만 할당할 수 있지만, elixir에서는 동일 변수에 다른 값을 여러번 할당할 수 있다.</p>
</blockquote>

<h2 id="패턴-매칭">패턴 매칭</h2>

<p>매치 연산자는 단순한 값을 매치할 때만 사용하지 않고 좀 더 복잡한 데이터타입의 구조를 매치할 때도 사용할 수 있다. 예를 들면 튜플에서 다음과 같이 사용할 수 있다.</p>

<pre><code>  
iex&gt; {a, b, c} = {:hello, &quot;world&quot;, 42}
  
{:hello, &quot;world&quot;, 42}
  
iex&gt; a
  
:hello
  
iex&gt; b
  
&quot;world&quot;
  
</code></pre>

<p>a, b, c 변수에 동일한 튜플구조의 우측값을 사용해 각각 :hello, &#8220;world&#8221;, 42를 한 번에 매치시키는 예제이다.</p>

<p>만약 구조가 동일하지 않을 경우 다음과 같이 MatchError가 발생될 것이다.</p>

<pre><code>  
iex&gt; {a, b, c} = {:hello, &quot;world&quot;}
  
** (MatchError) no match of right hand side value: {:hello, &quot;world&quot;}
  
</code></pre>

<p>또한 데이터타입이 상이할 때도 예외가 발생한다.</p>

<pre><code>  
iex&gt; {a, b, c} = [:hello, &quot;world&quot;, &quot;!&quot;]
  
** (MatchError) no match of right hand side value: [:hello, &quot;world&quot;, &quot;!&quot;]
  
</code></pre>

<p>조금 더 흥미로운 것은 특정값을 사용해 매치를 시킬 수 있다는 것이다. 다음 예를 보면 첫 번째 요소가 :ok인 튜플과 매치할 때에만 유효한 평가식을 살펴볼 수 있다.</p>

<pre><code>  
iex&gt; {:ok, result} = {:ok, 13}
  
{:ok, 13}
  
iex&gt; result
  
13

iex&gt; {:ok, result} = {:error, :oops}
  
** (MatchError) no match of right hand side value: {:error, :oops}
  
</code></pre>

<p>리스트를 대상으로 패턴매치를 수행할 수 있다.</p>

<pre><code>  
iex&gt; [a, b, c] = [1, 2, 3]
  
[1, 2, 3]
  
iex&gt; a
  
1
  
</code></pre>

<p>리스트의 경우에는 head와 tail을 나누어 다음과 같이 매치를 활용할 수도 있다.</p>

<pre><code>  
iex&gt; [head | tail] = [1, 2, 3]
  
[1, 2, 3]
  
iex&gt; head
  
1
  
iex&gt; tail
  
[2, 3]
  
</code></pre>

<p>리스트의 head는 첫번째 요소의 값이고, tail은 head를 제외한 나머지 요소를 갖는 리스트를 의미한다.</p>

<p>hd/1, tl/1함수를 사용하는 것과 유사한 결과를 패턴매칭을 사용해 구현할 수 있다.</p>

<pre><code>  
iex&gt; [h|t] = []
  
** (MatchError) no match of right hand side value: []
  
</code></pre>

<p>[head | tail] 형태는 패턴 매치뿐만 아니라 리스트의 선두에 아이템을 삽입(prepending item)하는데도 사용할 수 있다.</p>

<pre><code>  
iex&gt; list = [1, 2, 3]
  
[1, 2, 3]
  
iex&gt; [0|list]
  
[0, 1, 2, 3]
  
</code></pre>

<p>패턴 매칭은 튜플과 리스트 같은 데이터타입의 구조를 해석(destructure)하는것을 용이하게 해 준다. 다음 챕터에서 elixir의 재귀 함수 중의 하나를 살펴보며, map이나 binary같은 타입에 어떻게 적용되는지 살펴보게 될 것이다.</p>

<h2 id="핀-연산자">핀 연산자</h2>

<p>elixir에서 변수는 재할당(rebound)될 수 있다.</p>

<pre><code>  
iex&gt; x = 1
  
1
  
iex&gt; x = 2
  
2
  
</code></pre>

<p>핀 연산자(^)는 변수가 재할당되지 않도록 방지하며, 오직 값이 매치하는지에만 사용한다.</p>

<pre><code>  
iex&gt; x = 1
  
1
  
iex&gt; ^x = 2
  
** (MatchError) no match of right hand side value: 2
  
iex&gt; {x, ^x} = {2, 1}
  
{2, 1}
  
iex&gt; x
  
2
  
</code></pre>

<p>x에 새로운 값인 2를 재할당(rebound)하기 위해 이전 x(^x)의 값이 1과 매치하는지 확인하고 있다.</p>

<p>아래와 같이 패턴에서 변수가 한 번 이상 언급(사용)될 경우, 모든 참조는 동일한 패턴에 바인드되어야 한다.</p>

<p>(역주 &#8211; 값의 할당이 일어나지 않고, 값의 패턴 매칭만 수행하게 된다는 의미 같다.)</p>

<pre><code>  
iex&gt; {x, x} = {1, 1}
  
1
  
iex&gt; {x, x} = {1, 2}
  
** (MatchError) no match of right hand side value: {1, 2}
  
</code></pre>

<p>패턴에서 특정한 값을 무시(매치할 필요도 없고 변수에 바인드할 필요도 없는)해야할 경우가 있는데, underscore(_)의 경우 해당 용도로 다음과 같이 사용할 수 있다.</p>

<pre><code>  
iex&gt; [h | _] = [1, 2, 3]
  
[1, 2, 3]
  
iex&gt; h
  
1
  
</code></pre>

<p>리스트의 tail을 _에 바인드했지만 사실상 무시한 것과 동일하며 _는 읽을 수 없다.</p>

<pre><code>  
iex&gt; _
  
** (CompileError) iex:1: unbound variable _
  
</code></pre>

<p>패턴 매칭이 강력한 구조를 만들도록 해 주지만, 사용이 제한적이다. 일례로, 좌측에 함수를 사용하여 매치할 수 없다.</p>

<pre><code>  
iex&gt; length([1,[2],3]) = 3
  
** (CompileError) iex:1: illegal pattern
  
</code></pre>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/pattern-matching.html">Elixir Pattern matching</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-11T00:00:00Z">
            11 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/11/elixir-case-cond-and-if-521/">Elixir case, cond and if (#5/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>이번 챕터에서는 흐름 제어에 사용되는 case, cond, if에 대해 알아본다.</p>

<h2 id="case">case</h2>

<p>case는 매치되는 하나를 찾기 위해 많은 패턴과 값을 비교할 때 사용한다.</p>

<pre><code>  
iex&gt; case {1, 2, 3} do
  
&amp;#8230;&gt; {4, 5, 6} -&gt;
  
&amp;#8230;&gt; &quot;This clause won't match&quot;
  
&amp;#8230;&gt; {1, x, 3} -&gt;
  
&amp;#8230;&gt; &quot;This clause will match and bind x to 2 in this clause&quot;
  
&amp;#8230;&gt; _ -&gt;
  
&amp;#8230;&gt; &quot;This clause would match any value&quot;
  
&amp;#8230;&gt; end
  
&quot;This clause will match and bind x to 2 in this clause&quot;
  
</code></pre>

<p>기존의 변수에 패턴매치를 사용하고 싶다면 핀 연산자(^)를 사용해야 한다.</p>

<pre><code>  
iex&gt; x = 1
  
1
  
iex&gt; case 10 do
  
&amp;#8230;&gt; ^x -&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; _ -&gt; &quot;Will match&quot;
  
&amp;#8230;&gt; end
  
&quot;Will match&quot;
  
</code></pre>

<p>가드(guards)를 사용해서 추가 조건식을 사용할 수 있다.</p>

<pre><code>  
iex&gt; case {1, 2, 3} do
  
&amp;#8230;&gt; {1, x, 3} when x &gt; 0 -&gt;
  
&amp;#8230;&gt; &quot;Will match&quot;
  
&amp;#8230;&gt; _ -&gt;
  
&amp;#8230;&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; end
  
&quot;Will match&quot;
  
</code></pre>

<p>(가드는 매치를 먼저 수행한후 when 뒤에 추가 조건식을 작성하는 것을 말한다.)</p>

<h2 id="가드-절-guard-clauses-에서의-표현식">가드 절(guard clauses)에서의 표현식</h2>

<p>Erlang VM은 가드에서 사용할 표현식을 다음과 같이 제한하고 있다.</p>

<ul>
<li>비교 연산자(==, !=, ===, !==, &lt;, &gt;, &lt;=, &gt;=)</li>
<li>boolean 연산자(and, or)와 부정 연산자(not, !)</li>
<li>산술 연산자(+, -, *, /)</li>
<li>좌측 값으로 사용되는 &lgt;&gt;와 ++</li>
<li>in 연산자</li>
<li>다음의 타입 검사 함수들

<ul>
<li>is_atom/1</li>
<li>is_binary/1</li>
<li>is_bitstring/1</li>
<li>is_boolean/1</li>
<li>is_float/1</li>
<li>is_function/1</li>
<li>is_function/2</li>
<li>is_integer/1</li>
<li>is_list/1</li>
<li>is_map/1</li>
<li>is_nil/1</li>
<li>is_number/1</li>
<li>is_pid/1</li>
<li>is_port/1</li>
<li>is_reference/1</li>
<li>is_tuple/1</li>
</ul></li>
<li>다음 함수들도 가능하다.

<ul>
<li>abs(number)</li>
<li>bit_size(bitstring)</li>
<li>byte_size(bitstring)</li>
<li>div(integer, integer)</li>
<li>elem(tuple, n)</li>
<li>hd(list)</li>
<li>length(list)</li>
<li>map_size(map)</li>
<li>node()</li>
<li>node(pid | ref | port)</li>
<li>rem(integer, integer)</li>
<li>round(number)</li>
<li>self()</li>
<li>tl(list)</li>
<li>trunc(number)</li>
<li>tuple_size(tuple)</li>
</ul></li>
</ul>

<p>유저가 자신의 가드 함수를 작성한다면 일반적으로 &#8220;is_&#8221;로 시작하는 이름을 사용하도록 한다.</p>

<p>가드 안에서 에러가 발생하면 예외가 발생하지 않고 가드가 실패할 뿐이다.</p>

<pre><code>  
iex&gt; hd(1)
  
** (ArgumentError) argument error
      
:erlang.hd(1)
  
iex&gt; case 1 do
  
&amp;#8230;&gt; x when hd(x) -&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; x -&gt; &quot;Got: #{x}&quot;
  
&amp;#8230;&gt; end
  
&quot;Got 1&quot;
  
</code></pre>

<p>매치하는 절이 없을 경우 에러가 발생한다.(case 절에는 반드시 매치하는 절이 포함되어야 한다.)</p>

<pre><code>  
iex&gt; case :ok do
  
&amp;#8230;&gt; :error -&gt; &quot;Won't match&quot;
  
&amp;#8230;&gt; end
  
** (CaseClauseError) no case clause matching: :ok
  
</code></pre>

<p>익명 함수 역시 가드를 사용해 다음과 같이 작성할 수 있다.</p>

<pre><code>  
iex&gt; f = fn
  
&amp;#8230;&gt; x, y when x &gt; 0 -&gt; x + y
  
&amp;#8230;&gt; x, y -&gt; x * y
  
&amp;#8230;&gt; end
  
#Function&lt;12.71889879/2 in :erl_eval.expr/5&gt;
  
iex&gt; f.(1, 3)
  
4
  
iex&gt; f.(-1, 3)
  
-3
  
</code></pre>

<p>익명함수의 매개변수 개수는 각 절(clause)마다 동일해야하고, 그렇지 않을 경우 에러가 발생한다.</p>

<h2 id="cond">cond</h2>

<p>case의 경우 특정 값 기준으로 정확히 매치되는 절을 수행하는데 유용하지만, 많은 경우 여러 조건 중에 첫 번째로 true인 경우(뒤 이은 조건들 중에 true로 평가되는 경우가 있다 하더라도)만 찾기를 원하는 경우가 있다.</p>

<p>이럴 경우 case 대신 다음과 같이 cond를 사용한다.</p>

<pre><code>  
iex&gt; cond do
  
&amp;#8230;&gt; 2 + 2 == 5 -&gt;
  
&amp;#8230;&gt; &quot;This will not be true&quot;
  
&amp;#8230;&gt; 2 * 2 == 3 -&gt;
  
&amp;#8230;&gt; &quot;Nor this&quot;
  
&amp;#8230;&gt; 1 + 1 == 2 -&gt;
  
&amp;#8230;&gt; &quot;But this will&quot;
  
&amp;#8230;&gt; end
  
&quot;But this will&quot;
  
</code></pre>

<p>cond는 일반적인 언어에 있는 else if 구문과 동일하다.</p>

<p>cond의 조건식 중 true인 경우가 없다면 에러가 발생한다. 이런 상황을 방지하려면 항상 마지막 조건으로 true -&gt;를 사용해야 한다.</p>

<pre><code>  
iex&gt; cond do
  
&amp;#8230;&gt; 2 + 2 == 5 -&gt;
  
&amp;#8230;&gt; &quot;This is never true&quot;
  
&amp;#8230;&gt; 2 * 2 == 3 -&gt;
  
&amp;#8230;&gt; &quot;Nor this&quot;
  
&amp;#8230;&gt; true -&gt;
  
&amp;#8230;&gt; &quot;This is always true (equivalent to else)&quot;
  
&amp;#8230;&gt; end
  
&quot;This is always true (equivalent to else)&quot;
  
</code></pre>

<p>cond의 조건식은 nil이나 false가 아닌 경우 모두 true로 평가함을 주의하자.</p>

<pre><code>  
iex&gt; cond do
  
&amp;#8230;&gt; hd([1,2,3]) -&gt;
  
&amp;#8230;&gt; &quot;1 is considered as true&quot;
  
&amp;#8230;&gt; end
  
&quot;1 is considered as true&quot;
  
</code></pre>

<h2 id="if와-unless">if와 unless</h2>

<p>elixir는 case와 cond이외에 단 하나의 조건을 평가하기 위한 용도로 if/2와 unless/2 매크로를 제공한다.</p>

<pre><code>  
iex&gt; if true do
  
&amp;#8230;&gt; &quot;This works!&quot;
  
&amp;#8230;&gt; end
  
&quot;This works!&quot;
  
iex&gt; unless true do
  
&amp;#8230;&gt; &quot;This will never be seen&quot;
  
&amp;#8230;&gt; end
  
nil
  
</code></pre>

<p>if/2 매크로에 주어진 조건식이 false나 nil을 반환하면, body에 해당하는 do/end 블럭의 코드는 실행되지 않고, nil을 리턴한다. (unless/2는 반대)</p>

<p>if/2와 unless/2는 else 블록을 지원한다.</p>

<pre><code>  
iex&gt; if nil do
  
&amp;#8230;&gt; &quot;This won't be seen&quot;
  
&amp;#8230;&gt; else
  
&amp;#8230;&gt; &quot;This will&quot;
  
&amp;#8230;&gt; end
  
&quot;This will&quot;
  
</code></pre>

<blockquote>
<p>if/2와 unless/2는 매크로임을 주목하자. kernel 모듈에서 if/2 소스를 확인할 수 있다. kernel 모듈에는 +/2 연산자와 is_function/2 함수도 정의되어 있고, 별도의 import과정없이 기본적으로 모든 코드에서 사용할 수 있다.</p>
</blockquote>

<h2 id="do-end-블럭">do/end 블럭</h2>

<p>이 시점에서, case, cond, if, unless는 do/end 블럭을 갖는다는 사실을 알게되었을 것이다. 하지만 do/end 블럭 없이 다음과 같이 작성할 수도 있다.</p>

<pre><code>  
iex&gt; if true, do: 1 + 2
  
3
  
</code></pre>

<p>elixir에서 do/end 블럭은 표현식의 그룹(여러 표현식들)을 do:에 편하게 전달하게 도와준다. 다음은 동등한 구문이다.</p>

<pre><code>  
iex&gt; if true do
  
&amp;#8230;&gt; a = 1 + 2
  
&amp;#8230;&gt; a + 10
  
&amp;#8230;&gt; end
  
13
  
iex&gt; if true, do: (
  
&amp;#8230;&gt; a = 1 + 2
  
&amp;#8230;&gt; a + 10
  
&amp;#8230;&gt; )
  
13
  
</code></pre>

<p>두 번째 구문은 키워드 리스트(do/end 블럭 대신 소괄호를 사용)를 사용한다고 말할 수 있다. 다음 구문을 사용해서 else 절을 실행할 수 있다.</p>

<pre><code>  
iex&gt; if false, do: :this, else: :that
  
:that
  
</code></pre>

<p>do/end 블럭을 사용할 때 다음의 경우를 주의해야 한다.</p>

<pre><code>  
iex&gt; is_number if true do
  
&amp;#8230;&gt; 1 + 2
  
&amp;#8230;&gt; end
  
** (RuntimeError) undefined function: if/1
  
</code></pre>

<p>위의 구문은 다음과 같이 해석된다.</p>

<pre><code>  
iex&gt; is_number(if true) do
  
&amp;#8230;&gt; 1 + 2
  
&amp;#8230;&gt; end
  
** (RuntimeError) undefined function: if/1
  
</code></pre>

<p>즉, 의도한 바가 is_number/1의 매개변수로 if 절의 do/end 블럭의 값이 되기를 기대하지만, 위와 같이 작성해서는 원하는 결과를 얻을 수 없고 대신 다음과 같이 작성해야 한다.</p>

<pre><code>  
iex&gt; is_number(if true do
  
&amp;#8230;&gt; 1 + 2
  
&amp;#8230;&gt; end)
  
true
  
</code></pre>

<p>키워드 리스트를 사용해서 모호한 표현(잘못 해석될 수 있는)의 가능성을 제거할 수 있다.</p>

<p>키워드 리스트는 언어에서 중요한 역할을 수행하고, 많은 함수와 매크로에서 매우 일반적이으로 사용된다. 키워드 리스트에 대해서는 다른 챕터에서 더 자세히 살펴볼 기회가 있을 것이다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/case-cond-and-if.html">Elixir case, cond and if</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-11T00:00:00Z">
            11 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/10/elixir-basic-types/">Elixir Basic types (#2/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>elixir의 기본 데이터 타입을 살펴보자.</p>

<h2 id="기본-산술-표현식과-타입">기본 산술 표현식과 타입</h2>

<pre><code>  
iex&gt; 1 + 2
  
3
  
iex&gt; 5 * 5
  
25
  
iex&gt; 10 / 2
  
5.0
  
</code></pre>

<p>산술 연산자는 각각 +, -, *, / 연산자를 사용하면 된다.</p>

<p>주목할 것은 / 연산자인데, 결과값이 항상 float이다.</p>

<p>몫과 나머지를 각각 구하고자 한다면 다음과 같은 기본 산술 함수를 사용하도록 한다.</p>

<pre><code>  
iex&gt; div(10, 2)
  
5
  
iex&gt; div 10, 2
  
5
  
iex&gt; rem 10, 3
  
1
  
</code></pre>

<p>elixir 함수의 호출은 div(10, 2)와 같이 ()안에 매개변수를 ,로 구분해 입력하는 방법과 ()없이 함수명 뒤에 공백을 둔 후 매개변수리스트를 ,로 구분해 나열하는 방식 모두 사용할 수 있다.</p>

<p>div/2함수와 rem/2함수는 각각 몫과 나머지를 interger로 반환한다.</p>

<p>elixir는 이진수(binary), 8진수(octal), 16진수(hexadecimal)를 각각 다음과 같이 표기할 수 있다.</p>

<pre><code>  
iex&gt; 0b1010
  
10
  
iex&gt; 0o777
  
511
  
iex&gt; 0x1F
  
31
  
</code></pre>

<p>float은 다음과 같이 소숫점을 사용한 표기와 지수(e)를 사용한 표기법 모두 사용할 수 있다.</p>

<pre><code>  
iex&gt; 1.0
  
1.0
  
iex&gt; 1.0e-10
  
1.0e-10
  
</code></pre>

<p>float은 elixir에서 64비트 double 정밀도를 갖는다.</p>

<p>반올림(round/1)과 버림(trunc/1) 함수를 다음과 같이 사용할 수 있다.</p>

<pre><code>  
iex&gt; round 3.58
  
4
  
iex&gt; trunc 3.58
  
3
  
</code></pre>

<h2 id="boolean">boolean</h2>

<p>elixir는 boolean 타입을 위해 true와 false를 사용할 수 있다.</p>

<pre><code>  
iex&gt; true
  
true
  
iex&gt; true == false
  
false
  
</code></pre>

<p>elixir는 값의 타입을 확인하기 위한 다양한 함수를 제공한다.</p>

<p>예를 들어 is_boolean/1 함수는 값이 boolean 타입인지 아닌지 검사한다.</p>

<p>(elixir는 erlang과 동일하게 함수의 표현을 함수명과 arity(매개변수의 개수)로 표현한다. 예를 들면 is_boolean/1과 같은 방식인데 함수명이 is_boolean이고 매개변수의 개수는 1개라는 의미이다.)</p>

<p>is_boolean/1외에도 is_integer/1, is_float/1, is_number/1등을 사용할 수 있다.</p>

<h2 id="atom">atom</h2>

<p>atom은 이름 자체를 자신의 값으로 갖는 상수를 말한다. erlang의 atom과 동일한데 표기법만 다르다.</p>

<p>(구조적인 언어와 객체지향 언어에는 없는 개념이며, 상수에 값을 대입해 초기화 하는 방식이 아니라 상수명 자체가 값이 되는 방식이다.)</p>

<pre><code>  
iex&gt; :hello
  
:hello
  
iex&gt; :hello == :world
  
false
  
</code></pre>

<p>atom은 콜론(:)으로 시작하며 콜론 뒤에는 반드시 영문대소문자가 위치해야 한다. 그 뒤에는 영문대소문자 | 숫자 | ! | ? 의 조합으로 사용할 수 있다.</p>

<pre><code class="language-elixir">  
iex&gt; :Hello
  
:Hello
  
iex&gt; :19
  
** (SyntaxError) iex:10: invalid token: :19
  
iex&gt; :hello19
  
:hello19
  
iex&gt; :#hello
  
** (SyntaxError) iex:11: invalid token: :#hello
  
iex&gt; :hello!
  
:hello!
  
iex&gt; :hello?
  
:hello?
  
</code></pre>

<p>boolean에서 사용하는 true와 false는 사실 atom이다.</p>

<pre><code>  
iex&gt; true == :true
  
true
  
iex&gt; is_atom(false)
  
true
  
iex&gt; is_boolean(:false)
  
true
  
</code></pre>

<h2 id="string">string</h2>

<p>elixir에서 문자열은 &#8220;&#8221;로 감싸며 UTF-8로 인코딩된다.</p>

<pre><code>  
iex&gt; &quot;hellö&quot;
  
&quot;hellö&quot;
  
</code></pre>

<p>문자열 안에 atom이나 변수값을 삽입할 수 있다.</p>

<pre><code>  
iex&gt; world = &quot;hello&quot;
  
&quot;hello&quot;
  
iex&gt; &quot;hellö #{:world}&quot;
  
&quot;hellö world&quot;
  
iex&gt; &quot;hellö #{world}&quot;
  
&quot;hellö hello&quot;
  
</code></pre>

<p>IO모듈의 puts/1함수를 사용해서 문자열을 출력할 수 있다.</p>

<pre><code>  
iex&gt; IO.puts &quot;hellonworld&quot;
  
hello
  
world
  
:ok
  
</code></pre>

<p>IO.puts/1함수는 문자열을 출력한 후 :ok atom을 반환한다.</p>

<p>elixir에서 문자열은 내부적으로 바이너리(바이트의 순차)로 표현된다.</p>

<p>(erlang에서는 문자열은 리스트이며 바이너리는 리스트가 아닌 별개의 타입으로 취급한다.)</p>

<pre><code>  
iex&gt; is_binary(&quot;hellö&quot;)
  
true
  
</code></pre>

<p>문자열의 길이와 byte 수는 다음과 같이 별개로 취급된다.</p>

<pre><code>  
iex&gt; byte_size(&quot;hellö&quot;)
  
6
  
iex&gt; String.length(&quot;hellö&quot;)
  
5
  
</code></pre>

<p><a href="http://elixir-lang.org/docs/stable/elixir/#!String.html">String 모듈</a>은 유니코드 표준에서 정의한 다양한 문자열 처리 함수를 포함하고 있다.</p>

<pre><code>  
iex&gt; String.upcase(&quot;hellö&quot;)
  
&quot;HELLÖ&quot;
  
</code></pre>

<h2 id="anonymous-function-익명-함수">Anonymous function(익명 함수)</h2>

<p>익명 함수는 fn과 end 사이에 정의할 수 있다.</p>

<pre><code>  
iex&gt; add = fn a, b -&gt; a + b end
  
#Function&lt;12.71889879/2 in :erl_eval.expr/5&gt;
  
iex&gt; is_function(add)
  
true
  
iex&gt; is_function(add, 2)
  
true
  
iex&gt; is_function(add, 1)
  
false
  
iex&gt; add.(1, 2)
  
3
  
</code></pre>

<p>elixir의 함수는 일급시민(first class citizens)이다.</p>

<p>일급시민이란 함수형 언어에서 나오는 용어로 일급객체(first class objects)라고도 불리며, 간단히 다음의 조건을 만족하면 성립한다.</p>

<ul>
<li>변수나 데이터 구조안에 담을 수 있다.</li>
<li>매개변수로 전달 할 수 있다.</li>
<li>함수의 반환값으로 사용할 수 있다.</li>
<li>변수의 할당에 사용할 수 있다.</li>
</ul>

<p>위의 예에서 add 변수에 함수를 할당하고, is_function/1의 매개변수로 전달한 예제를 볼 수 있다.</p>

<p>익명함수는 add.(1, 2)와 같은 형식으로 사용할 수 있다.(일반함수와는 다르게 .을 사용해야 하고 ()없이 사용 불가)</p>

<p>익명함수는 closure이며 다음과 같이 사용할 수 있다.</p>

<pre><code>  
iex&gt; add_two = fn a -&gt; add.(a, 2) end
  
#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;
  
iex&gt; add_two.(2)
  
4
  
</code></pre>

<p>위의 예제보다 좀 더 closure를 잘 설명할 수 있는 다음 예제를 살펴보자.</p>

<pre><code>  
iex&gt; makeAdder = fn x -&gt; fn y -&gt; x + y end end
  
#Function&lt;6.90072148/1 in :erl_eval.expr/5&gt;
  
iex&gt; add5 = makeAdder.(5)
  
#Function&lt;6.90072148/1 in :erl_eval.expr/5&gt;
  
iex&gt; add10 = makeAdder.(10)
  
#Function&lt;6.90072148/1 in :erl_eval.expr/5&gt;
  
iex&gt; add5.(2)
  
7
  
iex&gt; add10.(2)
  
12
  
</code></pre>

<p>위의 예제는 다음과 같은 자바스크립트 클로저를 elixir로 변환한 것이다.</p>

<p>(출처는 참고 링크의 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures">클로저</a>)</p>

<pre><code class="language-javascript">  
function makeAdder(x) {
    
return function(y) {
      
return x + y;
    
};
  
}

var add5 = makeAdder(5);
  
var add10 = makeAdder(10);

print(add5(2)); // 7
  
print(add10(2)); // 12
  
</code></pre>

<p>add5함수는 makeAdder함수에 5의 값을 할당해 정의한 closure이며 x의 값이 5로 결정되어 add5함수를 사용할 때마다 x의 값은 5가 되고 반환된 내부 익명함수인 function(y)를 호출하게 되는 것이다.</p>

<p>즉 add5.(2)는 x + y = 5 + 2 = 7, 즉, 7을 반환한다.</p>

<p>개념이 약간 어렵지만 매우 실용적이고 활용도가 높기 때문에 숙지할 필요가 있어서 부연해 봤다.</p>

<p>또 하나 중요한 개념이 있다.</p>

<pre><code>  
iex&gt; x = 42
  
42
  
iex&gt; (fn -&gt; x = 0 end).()
  

  
iex&gt; x
  
42
  
</code></pre>

<p>위의 예제에서 x는 익명함수안에서 사용된 x = 0에 영향을 받지 않는다.</p>

<p>(erlang에서 변수는 대문자로만 표기할 수 있고, 한 번 할당되어 사용된 변수에는 다른 값을 재할당할 수 없다. 하지만 elixir에서는 변수를 소문자로 표기하며 동일한 변수에 여러 번 다른값으로 할당해 사용할 수 있다.)</p>

<h2 id="linked-list">(linked) list</h2>

<p>elixir는 대괄호([])를 사용해 리스트를 정의한다. 리스트의 요소는 어떤 타입도 사용할 수 있다.</p>

<pre><code>  
iex&gt; [1, 2, true, 3]
  
[1, 2, true, 3]
  
iex&gt; length [1, 2, 3]
  
3
  
</code></pre>

<p>두 개의 리스트의 결합이나 빼기는 각각 ++/2와 &#8211;/2 연산자를 사용한다.</p>

<pre><code>  
iex&gt; [1, 2, 3] ++ [4, 5, 6]
  
[1, 2, 3, 4, 5, 6]
  
iex&gt; [1, true, 2, false, 3, true] &amp;#8212; [true, false]
  
[1, 2, 3, true]
  
</code></pre>

<p>리스트는 head와 tail로 구분되는데 head는 리스트의 첫 번째 요소의 값이고, tail은 첫 번째 요소를 제외한 나머지 요소를 갖는 리스트이다.</p>

<p>head와 tail은 각각 hd/1, tl/1 함수를 사용해 구할 수 있다.</p>

<pre><code>  
iex&gt; list = [1,2,3]
  
iex&gt; hd(list)
  
1
  
iex&gt; tl(list)
  
[2, 3]
  
</code></pre>

<p>hd/1와 tl/1 함수의 입력 리스트는 빈 리스트가 되어서는 안된다.</p>

<pre><code>  
iex&gt; hd []
  
** (ArgumentError) argument error
  
</code></pre>

<p>가끔 리스트가 &#8221;로 감싸인 값을 반환하는 경우가 있다.</p>

<pre><code>  
iex&gt; [11, 12, 13]
  
'vfr'
  
iex&gt; [104, 101, 108, 108, 111]
  
'hello'
  
</code></pre>

<p>elixir는 리스트의 요소가 ASCII 코드인 경우 ASCII문자의 리스트로 출력하게 되고 이를 char list라고 부른다. char list는 기존의 erlang code와 인터페이스할 때 일반적으로 사용된다.</p>

<p>elixir에서 &#8221;와 &#8220;&#8221;은 다르며 다른 타입으로 표현된다.</p>

<pre><code>  
iex&gt; 'hello' == &quot;hello&quot;
  
false
  
</code></pre>

<p>&#8221;는 char list이고, &#8220;&#8221;는 문자열이다. 이 내용은 &#8220;Binaries, strings and char list&#8221; 챕터에서 더 자세하게 다룰 것이다.</p>

<h2 id="tuple">tuple</h2>

<p>elixir는 튜플(tuple)을 정의하기 위해 중괄호({})를 사용한다. 튜플은 어떤 값도 포함할 수 있다.</p>

<pre><code>  
iex&gt; {:ok, &quot;hello&quot;}
  
{:ok, &quot;hello&quot;}
  
iex&gt; tuple_size {:ok, &quot;hello&quot;}
  
2
  
</code></pre>

<p>튜플은 요소들을 인접한 메모리에 위치시킨다. 따라서 매우 빠른 속도로 인덱스를 사용해 요소에 접근할 수 있고 사이즈도 빠르게 구할 수 있다.(인덱스는 0부터 시작한다.)</p>

<pre><code>  
iex&gt; tuple = {:ok, &quot;hello&quot;}
  
{:ok, &quot;hello&quot;}
  
iex&gt; elem(tuple, 1)
  
&quot;hello&quot;
  
iex&gt; tuple_size(tuple)
  
2
  
</code></pre>

<p>특정 인덱스에 값을 할당하는 것도 가능하다.(put_elem/3)</p>

<pre><code>  
iex&gt; tuple = {:ok, &quot;hello&quot;}
  
{:ok, &quot;hello&quot;}
  
iex&gt; put_elem(tuple, 1, &quot;world&quot;)
  
{:ok, &quot;world&quot;}
  
iex&gt; tuple
  
{:ok, &quot;hello&quot;}
  
</code></pre>

<p>put_elem/3함수는 새로운 튜플을 반환한다는 것을 주지해야 한다. 본래의 튜플은 수정되지 않으며 elixir의 데이터 타입은 불변의 특성을 갖기 때문이다.(erlang도 마찬가지이며 이러한 특성이 의도치 않은 수정으로 발생할 수 있는 오류를 원천에서 차단하게 된다.)</p>

<p>이러한 특성은 병행성 코드(concurrent code)에서 발생할 수 있는 race condition를 제거하는데 도움을 준다.(동시에 동일한 데이터를 변경하는 시도 자체가 성립하지 않는다.)</p>

<h2 id="list-or-tuple">list or tuple?</h2>

<p>리스트와 튜플의 차이점은 무엇일까?</p>

<p>리스트는 메모리에 링크드 리스트의 형태로 저장되며, 이것이 의미하는 바는 각 요소는 값과 포인터를 갖는 cons cell로 구성되어 있음을 의미한다.</p>

<pre><code>  
iex&gt; list = [1|[2|[3|[]]]]
  
[1, 2, 3]
  
</code></pre>

<p>즉, 리스트의 길이를 구하는 것은 선형 동작이며 리스트의 사이즈를 구하기 위해 전체 요소를 탐색하는 동작이 필요하다.</p>

<pre><code>  
iex&gt; [0] ++ list
  
[0, 1, 2, 3]
  
iex&gt; list ++ [4]
  
[1, 2, 3, 4]
  
</code></pre>

<p>첫 번째 동작은 새로운 cons cell의 포인터에 list를 가리키도록 하면 되기 때문에 빠르다. 하지만 두 번째 동작은 리스트를 재 구성하고 새로운 요소를 뒤에 추가해야 하기 때문에 느리다.</p>

<p>반면에 튜플은, 메모리에 연속된 형태로 저장된다. 이것이 의미하는 바는 인덱스를 사용한 요소 접근이나 사이즈 계산이 빠르다는 것을 말한다. 하지만 튜플에 요소를 추가하거나 수정하는 비용은 메모리에서 해당 튜플을 모두 복사해서 새로 구성하는 동작을 요구하므로 비싸다.</p>

<p>이러한 성능적 특성들은 이들 자료 구조를 어떻게 사용해야 할 지 알려준다. 튜플의 매우 통상적인 사용법 중 하나는 함수에서 추가 정보를 반환하는데 사용하는 것이다. 예를 들어, File.read/1 함수는 파일의 내용을 읽어 튜플로 반환한다:</p>

<pre><code>  
iex&gt; File.read(&quot;path/to/existing/file&quot;)
  
{:ok, &quot;&amp;#8230; contents &amp;#8230;&quot;}
  
iex&gt; File.read(&quot;path/to/unknown/file&quot;)
  
{:error, :enoent}
  
</code></pre>

<p>File.read/1에 주어진 경로가 유효하면, 첫 번째 요소로 :ok atom을, 두 번째 요소로 파일 내용을 갖는 튜플을 반환한다. 경로가 유효하지 않다면 :error atom과 에러 설명을 포함한 튜플을 반환한다.</p>

<p>튜플에 있는 elem/2함수와 동일한 내장(built-in) 함수는 리스트에 없다:</p>

<pre><code>  
iex&gt; tuple = {:ok, &quot;hello&quot;}
  
{:ok, &quot;hello&quot;}
  
iex&gt; elem(tuple, 1)
  
&quot;hello&quot;
  
</code></pre>

<p>자료구조에서 요소의 개수를 &#8220;카운팅&#8221;할 때, elixir는 간단한 규칙을 준수한다: 동작이 상수시간을 갖는다면(값이 이미 계산되어진 경우), 함수의 이름은 size이어야 하고 동작을 요구할 때 실제로 카운팅한다면 length이어야 한다.</p>

<p>예를 들어, 지금까지 4개의 카운팅 함수를 사용했는데(byte_size/1(문자열의 byte 수), tuple_size/1(튜플 사이즈), length/1(리스트 길이), String.length/1(문자열의 문자 개수)), byte_size/1는 비용이 싼 반면 String.length/1는 비용이 비싼 함수임을 의미한다.</p>

<p>elixir는 Port와 Reference, PID(일반적으로 프로세스 통신에 사용하는) 데이터타입도 제공한다. 이 타입들은 프로세스에 대해 알아볼때 함께 살펴보도록 하겠다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/basic-types.html">elixir basic types</a></li>
<li><a href="http://blog.doortts.com/135">함수형 언어로 가는 길 &#8211; 일급객체</a></li>
<li><a href="http://en.wikipedia.org/wiki/First-class_citizen">first class citizen</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures">클로져(closure)</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-10T00:00:00Z">
            10 Jun 2015
        </time>
    </footer>
</article>

	

	<nav class="pagination" role="navigation">
	
	    <a class="newer-posts" href="/tags/tutorial/">&larr; Newer Posts</a>
	
	<span class="page-number">Page 2 of 2</span>
	
</nav>

</main>



    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">Erlang &amp; Go</a> </section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://jeidee.github.iojs/jquery.js"></script>
    <script type="text/javascript" src="https://jeidee.github.iojs/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://jeidee.github.iojs/index.js"></script>

</body>
</html>

