<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" Tutorial &middot;  Erlang &amp; Go" />
  	<meta property="og:site_name" content="Erlang &amp; Go" />
  	<meta property="og:url" content="https://jeidee.github.io/tags/tutorial/" />
    
    
    <meta property="og:type" content="website" />
    

  <title>
     Tutorial &middot;  Erlang &amp; Go
  </title>

    <meta name="description" content="" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://jeidee.github.ioimages/favicon.ico">
	  <link rel="apple-touch-icon" href="https://jeidee.github.ioimages/apple-touch-icon.png" />
    
    <link rel="stylesheet" type="text/css" href="https://jeidee.github.iocss/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
      
          <link href="https://jeidee.github.ioindex.xml" rel="alternate" type="application/rss+xml" title="Erlang &amp; Go" />
      
      
        <link href="https://jeidee.github.io/tags/tutorial/index.xml" rel="alternate" type="application/rss+xml" title="Tutorial &middot; Erlang &amp; Go" />
      
    
    <meta name="generator" content="Hugo 0.31.1" />

    <link rel="canonical" href="https://jeidee.github.io/tags/tutorial/" />

    
<div id="particles-js"></div>
<script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
<script src="https://jeidee.github.iojs/particles.js"></script>   
</head>
<body class="nav-closed">

  


 <div class="site-wrapper">




	<header class="main-header tag-head no-cover">

    <nav class="main-nav overlay clearfix">
      
      
        
          <a class="menu-button icon-feed" href="https://jeidee.github.io/tags/tutorial/index.xml">&nbsp;&nbsp;Subscribe</a>
        
      
    </nav>
    <div class="vertical">

        <div class="main-header-content inner">
            <h1 class="page-title">

              <a class="btn-bootstrap-2" href="#content">Erlang &amp; Go</a>
          </h1>
        </div>
</div>
    <a class="scroll-down icon-arrow-left" href="#content"><span class="hidden">Scroll Down</span></a>
</header>

<main id="content" class="content" role="main">
    

	<div class="extra-pagination inner">
    <nav class="pagination" role="navigation">
	
	<span class="page-number">Page 1 of 2</span>
	
	    <a class="older-posts" href="/tags/tutorial/page/2/">Older Posts &rarr;</a>
	
</nav>

	</div>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/21/elixir-where-to-go-next-2121/">Elixir Where to go next (#21/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>더 배우고 싶은가? 그럼 계속 읽어보자.</p>

<h2 id="build-your-first-elixir-project">Build your first Elixir project</h2>

<p>우리의 첫 프로젝트를 시작하기 위해, elixir는 Mix라는 빌드 툴을 제공한다. 우리는 다음과 같이 간단하게 첫 프로젝트를 만들 수 있다.</p>

<pre><code>  
mix new path/to/new/project
  
</code></pre>

<p>위의 과정을 통해 우리는 슈퍼비전 트리, 설정, 테스트등을 갖는 elixir 응용프로그램을 만들 수 있다. 다음 가이드를 통해 우리는 분산된 노드에 분산된 key-value 저장소를 갖는 응용프로그램을 만드는 방법을 배울 수 있다.</p>

<ul>
<li><a href="http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html">Mix and OTP</a></li>
</ul>

<h2 id="meta-programming">Meta-programming</h2>

<p>elixir는 메타 프로그래밍(코드를 생성하는 코드)을 지원하는 매우 확장성 있는 프로그래밍 언어이다. elixir는 매크로를 통해 메타-프로그래밍을 지원하며 여러 상황에서(특히 DSLs을 작성할 때) 매우 유용하게 사용할 수 있다. 우리는 다음 가이드를 통해 매크로를 사용한 기본 매커니즘을 설명하며 어떻게 매크로를 작성하고 그것들을 DSLs를 만들때 사용하는지 배울 수 있다.</p>

<ul>
<li><a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html">Meta-programming in Elixir</a></li>
</ul>

<h2 id="community-and-othe-resources">Community and othe resources</h2>

<p>이 외에도 elixir와 관련된 책과, 스크린캐스트 및 다른 여러 리소스를 찾을 수 있다. 또한 컨퍼런스, 오픈소스 프로젝트, 커뮤니티에서 생성한 학습 자료 등도 꽤 많다.</p>

<blockquote>
<p>역주 : 안타깝게도 현 시점(2015년 6월)에서 한글 자료는 전무하다.</p>
</blockquote>

<p>만약 elixir와 관련한 어려움이 있다면 irc.freenode.net의 #elixir-lang 채널을 방문하거나 <a href="http://groups.google.com/group/elixir-lang-talk">메일링 리스트</a>에 메세지를 보낼 수 있음을 기억하도록 한다. 그 곳에서 도움을 받을 수도 있고, <a href="http://elixir-lang.org/blog/">공식 블로그</a>나 <a href="http://groups.google.com/group/elixir-lang-core">공식 그룹</a>에서 최신 뉴스와 공지를 받아볼 수도 있다.</p>

<p>최신의 <a href="https://github.com/elixir-lang/elixir">elixir 소스코드</a>를 살펴볼 수 있다는 것과 <a href="http://elixir-lang.org/docs.html">elixir의 공식문서</a>를 살펴볼 수 있다는 것을 잊지말자.</p>

<h2 id="a-byte-of-erlang">A byte of Erlang</h2>

<p>elixir는 Erlang VM에서 동작하기 때문에, 이르거나 뒤늦은 차이는 있겠지만, elixir 개발자는 erlang 라이브러리와 인터페이스할 때가 오게된다. 아래에 Erlang과 관련된 좀 더 전문적인 내용을 포함하는 온라인 리소스의 링크가 있다.</p>

<ul>
<li><p><a href="http://elixir-lang.org/crash-course.html">Erlang 구문 : 집중 훈련</a>에서는 Erlang 구문의 간결한 소개를 제공한다. 각 코드 조각들은 elixir와 동등한 코드로 대응할 수 있다. 이 곳에서 Erlang의 기본 구문을 배울 수 있을 뿐만 아니라, 지금까지 배운 elixir의 내용을 리뷰할 수 있는 기회도 얻을 수 있다.</p></li>

<li><p>Erlang의 공식 웹 사이트에는 동시성(concurrent) 프로그래밍을 위한 Erlang의 기본 구문을 간략히 살펴볼 수 있는 <a href="http://www.erlang.org/course/concurrent_programming.html">튜토리얼</a>을 제공한다.</p></li>

<li><p><a href="http://learnyousomeerlang.com/">Learn You Some Erlang for Great Good!</a>사이트에서 Erlang의 뛰어난 소개를 볼 수 있다. 이 곳에서 Erlang의 설계 원리, 표준 라이브러리, 실제 사용례등의 많은 내용을 접해 볼 수 있다. 위에서 언급한 집중 코스를 한 번 읽어 봤다면, 이 책의 처음 몇 챕터는 쉽게 건너 뛸 수 있을 것이다. <a href="http://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency">동시성을 위한 히치하이커를 위한 안내</a> 챕터에 다다랐을때 비로소, 진짜 재밌는 시작을 할 수 있게 될 것이다.</p></li>
</ul>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/where-to-go-next.html">Elixir Where to go next</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-21T00:00:00Z">
            21 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/19/elixir-sigils-1821/">Elixir Sigils (#18/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>우리는 이미 elixir의 문자열과 문자 리스트를 배웠다. 하지만, 언어에 있어 텍스트의 표현을 위한 구조의 겉면만 다루었을 뿐이다. atom을 예로 들면, 대부분 :atom 형식으로 표현되는 식이다.</p>

<p>elixir의 목표 중 하나는 확장성이다: elixir를 사용하면 개발자가 어떤 도메인에도 꼭 맞도록 언어를 확장할 수 있다. 개발자나, 회사, 또는 커뮤티니들이 그들과 관련된 도메인안에서 언어를 확장할 수 있도록 만들어졌다는 말이다.</p>

<p>이번 챕터에서 우리는, 텍스트 처리에 사용하는 매커니즘 중 하나인 <a href="https://en.wikipedia.org/wiki/Sigil_(computer_programming)">sigil &#8211; $foo에서 $와 같은 기호</a>에 대해서 알아볼 것이다. sigil은 틸드(~) 문자로 시작하는 문자열이며 선택적으로 시작과 끝 구분자를 가질 수 있다.</p>

<h2 id="regular-expressions">Regular expressions</h2>

<p>대표적인 sigil로는 ~r이 있는데, 정규표현식을 만들때 사용한다.</p>

<pre><code>  
\# A regular expression that matches strings which contain &quot;foo&quot; or &quot;bar&quot;:
  
iex&gt; regex = ~r/foo|bar/
  
~r/foo|bar/
  
iex&gt; &quot;foo&quot; =~ regex
  
true
  
iex&gt; &quot;bat&quot; =~ regex
  
false
  
</code></pre>

<p>elixir는 perl과 호환되는 정규 표현식(regexes)을 지원하는데 <a href="http://www.pcre.org/">PCRE</a> 라이브러리로 구현되어 있다. 정규 표현식은 변경자(modifier) 역시 지원한다. 예를 들어, i 변경자는 정규 표현식이 대소문자 구분을 하도록 한다.</p>

<pre><code>  
iex&gt; &quot;HELLO&quot; =~ ~r/hello/
  
false
  
iex&gt; &quot;HELLO&quot; =~ ~r/hello/i
  
true
  
</code></pre>

<p>정규 표현식에서 지원되는 다른 변경자와 기능(operation)을 살펴보고 싶다면 <a href="http://elixir-lang.org/docs/stable/elixir/#!Regex.html">Regex</a> 모듈을 확인해 보면 된다.</p>

<p>지금까지, 모든 예제는 정규 표현식에 / 구분자를 사용했다. 그 외에도 sigil은 8개의 다른 구분자(delimiter)를 지원한다.</p>

<pre><code>  
~r/hello/
  
~r|hello|
  
~r&quot;hello&quot;
  
~r'hello'
  
~r(hello)
  
~r[hello]
  
~r{hello}
  
~r
  
</code></pre>

<p>다른 구분자를 제공하는 이면에는 다른 구분자들이 다른 sigil에 더욱 적합하기 때문이다. 예를 들어, 정규 표현식을 위해 소괄호를 사용한다면 regex에 포함되는 소괄호와 혼동될 것이다. 어쨌든, 다음 섹션에서 살펴보겠지만, 소괄호는 다른 sigil에서 유용하다.</p>

<h2 id="strings-char-lists-and-words-sigils">Strings, char lists and words sigils</h2>

<p>정규 표현식 이외에도, elixir는 세 개의 다른 sigil을 포함한다.</p>

<h3 id="strings">Strings</h3>

<p>~s sigil은 문자열을 만들때 사용되는데, &#8220;&#8221;을 사용하는 것과 같다. ~s sigil은 안에 &#8220;&#8221;(double quotes)와 &#8221;(single quotes)를 포함해야 할 때 유용하게 사용될 수 있다.</p>

<pre><code>  
iex&gt; ~s(this is a string with &quot;double&quot; quotes, not 'single' ones)
  
&quot;this is a string with \&quot;double\&quot; quotes, not 'single' ones&quot;
  
</code></pre>

<h3 id="char-lists">Char lists</h3>

<p>~c sigil은 문자 리스트를 만들 때 사용한다.</p>

<pre><code>  
iex&gt; ~c(this is a char list containing 'single quotes')
  
'this is a char list containing \'single quotes\''
  
</code></pre>

<h3 id="word-lists">Word lists</h3>

<p>~w sigil은 단어 리스트(단어는 문자열이다.)를 만들때 사용한다. ~w sigil안에서, 단어는 공백으로 구분한다.</p>

<pre><code>  
iex&gt; ~w(foo bar bat)
  
[&quot;foo&quot;, &quot;bar&quot;, &quot;bat&quot;]
  
</code></pre>

<p>~w sigil은 c, s, a 변경자(각각 문자 리스트, 문자열, atom을 위한)를 사용할 수 있는데, 각 요소의 결과 데이터타입을 명시할 때 사용한다.</p>

<pre><code>  
iex&gt; ~w(foo bar bat)a
  
[:foo, :bar, :bat]
  
</code></pre>

<h2 id="interpolation-and-escaping-in-sigils">Interpolation and escaping in sigils</h2>

<p>소문자화(lowercase) sigil 이외에도, elixir는 대문자화(uppercase) sigil을 문자열 삽입(interpolation)에서 문자를 escape하기 위해 사용한다. ~s와 ~S는 문자열을 반환하며, 전자는 escape와 interpolation을 지원하며 후자는 지원하지 않는다.</p>

<pre><code>  
iex&gt; ~s(String with escape codes \x26 #{&quot;inter&quot; &quot;polation&quot;})
  
&quot;String with escape codes &amp; interpolation&quot;
  
iex&gt; ~S(String without escape codes and without #{interpolation})
  
&quot;String without escape codes and without \#{interpolation}&quot;
  
</code></pre>

<p>다음 escape 코드는 문자열과 문자리스트에서 사용된다.</p>

<ul>
<li>&#092;&rdquo; &#8211; double quote</li>
<li>&#092;&rsquo; &#8211; single quote</li>
<li>&#092;&#092; &#8211; single backslash</li>
<li>&#092;a &#8211; bell/alert</li>
<li>&#092;b &#8211; backspace</li>
<li>&#092;d &#8211; delete</li>
<li>&#092;e -escape</li>
<li>&#092;f &#8211; form feed</li>
<li>&#092;n &#8211; newline</li>
<li>&#092;r &#8211; carriage return</li>
<li>&#092;s &#8211; space</li>
<li>&#092;t &#8211; tab</li>
<li>&#092;v &#8211; vertical tab</li>
<li>&#092;0 &#8211; null byte</li>
<li>&#092;xDD &#8211; 16진수 표현(예, &#092;x13)</li>
<li>&#092;x{D&#8230;} &#8211; 16진수 숫자를 하나 이상 갖는 16진수 표현(예, &#092;x{abc13})</li>
</ul>

<p>sigil은 heredoc을 지원하며, 구분자로 &ldquo;&rdquo;&ldquo;나 &lsquo;를 사용한다.</p>

<pre><code>  
iex&gt; ~s&quot;&quot;&quot;
  
&amp;#8230;&gt; this is
  
&amp;#8230;&gt; a heredoc string
  
&amp;#8230;&gt; &quot;&quot;&quot;
  
</code></pre>

<p>heredoc sigil의 대표적인 사용예는 문서를 쓸 때 이다. 예를 들어, 문서에서 escape 문자를 쓰고자 할 때는 두번 적어야 한다.</p>

<pre><code>  
@doc &quot;&quot;&quot;
  
Converts double-quotes to single-quotes.

\## Examples

iex&gt; convert(&quot;\\\&quot;foo\\\&quot;&quot;)
      
&quot;'foo'&quot;

&quot;&quot;&quot;
  
def convert(&amp;#8230;)
  
</code></pre>

<p>~S를 사용하면 다음과 같이 작성할 수 있다.</p>

<pre><code>  
@doc ~S&quot;&quot;&quot;
  
Converts double-quotes to single-quotes.

\## Examples

iex&gt; convert(&quot;\&quot;foo\&quot;&quot;)
      
&quot;'foo'&quot;

&quot;&quot;&quot;
  
def convert(&amp;#8230;)
  
</code></pre>

<h2 id="custom-sigils">Custom sigils</h2>

<p>이번 챕터의 시작부분에서 준 힌트처럼, elixir의 sigil은 확장성이 있다. 사실, ~r/foo/i와 같은 sigil은 바이너리와 문자리스트를 매개변수로 사용하는 sigil_r 함수를 호출하는 것과 동등하다.</p>

<pre><code>  
iex&gt; sigil_r(&lt;&gt;, 'i')
  
~r&quot;foo&quot;i
  
</code></pre>

<p>우리는 sigil_r 함수를 통해, ~r sigil에 대한 문서에 접근할 수 있다.</p>

<pre><code>  
iex&gt; h sigil_r
  
&amp;#8230;
  
</code></pre>

<p>우리는 또한 sigil_{identifier} 패턴을 따르는 함수를 작성해서 우리 자신의 sigil을 만들 수도 있다. 예를 들어, 정수를 반환하는(음수를 만들기 위해 선택적으로 n 변경자를 갖는) ~i sigil을 만들어 보자.</p>

<pre><code>  
iex&gt; defmodule MySigils do
  
&amp;#8230;&gt; def sigil\_i(string, []), do: String.to\_integer(string)
  
&amp;#8230;&gt; def sigil\_i(string, [?n]), do: -String.to\_integer(string)
  
&amp;#8230;&gt; end
  
iex&gt; import MySigils
  
iex&gt; ~i(13)
  
13
  
iex&gt; ~i(42)n
  
-42
  
</code></pre>

<p>sigil은 매크로의 도움을 받아 컴파일 타임에 사용될 수 있다. 예를 들어, elixir의 정규 표현식이 소스코드의 컴파일 동안 컴파일된다면, 런타임에 이런 단계가 생략될 수 있다. 이 주제에 관심이 있다면, 매크로에 대해 더 자세히 배우길 권장하며, sigil이 Kernel 모듈(sigil_* 함수가 정의된 곳)에서 어떻게 구현되어 있는지 살펴볼 것을 권장한다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/sigils.html#strings%2C-char-lists-and-words-sigils">Elixir Sigils</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-19T00:00:00Z">
            19 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/19/elixir-try-catch-and-rescue-1921/">Elixir try, catch and rescue (#19/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>elixir는 세 개의 에러 매커니즘을 갖는다: errors, throws, exits. 이번 챕터에서 우리는 이들 각각을 살펴보도록 한다.</p>

<h2 id="errors">Errors</h2>

<p>에러(또는 예외)는 코드에서 예외적인 상황이 발생할 때 사용된다. 숫자를 atom에 더할 때 발생할 수 있는 에러를 살펴보자.</p>

<pre><code>  
iex&gt; :foo + 1
  
** (ArithmeticError) bad argument in arithmetic expression
       
:erlang.+(:foo, 1)
  
</code></pre>

<p>raise/1 함수를 사용하면 아무 때나 런타임에 에러를 발생시킬 수 있다.</p>

<pre><code>  
iex&gt; raise &quot;oops&quot;
  
** (RuntimeError) oops
  
</code></pre>

<p>raise/2함수를 사용하면 에러명과 키워드 리스트를 매개변수로 넘겨 다른 에러를 발생시킬 수 있다.</p>

<pre><code>  
iex&gt; raise ArgumentError, message: &quot;invalid argument foo&quot;
  
** (ArgumentError) invalid argument foo
  
</code></pre>

<p>우리는 우리의 모듈에서 defexception을 사용해 우리만의 에러를 정의할 수 있다. 이 방법을 사용하면 에러이름이 모듈명과 동일해진다. 일반적인 방법은 메세지 필드와 함께 커스텀 예외를 정의하는 것이다.</p>

<pre><code>  
iex&gt; defmodule MyError do
  
iex&gt; defexception message: &quot;default message&quot;
  
iex&gt; end
  
iex&gt; raise MyError
  
** (MyError) default message
  
iex&gt; raise MyError, message: &quot;custom message&quot;
  
** (MyError) custom message
  
</code></pre>

<p>try/rescue 구문을 사용하면 에러를 처리할 수 있다.</p>

<pre><code>  
iex&gt; try do
  
&amp;#8230;&gt; raise &quot;oops&quot;
  
&amp;#8230;&gt; rescue
  
&amp;#8230;&gt; e in RuntimeError -&gt; e
  
&amp;#8230;&gt; end
  
%RuntimeError{message: &quot;oops&quot;}
  
</code></pre>

<p>위의 예제는 런타임 에러를 처리하며 iex 세션에 에러 자체를 출력한다. 실제로는, try/rescue 구문은 드물게 사용된다. 예를 들어, 많은 언어에서 파일이 성공적으로 열리지 않았을 경우 에러를 발생하고 처리하도록 한다. elixir는 그 대신에 파일을 연후 그 결과를 튜플로 반환하는 File.read/1 함수를 제공한다.</p>

<pre><code>  
iex&gt; File.read &quot;hello&quot;
  
{:error, :enoent}
  
iex&gt; File.write &quot;hello&quot;, &quot;world&quot;
  
:ok
  
iex&gt; File.read &quot;hello&quot;
  
{:ok, &quot;world&quot;}
  
</code></pre>

<p>여기에서 try/rescue를 사용하진 않았다. 우리가 파일을 열었을 때 발생하는 여러 상황을 처리하길 원한다면, 단순히 case 구문을 사용하면 된다.</p>

<pre><code>  
iex&gt; case File.read &quot;hello&quot; do
  
&amp;#8230;&gt; {:ok, body} -&gt; IO.puts &quot;Success: #{body}&quot;
  
&amp;#8230;&gt; {:error, reason} -&gt; IO.puts &quot;Error: #{reason}&quot;
  
&amp;#8230;&gt; end
  
</code></pre>

<p>언젠가, 파일을 열때 예외를 발생할지 말지 결정해야할 때가 올 것이다. 이것이 바로 elixir가 File.read/1과 그 외의 많은 함수에서 예외를 발생시키지 않는 이유이다. 대신에, 개발자가 스스로 최선의 처리를 하도록 해 준다.</p>

<p>파일이 존재하길 기대하는 경우라면(없을 경우 에러가 발생해야만 하는 경우) 우리는 단순히 File.read!/1 함수를 사용하면 된다.</p>

<pre><code>  
iex&gt; File.read! &quot;unknown&quot;
  
** (File.Error) could not read file unknown: no such file or directory
      
(elixir) lib/file.ex:305: File.read!/1
  
</code></pre>

<p>표준 라이브러리의 많은 함수가 이러한 패턴(에러를 발생시키는 함수와 튜플을 반환하는 함수를 쌍으로 갖는)을 따른다. 이러한 관습에 따라 foo 함수와 foo! 함수는 각각 예외 없이 튜플을 반환하거나 실패할 경우 에러를 발생시키는 방식으로 구현되어 있다. File 모듈이 이러한 관습의 대표적인 예이다.</p>

<p>elixir에서 우리는 흐름 제어를 위해 try/rescue 구문을 사용하지 않는 것이 좋다. 에러는 글자 그대로 에러로 취급해야 한다. 즉, 에러는 기대하지 않은 상황이며 예외적인 상황에 사용됨을 확실히 하는 것이다. 흐름 제어가 필요하다면, throws를 사용해라.</p>

<h2 id="throws">Throws</h2>

<p>elixir에서 값을 던져서 나중에 받을 수 있다. throw와 catch는 이와 같은 상황에서 사용되는 구문이다.</p>

<p>이런 상황은 적합한 API를 제공하지 않는 라이브러리와 인터페이스하는 경우를 제외하고는 실제로 흔하지 않다. 예를 들어, Enum 모듈이 값을 찾는 API를 제공하지 않는 상황에서 숫자 리스트에서 13의 첫 번째 배수를 찾는다고 가정해 보자.</p>

<pre><code>  
iex&gt; try do
  
&amp;#8230;&gt; Enum.each -50..50, fn(x) -&gt;
  
&amp;#8230;&gt; if rem(x, 13) == 0, do: throw(x)
  
&amp;#8230;&gt; end
  
&amp;#8230;&gt; &quot;Got nothing&quot;
  
&amp;#8230;&gt; catch
  
&amp;#8230;&gt; x -&gt; &quot;Got #{x}&quot;
  
&amp;#8230;&gt; end
  
&quot;Got -39&quot;
  
</code></pre>

<p>Enum은 적합한 API를 제공하기 때문에, 사실 Enum.find/2는 잘 동작할 것이다.</p>

<pre><code>  
iex&gt; Enum.find -50..50, &amp;(rem(&amp;1, 13) == 0)
  
-39
  
</code></pre>

<h2 id="exits">Exits</h2>

<p>모든 elixir 코드는 서로 통신하는 프로세스 안에서 실행된다. 프로세스가 &#8220;자연스럽게 야기된 오류 &#8211; natural causes&#8221;로 죽는다면(예를 들면 처리되지 않은 예외같은), 프로세스는 exit 시그널을 보낸다. 프로세스는 exit 시그널을 명시적으로 보내는 것으로 죽을 수도 있다.</p>

<pre><code>  
iex&gt; spawn_link fn -&gt; exit(1) end
  
#PID&lt;0.56.0&gt;
  
** (EXIT from #PID&lt;0.56.0&gt;) 1
  
</code></pre>

<p>위의 예제에서, 연결된 프로세스는 1의 값을 갖는 exit 시그널을 보내는 것에 의해 죽게된다. elixir는 자동적으로 해당 메세지를 처리하고 터미널에 결과를 출력한다.</p>

<p>exit는 try/catch 구문에서 처리될 수 있다.</p>

<pre><code>  
iex&gt; try do
  
&amp;#8230;&gt; exit &quot;I am exiting&quot;
  
&amp;#8230;&gt; catch
  
&amp;#8230;&gt; :exit, _ -&gt; &quot;not really&quot;
  
&amp;#8230;&gt; end
  
&quot;not really&quot;
  
</code></pre>

<p>try/catch를 사용하는 것도 드물지만 exit를 처리하는 것도 매우 드문 경우이다.</p>

<p>exit 시그널은 Erlang VM에 의해 제공되는 결함 내구성(fault-tolerant) 시스템의 부분으로서 아주 중요하다. 프로세스는 일반적으로 감독되는 프로세스로 부터 exit 시그널을 기다리는 슈퍼비전 트리 안에서 실행된다. exit 시그널을 한 번 받으면, 슈퍼바이저 전략에 의해 kick된 후 곧 바로 재시작 된다.</p>

<p>이것이 바로 elixir에서 try/catch, try/rescue가 일반적이지 않은 이유이다. 에러를 처리(복구)하는 대신, &#8220;빨리 실패-fail fast&#8221;하고, 슈퍼비전 트리에서 에러가 없는 초기 상태로 재빨리 복구되도록 보장하는 것이 더 중요하다.</p>

<h2 id="after">After</h2>

<p>때때로, 에러가 발생할 수 있는 잠재적인 어떤 액션 이후에 리소스를 깨끗이 비워지도록 하는 것이 필요하다. try/after 구문은 우리가 이러한 처리를 할 수 있도록 해 준다. 예를 들어, 우리가 파일을 열고 항상 닫히길 원한다면 try/after 구문을 사용하면 된다.</p>

<pre><code>  
iex&gt; {:ok, file} = File.open &quot;sample&quot;, [:utf8, :write]
  
iex&gt; try do
  
&amp;#8230;&gt; IO.write file, &quot;olá&quot;
  
&amp;#8230;&gt; raise &quot;oops, something went wrong&quot;
  
&amp;#8230;&gt; after
  
&amp;#8230;&gt; File.close(file)
  
&amp;#8230;&gt; end
  
** (RuntimeError) oops, something went wrong
  
</code></pre>

<h2 id="varialbes-scope">Varialbes scope</h2>

<p>try/catch/rescue/after 블럭 안에서 사용된 변수가 문맥 밖으로 누출되지 않게 하는 것은 매우 중요하다. 변수가 처음 바인드 되기 전에 try 블록에서 실패하게 되는 상황때문이다. 달리 말해, 코드가 유효하지 않게 되는 것이다.</p>

<pre><code>  
iex&gt; try do
  
&amp;#8230;&gt; from_try = true
  
&amp;#8230;&gt; after
  
&amp;#8230;&gt; from_after = true
  
&amp;#8230;&gt; end
  
iex&gt; from_try
  
** (RuntimeError) undefined function: from_try/0
  
iex&gt; from_after
  
** (RuntimeError) undefined function: from_after/0
  
</code></pre>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/try-catch-and-rescue.html">Elixir try, catch and rescue</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-19T00:00:00Z">
            19 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/18/elixir-comprehensions-1721/">Elixir Comprehensions (#17/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>elixir에서는, 열거형을 반복문에서 열거하고 요소를 필터링해 다른 리스트로 반환하는 일이 매우 일반적이다. 해석식(Comprehensions)은 그러한 패턴을 쉽게 하도록 도와준다. 해석식은 for와 같은 특별한 형태를 사용해 그러한 작업을 처리할 수 있다.</p>

<p>예를 들면, 정수 리스트에서 각 요소의 제곱을 구해 새로운 리스트를 반환하는 작업은 다음과 같이 구현할 수 있다.</p>

<pre><code>  
iex&gt; for n &lt;- [1, 2, 3, 4], do: n * n
  
[1, 4, 9, 16]
  
</code></pre>

<p>해석식은 세 부분으로 구성된다: 발생기(generator), 필터, 수집자(collectables).</p>

<h2 id="generators-and-filters">Generators and filters</h2>

<p>위의 표현식에서, n &lt;- [1, 2, 3, 4] 부분이 발생기이다. 발생기는 말 그대로 해석을 위한 값을 생성한다. 어떤 열거형도 발생기 표현식(generator expression)의 우측 값으로 사용할 수 있다.</p>

<pre><code>  
iex&gt; for n &lt;- 1..4, do: n * n
  
[1, 4, 9, 16]
  
</code></pre>

<p>발생기 표현식은 좌측 값으로 패턴 매칭을 지원하는데 매치하지 않는 패턴은 무시(ignored) 된다. 범위 값 대신에, 우리는 :good과 :bad atom을 키로 갖는 키워드 리스트를 받아, :good 값만 제곱하기를 원한다고 상상해 보자.</p>

<pre><code>  
iex&gt; values = [good: 1, good: 2, bad: 3, good: 4]
  
iex&gt; for {:good, n} &lt;- values, do: n * n
  
[1, 4, 16]
  
</code></pre>

<p>패턴 매칭 대신에, 필터를 사용할 수 있다. 예를 들어, 우리는 3의 배수를 구해 제곱하는 식을 다음과 같이 구현할 수 있다.</p>

<pre><code>  
iex&gt; multiple\_of\_3? = fn(n) -&gt; rem(n, 3) == 0 end
  
iex&gt; for n &lt;- 0..5, multiple\_of\_3?.(n), do: n * n
  
[0, 9]
  
</code></pre>

<p>필터가 false와 nil을 반환할 경우 해당 요소를 제거하고, 그 외의 요소만 유지한다.</p>

<p>해석식은 일반적으로 Enum과 Stream 모듈의 동등한 함수를 사용하는 것에 비해 훨씬 더 간결한 표현을 제공한다.</p>

<p>게다가, 해석식은 하나 이상의 발생기와 필터를 허용한다. 다음 예제는 디렉토리 리스트를 받아, 해당 디렉토리의 모든 파일을 삭제하는 예이다.</p>

<pre><code>  
for dir &lt;- dirs,
      
file &lt;- File.ls!(dir),
      
path = Path.join(dir, file),
      
File.regular?(path) do
    
File.rm!(path)
  
end
  
</code></pre>

<p>변수가 해석식 안에서 할당되며, 발생기와 필터, 또는 코드 블럭 안에서 사용되고, 해석식 밖에서 사용되지 않는 다는 것을 명심하자.</p>

<h2 id="bitstring-generators">Bitstring generators</h2>

<p>비트문자열 발생기 역시 지원되며, 비트문자열 스트림을 해석할 때 매우 유용하게 사용된다. 아래 예제는 Red,Green,Blue 색상을 갖는 바이너리 픽셀 리스트를 받아, R/G/B 세 개의 요소를 갖는 튜플 리스트로 변환한다.</p>

<pre><code>  
iex&gt; pixels = &lt;&lt;213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15&gt;&gt;
  
iex&gt; for &lt;&lt;r::8, g::8, b::8 &lt;- pixels&gt;&gt;, do: {r, g, b}
  
[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]
  
</code></pre>

<p>비트문자열 발생기는 &#8220;표준-reqular&#8221; 열거형 발생기와 함께 쓰일 수 있고 필터 역시 제공한다.</p>

<h2 id="results-other-than-lists">Results other than lists</h2>

<p>위의 예제에서, 모든 해석식은 결과로 리스트를 반환한다. 또한 해석식의 결과가 :into 옵션을 사용해 다른 데이터 구조에 삽입될 수도 있다.</p>

<p>예를 들어, 비트문자열 발생기는 문자열에서 모든 공백을 쉽게 제거하기 위해 :into 옵션과 함께 사용될 수 있다.</p>

<pre><code>  
iex&gt; for &lt;&lt;c &lt;- &quot; hello world &quot;&gt;&gt;, c != ?s, into: &quot;&quot;, do: &lt;&lt;c&gt;&gt;
  
&quot;helloworld&quot;
  
</code></pre>

<dl>
<dt>셋(Sets), 맵(Maps) 그리고 사전(Dictionaries)는 :into 옵션에 사용할 수 있다. 일반적으로, :into 옵션은 Collectable 프로토콜을 구현한 어떤 데이터 구조도 사용할 수 있다.</dt>
</dl>

<p>:into의 일반적인 용도는 키를 사용하지 않고 맵의 값을 변형하는데 있다.</p>

<pre><code>  
iex&gt; for {key, val} &lt;- %{&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2}, into: %{}, do: {key, val * val}
  
%{&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 4}
  
</code></pre>

<p>스트림을 사용한 예를 보자. IO 모듈은 스트림(Enumeralbe과 Collectable 프로토콜을 구현한)을 제공하기때문에, 해석식을 사용해 입력되는 어떤 문자도 대문자로 변경해 출력하는 에코 터미널을 만들 수 있다.</p>

<pre><code>  
iex&gt; stream = IO.stream(:stdio, :line)
  
iex&gt; for line &lt;- stream, into: stream do
  
&amp;#8230;&gt; String.upcase(line) &lt;&gt; &quot;n&quot;
  
&amp;#8230;&gt; end
  
</code></pre>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/comprehensions.html">Elixir Comprehensions</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-18T00:00:00Z">
            18 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/18/elixir-protocols-1621/">Elixir Protocols (#16/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>프로토콜은 elixir에서 다형성을 구현하는 매커니즘이다. 프로토콜은 어떤 데이터 타입에서도 사용할 수 있다. 예제를 보도록 하자.</p>

<p>elixir에서는 false와 nil만이 false처럼 처리된다. 그 외에는 모든 것이 true로 평가된다. 응용프로그램에 따라, blank로 처리되는 데이터타입을 위해 boolean값을 반환하는 blank? 프로토콜을 명시하는 것이 중요할 수도 있다. 예를 들어, 빈 리스트나 빈 바이너리는 blank로 간주될 수 있다.</p>

<p>우리는 이러한 프로토콜을 다음과 같이 정의할 수 있다.</p>

<pre><code>  
defprotocol Blank do
    
@doc &quot;Returns true if data is considered blank/empty&quot;
    
def blank?(data)
  
end
  
</code></pre>

<p>이 프로토콜은 하나의 매개변수를 갖도록 구현된 blank? 함수가 호출되기를 기대한다. 우리는 다음과 같이 다른 데이터타입에 이 프로토콜을 구현할 수 있다.</p>

<pre><code>  
\# Integers are never blank
  
defimpl Blank, for: Integer do
    
def blank?(_), do: false
  
end

\# Just empty list is blank
  
defimpl Blank, for: List do
    
def blank?([]), do: true
    
def blank?(_), do: false
  
end

\# Just empty map is blank
  
defimpl Blank, for: Map do
    
\# Keep in mind we could not pattern match on %{} because
    
\# it matches on all maps. We can however check if the size
    
\# is zero (and size is a fast operation).
    
def blank?(map), do: map_size(map) == 0
  
end

\# Just the atoms false and nil are blank
  
defimpl Blank, for: Atom do
    
def blank?(false), do: true
    
def blank?(nil), do: true
    
def blank?(_), do: false
  
end
  
</code></pre>

<blockquote>
<p>역주: elixir의 프로토콜은 c#/java의 interface나 또는 objective-c의 protocol보다는 objective-c의 category와 조금 더 가까운 느낌이다. objective-c의 category는 기존 타입을 확장(함수 추가)하는 역할을 한다.</p>
</blockquote>

<p>그리고 우리는 모든 네이티브 데이터 타입에 위와 같이 할 수 있다. 가능한 타입은 다음과 같다.</p>

<ul>
<li>Atom</li>
<li>BitString</li>
<li>Float</li>
<li>Function</li>
<li>Integer</li>
<li>List</li>
<li>Map</li>
<li>PID</li>
<li>Port</li>
<li>Reference</li>
<li>Tuple</li>
</ul>

<p>이제 프로토콜을 정의했고 데이터타입에 구현했으므로, 다음과 같이 사용할 수 있다.</p>

<pre><code>  
iex&gt; Blank.blank?(0)
  
false
  
iex&gt; Blank.blank?([])
  
true
  
iex&gt; Blank.blank?([1, 2, 3])
  
false
  
</code></pre>

<p>구현되지 않은 데이터 타입을 넘기면 에러가 발생한다.</p>

<pre><code>  
iex&gt; Blank.blank?(&quot;hello&quot;)
  
** (Protocol.UndefinedError) protocol Blank not implemented for &quot;hello&quot;
  
</code></pre>

<h2 id="protocols-and-structs">Protocols and structs</h2>

<p>elixir 확장의 힘은 프로토콜과 구조체를 함께 사용할 때 느낄 수 있다.</p>

<p>이전 챕터에서, 우리는 구조체가 맵이긴 하지만, 맵에 구현된 프로토콜을 공유하지는 않는다고 배웠다. 이전 챕터에서 살펴본 User 구조체를 보자.</p>

<pre><code>  
iex&gt; defmodule User do
  
&amp;#8230;&gt; defstruct name: &quot;john&quot;, age: 27
  
&amp;#8230;&gt; end
  
{:module, User,
   
&lt;&lt;70, 79, 82, &amp;#8230;&gt;&gt;, {:\_\_struct\_\_, 0}}
  
</code></pre>

<p>그리고 다음과 같이 검사해 보자.</p>

<pre><code>  
iex&gt; Blank.blank?(%{})
  
true
  
iex&gt; Blank.blank?(%User{})
  
** (Protocol.UndefinedError) protocol Blank not implemented for %User{age: 27, name: &quot;john&quot;}
  
</code></pre>

<p>맵과 프로토콜 구현을 공유하는 대신, 구조체는 User만의 프로토콜 구현을 요구한다.</p>

<pre><code>  
defimpl Blank, for: User do
    
def blank?(_), do: false
  
end
  
</code></pre>

<p>원한다면, 우리 자신의 User 구조체를 위한 Blank 프로토콜을 정의할 수 있다. 그 뿐아니라, 큐와 같은 좀 더 강건한 데이터타입을 만들기 위해 구조체를 사용할 수 있는데, Enumarable에 Blank를 구현하는 것과 같이 이러한 데이터타입에도 프로토콜을 구현할 수 있다.</p>

<p>많은 경우에, 모든 구조체에 프토토콜을 명시적으로 구현하는 것이 지루해질 수 있기 때문에, 개발자는 구조체를 위한 기본 구현을 제공하길 원할지도 모르겠다. 이런 경우에 @fallback_to_any를 사용할 수 있다.</p>

<h2 id="falling-back-to-any">Falling back to Any</h2>

<p>모든 타입에 기본 구현을 제공하는 편리한 방법이 있다. 프로토콜 정의에 @fallback_to_any를 true로 설정하면된다.</p>

<pre><code>  
defprotocol Blank do
    
@fallback\_to\_any true
    
def blank?(data)
  
end
  
</code></pre>

<p>이 프로토콜은 다음과 같이 구현할 수 있다.</p>

<pre><code>  
defimpl Blank, for: Any do
    
def blank?(_), do: false
  
end
  
</code></pre>

<p>이제 모든 데이터 타입(구조체를 포함해서)에서 blank는 false 값을 갖는다.</p>

<h2 id="built-in-protocols">Built-in protocols</h2>

<p>elixir는 약간의 내장 프로토콜을 보유하고 있다. 이전 챕터에서, 우리는 Enumerable 프로토콜을 구현해서 어떤 데이터 구조라도 처리할 수 있는 많은 함수를 제공하는 Enum 모듈을 배웠다.</p>

<pre><code>  
iex&gt; Enum.map [1, 2, 3], fn(x) -&gt; x * 2 end
  
[2,4,6]
  
iex&gt; Enum.reduce 1..3, 0, fn(x, acc) -&gt; x + acc end
  
6
  
</code></pre>

<p>다른 유용한 예로, String.Chars 프로토콜이 있는데, 문자로 구성된 데이터 구조를 문자열로 변경하는데 유용하게 쓰인다. 해당 프로토콜에는 to_string 함수를 노출하고 있다.</p>

<pre><code>  
iex&gt; to_string :hello
  
&quot;hello&quot;
  
</code></pre>

<p>elixir에서 문자열 삽입은 to_string 함수를 호출한다는 것을 명심하자.</p>

<pre><code>  
iex&gt; &quot;age: #{25}&quot;
  
&quot;age: 25&quot;
  
</code></pre>

<p>위의 코드 조각은 숫자(numbers)가 String.Chars 프로토콜을 구현하고 있기 때문에 작동한다. 튜플을 넘겨주면 오류가 발생할 것이다.</p>

<pre><code>  
iex&gt; tuple = {1, 2, 3}
  
{1, 2, 3}
  
iex&gt; &quot;tuple: #{tuple}&quot;
  
** (Protocol.UndefinedError) protocol String.Chars not implemented for {1, 2, 3}
  
</code></pre>

<p>Inspect 프로토콜에 기반한 inspect 함수를 사용할 경우, 좀 더 복잡한 데이터 구조를 출력할 수 있다.</p>

<pre><code>  
iex&gt; &quot;tuple: #{inspect tuple}&quot;
  
&quot;tuple: {1, 2, 3}&quot;
  
</code></pre>

<p>Inspect 프로토콜은 어떤 데이터 구조라도 읽을 수 있는 텍스트 형태의 표현식으로 변경하는데 사용하는 프로토콜이다. 이것은 IEx같은 툴이 결과를 출력하는데 사용된다.</p>

<pre><code>  
iex&gt; {1, 2, 3}
  
{1,2,3}
  
iex&gt; %User{}
  
%User{name: &quot;john&quot;, age: 27}
  
</code></pre>

<p>명심할 것은, 관습에의해, #으로 시작하는 값을 검사할 때는 항상, 유효하지 않은 elixir 구문으로 데이터 구조를 표현한다는 것이다. 이것이 의미하는 바는, 정보의 손실이 있을 수 있기 때문에,Inspect 프로토콜이 역으로 변환되지 않는 다는 것이다.</p>

<pre><code>  
iex&gt; inspect &amp;(&amp;1+2)
  
&quot;#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;&quot;
  
</code></pre>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/protocols.html">Elixir Protocols</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-18T00:00:00Z">
            18 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/17/elixir-io-and-the-file-system-1221/">Elixir IO and the file system (#12/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>이번 챕터에서는 IO, File, Path 모듈과 관련된 입/출력 매커니즘과 파일 시스템 관련 태스크를 소개하도록 한다.</p>

<h2 id="the-io-module">The IO module</h2>

<p>elixir의 IO 모듈은 표준 입출력, 표준 에러, 파일과 다른 IO 장치들을 읽고 쓸 수 있도록 해주는 주요 매커니즘이다. 모듈의 사용법은 꽤 직관적이다.</p>

<pre><code>  
iex&gt; IO.puts &quot;hello world&quot;
  
hello world
  
:ok
  
iex&gt; IO.gets &quot;yes or no? &quot;
  
yes or no? yes
  
&quot;yesn&quot;
  
</code></pre>

<p>기본적으로, IO 모듈의 함수는 표준 입력에서 읽고 표준 출력에 쓴다. 우리는 다른 장치를 사용할 수도 있다. 예를 들어 매개변수로 :stderr를 사용하는 것으로 표준 출력 장치를 사용할 수 있다.</p>

<pre><code>  
iex&gt; IO.puts :stderr, &quot;hello world&quot;
  
hello world
  
:ok
  
</code></pre>

<h2 id="the-file-module">The File module</h2>

<p>File 모듈은 IO 장치로 파일을 처리할 수 있는 여러 함수들을 포함한다. 기본적으로, 파일은 바이너리 모드로 열리고, IO 모듈의 IO.binread/2와 IO.binwrite/2 함수를 사용하도록 요구한다.</p>

<pre><code>  
iex&gt; {:ok, file} = File.open &quot;hello&quot;, [:write]
  
{:ok, #PID&lt;0.47.0&gt;}
  
iex&gt; IO.binwrite file, &quot;world&quot;
  
:ok
  
iex&gt; File.close file
  
:ok
  
iex&gt; File.read &quot;hello&quot;
  
{:ok, &quot;world&quot;}
  
</code></pre>

<p>파일은 :utf8 인코딩을 명시해서 열 수 있고, File 모듈에 UTF-8 인코딩된 바이트를 읽도록 알려줄 수 있다.</p>

<p>파일을 열고/읽고/쓰는 함수들 외에도, File 모듈은 파일 시스템을 처리하는 많은 함수들을 포함한다. 그러한 함수들은 UNIX와 동등한 이름을 갖고 있다. 예를 들어, File.rm/1 함수는 파일을 삭제할 수 있고, File.mkdir/1 함수는 디렉토리를 생성하며, File.mkdir_p/1 함수는 지정된 경로의 부모 디렉토리 체인(/path/to와 같을 경우 path도 없고 to도 없는 경우 path도 만들고 to도 만든다.)을 포함해 디렉토리를 생성한다. File.cp_r/2와 File.rm_rf/2 함수는 디렉토리를 재귀적으로 순환하면서 각각의 파일을 복사하거나 삭제한다.(파일 뿐 아니라 디렉토리를 포함한다.)</p>

<p>File 모듈의 함수는 두 개의 형태를 갖는다. !가 뒤에 붙는 것과 그렇지 않은 것인데, 예를 들어 파일을 읽기 위해 File.read/1함수를 사용할 수 있다면 File.read!/1 함수도 역시 다음과 같이 사용할 수 있다.</p>

<pre><code>  
iex&gt; File.read &quot;hello&quot;
  
{:ok, &quot;world&quot;}
  
iex&gt; File.read! &quot;hello&quot;
  
&quot;world&quot;
  
iex&gt; File.read &quot;unknown&quot;
  
{:error, :enoent}
  
iex&gt; File.read! &quot;unknown&quot;
  
** (File.Error) could not read file unknown: no such file or directory
  
</code></pre>

<p>!(bang) 함수의 경우 파일이 없다면 에러가 발생하지만, 일반적인 버전의 함수는 에러대신 튜플을 반환하며, 패턴매칭을 사용해 상황별 대처를 할 수 있다.</p>

<pre><code>  
case File.read(file) do
    
{:ok, body} -&gt; # do something with the \`body\`
    
{:error, reason} -&gt; # handle the error caused by \`reason\`
  
end
  
</code></pre>

<p>하지만, 파일이 존재할 것이라 기대하고 !함수를 사용하게 되면 의미 있는 에러 메세지가 발생하게 되고, 잘못된 쓰기를 방지하는데 좀 더 유용하게 사용할 수 있다.</p>

<pre><code>  
{:ok, body} = File.read(file)
  
</code></pre>

<p>위의 예제에서 에러가 발생할 경우 {:error, reason}이 반환되므로 패턴 매칭에 실패하게 된다. 패턴 매칭 실패에 에러 상황을 의존하게될 경우 애매해지게 되며 실제 에러가 어떤 것인지 알 수 없게 된다.</p>

<p>명확한 에러가 발생하길 원한다면 File.read!/1 함수를 사용하는 것이 더 좋다.</p>

<h2 id="the-path-module">The Path module</h2>

<p>File 모듈의 함수들은 대부분 경로를 매개변수로 원한다. 가장 일반적으로, 이들 경로는 정규 바이너리이다. Path 모듈은 이러한 경로를 쉽게 처리하는 기능들을 제공한다.</p>

<pre><code>  
iex&gt; Path.join(&quot;foo&quot;, &quot;bar&quot;)
  
&quot;foo/bar&quot;
  
iex&gt; Path.expand(&quot;~/hello&quot;)
  
&quot;/Users/jose/hello&quot;
  
</code></pre>

<p>바이너리를 직접 처리하는 대신에 Path 모듈의 함수들을 사용는 것이 더 좋은데, 이유는 Path 모듈이 제공하는 함수들이 OS에 맞게 처리되기 때문이다. 예를 들어, Path.join/2 함수는 Unix 시스템의 경우 (/)를 사용하며 윈도우 시스템의 경우 (&#092;&#092;)를 사용한다.</p>

<p>elixir는 메인 모듈에서 IO와 파일 시스템을 처리하는 기능을 제공한다. 다음 섹션에서 우리는, IO에 관한 좀 더 전문적인 내용을 살펴볼 것이다. elixir 코드를 작성하기 위해 이러한 전문적인 내용이 필요하진 않으므로, 필요하다면 무시해도 좋다. 그러나 IO 시스템이 VM에서 어떻게 구현되었는지 궁금하다면 훑어볼 것을 권장한다.</p>

<h2 id="processes-and-group-leaders">Processes and group leaders</h2>

<p>File.open/2 함수는 {:ok, pid} 튜플을 반환한다는 것을 알고 있을 것이다.</p>

<pre><code>  
iex&gt; {:ok, file} = File.open &quot;hello&quot;, [:write]
  
{:ok, #PID}
  
</code></pre>

<p>이와 같은 이유는 IO 모듈이 프로세스와 함께 동작하기 때문이다. 우리가 IO.write(pid, binary)를 작성할 때, IO 모듈은 pid로 식별되는 프로세스에 지정된 동작을 수행하라고 메세지를 전송하게 된다. 우리의 프로세스에서 어떤 일이 일어나는지 살펴보자.</p>

<pre><code>  
iex&gt; pid = spawn fn -&gt;
  
&amp;#8230;&gt; receive do: (msg -&gt; IO.inspect msg)
  
&amp;#8230;&gt; end
  
#PID
  
iex&gt; IO.write(pid, &quot;hello&quot;)
  
{:io\_request, #PID, #PID, {:put\_chars, :unicode, &quot;hello&quot;}}
  
** (ErlangError) erlang error: :terminated
  
</code></pre>

<p>IO.write/2함수를 사용한 후에, 우리는 IO 모듈에 의해 보내진 요청(4개의 요소를 갖는 튜플)을 볼 수 있다. 그런 후에, 우리는 IO 모듈이 기대하는 어떤 값을 제공해 주지 않았기 때문에 실패했음을 볼 수 있다.</p>

<p>StringIO 모듈은 문자열 처리를 위해 IO 장치의 메세지 구현을 제공한다.</p>

<pre><code>  
iex&gt; {:ok, pid} = StringIO.open(&quot;hello&quot;)
  
{:ok, #PID}
  
iex&gt; IO.read(pid, 2)
  
&quot;he&quot;
  
</code></pre>

<p>프로세스에 IO 장치를 처리하도록 설계되었기 때문에, Erlang VM은 같은 네트워크 상에서 서로 다른 프로세스간 파일 처리를 가능하도록 허용한다. 모든 IO 장치의 각 프로세스는 특별한 프로세스가 하나 있는데, 그룹리더라고 부른다.</p>

<p>우리가 :stdio에 쓸때, 실제로는 표준 출력 파일 디스크립터를 사용하는 그룹 리더에 메세지를 보내는 것이다.</p>

<pre><code>  
iex&gt; IO.puts :stdio, &quot;hello&quot;
  
hello
  
:ok
  
iex&gt; IO.puts Process.group_leader, &quot;hello&quot;
  
hello
  
:ok
  
</code></pre>

<p>그룹 리더는 프로세스 마다 설정될 수 있고, 다른 상황에서 사용될 수 있다. 예를 들어, 원격 터미널에서 코드가 실행될 때, 원격 노드에 있는 메세지가 요청이 이뤄진 터미널에 재전송되어 출력될 것임을 보장한다.</p>

<h2 id="iodata-and-chardata">iodata and chardata</h2>

<p>위의 모든 예제에서, 우리는 파일을 쓸때 바이너리를 사용했다. &ldquo;Binaries, strings and char lists&rdquo; 챕터에서 우리는, 문자열이 단순히 코드 포인트로 이뤄진 문자 리스트임을 언급했었다.</p>

<p>IO와 File 모듈의 함수들 역시 매개변수로 리스트를 허용한다. 그 뿐 아니라, 리스트, 정수, 바이너리 등의 조합으로 이뤄진 리스트도 허용한다.</p>

<pre><code>  
iex&gt; IO.puts 'hello world'
  
hello world
  
:ok
  
iex&gt; IO.puts ['hello', ?\s, &quot;world&quot;]
  
hello world
  
:ok
  
</code></pre>

<p>하지만, 이것은 약간의 주의를 필요로한다. 리스트는 바이트나 IO 장치의 인코딩에 의존하는 문자들의 모음이다. 파일이 인코딩 없이 열려있다면, 파일은 raw 모드로 열린 것이고 IO 모듈의 bin* 으로 시작하는 함수가 사용되어야 한다. 이러한 함수들은 매개변수로 iodata를 요구한다. iodata는 바이트와 바이너리를 표현하기 위해 정수로 표현되는 리스트이다.</p>

<p>이와 달리, :stdio와 파일이 :utf8 인코딩으로 열린 경우 IO 모듈의 나머지 함수들(bin*이외의)을 사용할 수 있다. 이러한 함수들은 매개변수로 문자들의 리스트나 문자열인 char_data를 요구한다.</p>

<p>비록 이것이 미묘한 차이일지라도, 함수에 리스트를 넘길 때 이러한 차이에 신경을 써야할 필요가 있다. 바이너리는 이미 바이트 기반으로 표현되고 항상 raw로 처리된다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/io-and-the-file-system.html">Elixir IO and the file system</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-17T00:00:00Z">
            17 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/17/elixir-module-attributes-1421/">Elixir Module attributes (#14/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>elixir에서 모듈의 속성은 3개의 목적으로 제공된다.</p>

<ul>
<li>모듈에 주석을 제공한다. 사용자와 VM에 정보를 제공한다.</li>
<li>상수로 동작한다.</li>
<li>컴파일하는 동안 임시 모듈 저장공간으로 사용된다.</li>
</ul>

<p>하나씩 살펴보자.</p>

<h2 id="as-annotations">As annotations</h2>

<p>elixir는 모듈 속성 컨셉을 Erlang에서 가져왔다. 예를 보자.</p>

<pre><code>  
defmodule MyServer do
    
@vsn 2
  
end
  
</code></pre>

<p>위의 예는, 모듈의 버전 속성을 명시적으로 설정한다. @vsn은 Erlang VM이 모듈이 수정되었는지 여부를 검사해서 코드를 리로딩할 지 결정하는 매커니즘으로 사용한다. @vsn이 명시되지 않을 경우 모듈 함수의 버전으로 MD5 체크섬이 설정된다.</p>

<p>elixir는 소수의 예약된 속성을 갖는다. 그들 중 흔히 사용되는 것들 몇 개만 살펴보도록 하자.</p>

<ul>
<li>@moduledoc &#8211; 현재 모듈의 문서를 제공한다.</li>
<li>@doc &#8211; 함수나 매크로의 문서를 제공한다.</li>
<li>@behaviour &#8211; OTP 또는 유저가 정의한 behaviour를 명시한다.</li>
<li>@before_compile &#8211; 모듈이 컴파일될 때 불려지는 동작을 명시한다. 이것은 컴파일 타임에 특정 함수를 모듈에 주입(inject)할 수 있게 해 준다.</li>
</ul>

<p>@moduledoc과 @doc은 흔히 사용하는 속성인데, 가능하면 많이 사용하도록 해야 한다. elixir는 문서를 일등급(first-class)으로 취급하고 문서에 접근할 수 있는 많은 함수를 제공한다.</p>

<p>이전 챕터에서 정의한 Math 모듈로 되돌아가 보자. math.ex 파일에 다음과 같이 문서를 추가해 보자.</p>

<pre><code>  
defmodule Math do
    
@moduledoc &quot;&quot;&quot;
    
Provides math-related functions.

\## Examples

iex&gt; Math.sum(1, 2)
        
3

&quot;&quot;&quot;

@doc &quot;&quot;&quot;
    
Calculates the sum of two numbers.
    
&quot;&quot;&quot;
    
def sum(a, b), do: a + b
  
end
  
</code></pre>

<p>elixir는 가독성 있는 문서를 작성하는데 <a href="http://zetawiki.com/wiki/HEREDOC">heredoc</a>(문자열을 코드 중간에 그대로 포함)과 함께 마크다운 문법을 사용하도록 권고한다. heredoc은 여러 줄의 문자열로 이뤄져 있고 시작과 끝은 &#8220;&#8221;&#8221;(triple quotes)으로 묶으며 입력한 그대로의 형태를 유지한다. 우리는 컴파일된 모듈의 문서를 iex를 통해 볼 수 있다.</p>

<pre><code>  
$ elixirc math.ex
  
$ iex

iex&gt; h Math # Access the docs for the module Math
  
&amp;#8230;
  
iex&gt; h Math.sum # Access the docs for the sum function
  
&amp;#8230;
  
</code></pre>

<p>우리는 <a href="https://github.com/elixir-lang/ex_doc">ExDoc</a>이라고 불리는 도구를 사용해 HTML 페이지 형태의 문서를 만들 수도 있다.</p>

<p>지원되는 속성의 전체 리스트는 <a href="http://elixir-lang.org/docs/stable/elixir/#!Module.html">Module</a> 문서에서 볼 수 있다. elixir는 또한 <a href="http://elixir-lang.org/docs/stable/elixir/#!Kernel.Typespec.html">typespecs</a>를 정의해서 속성을 만들수도 있다.</p>

<ul>
<li>@spec &#8211; 함수를 위한 명세를 제공</li>
<li>@callback &#8211; behaviour 콜백을 위한 명세를 제공</li>
<li>@type &#8211; @spec에서 사용되는 타입을 정의</li>
<li>@typep &#8211; @spec에서 사용되는 private 타입을 정의</li>
<li>@opaque &#8211; @spec에서 사용하는 opaque 타입(변수의 조작을 함수를 통해서만 가능하도록 하는 타입)을 정의</li>
</ul>

<p>이 섹션에서는 내장된(built-in) 속성만 언급했다. 하지만, 속성은 개발자에 의해 사용될 뿐만 아니라 커스텀 behaviour를 지원하는 라이브러리에 의해서 확장될 수도 있다.</p>

<h2 id="as-constants">As constants</h2>

<p>elixir 개발자는 모듈 속성을 상수로 사용하기도 한다.</p>

<pre><code>  
defmodule MyServer do
    
@initial_state %{host: &quot;147.0.0.1&quot;, port: 3456}
    
IO.inspect @initial_state
  
end
  
</code></pre>

<blockquote>
<p>Erlang과 다르게, 유저가 정의한 속성은 기본적으로 모듈에 저장되지 않는다. 값은 오직 컴파일시에만 존재한다. 개발자가 Erlang과 유사하게 속성을 설정하고 싶다면 Module.register_attribute/3 함수를 사용해야 한다.</p>
</blockquote>

<p>정의되지 않은 속성에 접근하게 되면 경고를 출력할 것이다.</p>

<pre><code>  
defmodule MyServer do
    
@unknown
  
end
  
warning: undefined module attribute @unknown, please remove access to @unknown or explicitly set it to nil before access
  
</code></pre>

<p>속성은 함수 안에서 다음과 같이 사용될 수 있다.</p>

<pre><code>  
defmodule MyServer do
    
@my_data 14
    
def first\_data, do: @my\_data
    
@my_data 13
    
def second\_data, do: @my\_data
  
end

MyServer.first_data #=&gt; 14
  
MyServer.second_data #=&gt; 13
  
</code></pre>

<p>함수 안에서 속성을 읽는 순간 현재 값의 스냅샷을 가져온다는 것을 명심하자. 다른 말로, 값은 컴파일시에 읽혀질뿐, 런타임에 읽혀지는 것이 아니다. 우리가 살펴본대로, 속성은 모듈이 컴파일되는 동안 저장공간으로 유용하게 사용될 수 있다.</p>

<h2 id="as-temporary-storage">As temporary storage</h2>

<p>elixir로 구성한 프로젝트 중에 <a href="https://github.com/elixir-lang/plug">Plug</a> 프로젝트가 있는데, elixir에서 웹 라이브러리와 프레임워크를 만드는데 기초가 되는 프로젝트이다.</p>

<p>Plug 라이브러리는 개발자가 웹서버에서 실행될 수 있는 그들 자신의 plug를 정의할 수 있게 해 준다.</p>

<pre><code>  
defmodule MyPlug do
    
use Plug.Builder

plug :set_header
    
plug :send_ok

def set\_header(conn, \_opts) do
      
put\_resp\_header(conn, &quot;x-header&quot;, &quot;set&quot;)
    
end

def send\_ok(conn, \_opts) do
      
send(conn, 200, &quot;ok&quot;)
    
end
  
end

IO.puts &quot;Running MyPlug with Cowboy on http://localhost:4000&quot;
  
Plug.Adapters.Cowboy.http MyPlug, []
  
</code></pre>

<p>위의 예제에서, 우리는 웹 요청이 있을 때 호출되는 함수 연결을 위해 plug/1 매크로를 사용했다. 내부적으로, 매번 plug/1을 호출할 때마다, Plug 라이브러리는 @plugs 속성에 있는 주어진 매개변수를 저장한다. 모듈이 컴파일되기 직전에, Plug는 http 요청을 처리하는 call/2 메서드를 정의하는 콜백을 실행한다. 이 메서드는 순서대로 @plugs 안에서 모든 plug를 실행할 것이다.</p>

<p>아래 코드를 이해하기 위해, 우리는 매크로가 필요한데, 이 매크로는 메타 프로그래밍 가이드에서 다시 한 번 살펴볼 것이다. 어쨌든, 여기에서 집중할 것은, 어떻게 모듈 속성을 저장공간으로 사용하는 것이 개발자로 하여금 DSL(?)을 생성하도록 허용하는가이다.</p>

<p>모듈 속성을 주석과 저장소로 사용하는 ExUnit 프레임워크의 예제를 보도록 하자.</p>

<pre><code>  
defmodule MyTest do
    
use ExUnit.Case

@tag :external
    
test &quot;contacts external service&quot; do
      
\# &amp;#8230;
    
end
  
end
  
</code></pre>

<p>ExUnit의 태그는 주석 테스트에 사용된다. 태그를 사용해 테스트를 필터링할 수 있다. 예를 들어, 느리거나 다른 서비스에 의존성이 있는 외부 테스트를 실행하지 않을 수 있다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/module-attributes.html">Elixir Module attributes</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-17T00:00:00Z">
            17 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/17/elixir-structs-1521/">Elixir Structs (#15/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>이전 챕터에서 우리는 맵에 대해 배웠다.</p>

<pre><code>  
iex&gt; map = %{a: 1, b: 2}
  
%{a: 1, b: 2}
  
iex&gt; map[:a]
  
1
  
iex&gt; %{map | a: 3}
  
%{a: 3, b: 2}
  
</code></pre>

<p>구조체는 컴파일 타임 검사와 기본값을 제공하는 맵의 확장이다.</p>

<h2 id="defining-structs">Defining structs</h2>

<p>구조체를 정의하기 위해, defstruct를 사용한다.</p>

<pre><code>  
iex&gt; defmodule User do
  
&amp;#8230;&gt; defstruct name: &quot;John&quot;, age: 27
  
&amp;#8230;&gt; end
  
</code></pre>

<p>defstruct에 사용된 키워드 리스트는, 어떤 필드가 어떤 기본값을 갖는지 정의한다.</p>

<p>구조체는 구조체가 정의된 모듈의 이름을 통해서 가져온다. 위의 예에는 User 모듈에 구조체를 정의했다.</p>

<p>우리가 만든 User 구조체는 맵과 유사한 구문으로 사용할 수 있다.</p>

<pre><code>  
iex&gt; %User{}
  
%User{age: 27, name: &quot;John&quot;}
  
iex&gt; %User{name: &quot;Meg&quot;}
  
%User{age: 27, name: &quot;Meg&quot;}
  
</code></pre>

<p>구조체는 컴파일타임에 defstruct를 통해 정의된 필드만 사용할 수 있음을 보장한다.</p>

<pre><code>  
iex&gt; %User{oops: :field}
  
** (CompileError) iex:3: unknown key :oops for struct User
  
</code></pre>

<h2 id="accessing-and-updating-structs">Accessing and updating structs</h2>

<p>우리가 맵을 배울때, 맵의 필드에 어떻게 접근하고 값을 수정할 수 있는지 보여주었다. 같은 테크닉(같은 구문)으로 구조체를 사용할 수 있다.</p>

<pre><code>  
iex&gt; john = %User{}
  
%User{age: 27, name: &quot;John&quot;}
  
iex&gt; john.name
  
&quot;John&quot;
  
iex&gt; meg = %{john | name: &quot;Meg&quot;}
  
%User{age: 27, name: &quot;Meg&quot;}
  
iex&gt; %{meg | oops: :field}
  
** (ArgumentError) argument error
  
</code></pre>

<p>수정 구문(|)을 사용할 때, VM은 메모리에 저장된 공유 구조체 하부가 맵이기 때문에, 어떤 새로운 키도 추가되지 않을 것임을 알고 있다. 위의 예에서, john과 meg은 메모리에서 동일한 키를 공유하고 있다.</p>

<p>구조체는 패턴 매칭에도 사용될 수 있다.</p>

<pre><code>  
iex&gt; %User{name: name} = john
  
%User{age: 27, name: &quot;John&quot;}
  
iex&gt; name
  
&quot;John&quot;
  
iex&gt; %User{} = %{}
  
** (MatchError) no match of right hand side value: %{}
  
</code></pre>

<h2 id="structs-are-just-bare-maps-underneath-구조체는-사실-순수한-맵이다">Structs are just bare maps underneath(구조체는 사실 순수한 맵이다.)</h2>

<p>위의 예에서, 패턴매칭이 동작하는 이유는 하부 구조가 단순히 맵이기 때문이다. 맵 처럼, 구조체도 <strong>struct</strong>라는 &#8220;특별한&#8221; 필드를 저장하는데, 구조체의 이름을 보유하고 있다.</p>

<pre><code>  
iex&gt; is_map(john)
  
true
  
iex&gt; john.\_\_struct\_\_
  
User
  
</code></pre>

<p>우리는 맵을 위해 구현된 어떤 프로토콜도 구조체에서는 사용할 수 없기 때문에, 순수한 맵처럼 취급해야 함을 명심하자. 예를 들어, 구조체 내부를 접근해서 열거할 수 없다.</p>

<pre><code>  
iex&gt; john = %User{}
  
%User{age: 27, name: &quot;John&quot;}
  
iex&gt; john[:name]
  
** (Protocol.UndefinedError) protocol Access not implemented for %User{age: 27, name: &quot;John&quot;}
  
iex&gt; Enum.each john, fn({field, value}) -&gt; IO.puts(value) end
  
** (Protocol.UndefinedError) protocol Enumerable not implemented for %User{age: 27, name: &quot;John&quot;}
  
</code></pre>

<p>구조체는 사전(dictionary) 역시 아니므로 Dict 모듈의 함수에서 사용할 수 없다.</p>

<pre><code>  
iex&gt; Dict.get(%User{}, :name)
  
** (UndefinedFunctionError) undefined function: User.fetch/2
  
</code></pre>

<p>하지만, 구조체는 맵이기 때문에, Map 모듈의 함수에서는 사용할 수 있다.</p>

<pre><code>  
iex&gt; kurt = Map.put(%User{}, :name, &quot;Kurt&quot;)
  
%User{age: 27, name: &quot;Kurt&quot;}
  
iex&gt; Map.merge(kurt, %User{name: &quot;Takashi&quot;})
  
%User{age: 27, name: &quot;Takashi&quot;}
  
iex&gt; Map.keys(john)
  
[:\_\_struct\_\_, :age, :name]
  
</code></pre>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/structs.html">Elixir Structs</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-17T00:00:00Z">
            17 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/17/elixir-alias-require-and-import-1321/">Elixir alias, require and import (#13/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>소프트웨어 재사용을 쉽게 하기 위해, elixir는 3개의 지시자(directives)를 제공한다. 이들 지시자는 정적 유효범위(<a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope">lexical scope</a>)를 갖는다.(일반적인 언어에서 변수의 선언과 유효범위는 대부분 lexical scope를 갖는다.)</p>

<h2 id="alias">alias</h2>

<p>alias는 모듈이름의 별칭을 허용한다. 우리가 만든 Math 모듈에 특별한 List가 있다고 가정해 보자.</p>

<pre><code>  
defmodule Math do
    
alias Math.List, as: List
  
end
  
</code></pre>

<p>이제 Math 모듈 안에서 List는 자동적으로 Math.List로 확장된다. 만약 본래의 List 모듈에 접근하고자 한다면, Elixir. 접두어(prefix)를 사용해야 한다.</p>

<pre><code>  
List.flatten #=&gt; uses Math.List.flatten
  
Elixir.List.flatten #=&gt; uses List.flatten
  
Elixir.Math.List.flatten #=&gt; uses Math.List.flatten
  
</code></pre>

<blockquote>
<p>elxir에 정의된 모든 모듈은 Elixir 네임스페이스에 포함되어 있다. 하지만 편리성을 위해 Elixir. 접두어는 생략할 수 있다.</p>
</blockquote>

<p>별칭은 자주 사용된다. 사실 :as 옵션을 제외하고 사용할 수 있는데, 다음 두 용법은 동일하다.</p>

<pre><code>  
alias Math.List

alias Math.List, as: List
  
</code></pre>

<p>alias가 정적 유효범위(lexically scoped)를 갖는다는 것을 명심하자. 함수내에서 사용되었다면 해당 함수 안에서만 유효하다.</p>

<pre><code>  
defmodule Math do
    
def plus(a, b) do
      
alias Math.List
      
\# &amp;#8230;
    
end

def minus(a, b) do
      
\# &amp;#8230;
    
end
  
end
  
</code></pre>

<p>위의 예제에서, alias가 plus/2 함수에서 사용되었기 때문에 plus/2 함수 안에서만 유효하게 사용된다. minus/2 함수에서는 적용되지 않는다.</p>

<h2 id="require">require</h2>

<p>elixir는 메타-프로그래밍(코드를 생성하는 코드)을 위한 매커니즘을 위해 매크로가 제공된다.</p>

<p>매크로는 컴파일 타임에 확장되어 실행되는 코드 조각이다. 이것이 의미하는 바는, 매크로가 사용되는 모듈과 구현코드가 컴파일 될 때 해당 매크로가 유효해야 함을 뜻한다. require 지시자를 통해 이 조건을 완수할 수 있다.</p>

<pre><code>  
iex&gt; Integer.is_odd(3)
  
** (CompileError) iex:1: you must require Integer before invoking the macro Integer.is_odd/1
  
iex&gt; require Integer
  
nil
  
iex&gt; Integer.is_odd(3)
  
true
  
</code></pre>

<p>elixir에서, Integer.is_odd/1 함수는 가드를 사용하는 매크로로 정의되어 있다. 즉, Integer.is_odd/1 매크로를 호출하기 위해 우리는 Integer 모듈을 require해야 한다.</p>

<p>일반적으로 모듈은 모듈에서 매크로를 사용하기를 원하지 않는 다면, 사용하기 전에 require할 필요는 없다. 매크로를 호출할 때 로드되지 않았다면 에러가 발생할 것이다. require 지시자 역시 alias와 마찬가지로 정적 유효범위를 갖는다. 다음 챕터에서 매크로에 대해 좀 더 자세히 살펴볼 것이다.</p>

<h2 id="import">import</h2>

<p>우리는 FQN(fully-qualified name)을 사용하지 않고 다른 모듈에서 함수와 매크로를 쉽게 접근하길 원할 때, import 지시자를 사용한다. 예를 들어, List모듈의 duplicate/2 함수를 사용할 때 단순히 duplicate/2만 사용하고자 한다면 다음과 같이 사용할 수 있다.</p>

<pre><code>  
iex&gt; import List, only: [duplicate: 2]
  
nil
  
iex&gt; duplicate :ok, 3
  
[:ok, :ok, :ok]
  
</code></pre>

<p>이 경우에, 우리는 duplicate/2 함수만 import했다. :only는 옵션이며, 주어진 모듈에서 모든 함수가 import되는 것을 방지하고자 할 때 사용할 수 있다. 반대로 :except 옵션은 특정 함수의 리스트를 제외한 나머지를 import하고 싶을 때 사용한다.</p>

<p>import는 :macros와 :functions 옵션을 :only와 함께 사용할 수 있는데, 모든 매크로나 모든 함수를 지정해서 import할 때 사용한다.</p>

<pre><code>  
import Integer, only: :macros

import Integer, only: :functions
  
</code></pre>

<p>import 또한 정적 유효범위를 갖는다.</p>

<pre><code>  
defmodule Math do
    
def some_function do
      
import List, only: [duplicate: 2]
      
duplicate(:ok, 10)
    
end
  
end
  
</code></pre>

<p>위의 예제에서 import된 List.duplicate/2 함수는 특정 함수인 some_function/0에서만 유효하다.</p>

<p>import 지시자를 사용하면 자동적으로 모듈을 require한 것이 된다.</p>

<h2 id="aliases">Aliases</h2>

<p>이쯤에서 궁금할 것이다. &#8220;Elixir&#8221; 별칭이 정확히 무엇이고 어떻게 표현되는 것일까?</p>

<p>elixir의 별칭은 컴파일 타임에 atom으로 변환되는 대문자로 시작하는 식별자(String, Keyword 같은)이다. 예를 들어, String 별칭은 &#8220;Elixir.String&#8221; atom으로 변환된다.</p>

<pre><code>  
iex&gt; is_atom(String)
  
true
  
iex&gt; to_string(String)
  
&quot;Elixir.String&quot;
  
iex&gt; :&quot;Elixir.String&quot; == String
  
true
  
</code></pre>

<p>alias/2 지시자를 사용해서, 우리는 별칭이 어떻게 번역되야 할지 지정할 수 있다.</p>

<p>Erlang 모듈의 경우 다음과 같이 atom으로 표현된다.</p>

<pre><code>  
iex&gt; :lists.flatten([1, [2], 3])
  
[1, 2, 3]
  
</code></pre>

<p>이것은 우리가 모듈에서 주어진 함수를 동적으로 호출할 수 있게 해 주는 매커니즘이다.</p>

<pre><code>  
iex&gt; mod = :lists
  
:lists
  
iex&gt; mod.flatten([1, [2], 3])
  
[1, 2, 3]
  
</code></pre>

<p>우리는 단순히 :lists atom을 사용해서 flatten 함수를 호출할 수 있다.</p>

<h2 id="nesting">Nesting</h2>

<p>이제 중첩에 대해 알아보자. 다음과 같은 예제가 있다.</p>

<pre><code>  
defmodule Foo do
    
defmodule Bar do
    
end
  
end
  
</code></pre>

<p>위 예제는 두개의 모듈(Foo, Foo.Bar)을 정의하고 있다. Bar 모듈은 Foo 모듈안에서 정적 유효범위를 갖는다.</p>

<p>나중에 Bar 모듈이 Foo 모듈 외부로 이동할 경우, Foo.Bar와 같이 전체 이름이 필요하거나 alias를 사용해서 위와 같이 설정할 필요가 있다. Bar 모듈의 정의 역시 변경된다. 아래 예제는 위의 예제와 동일하다.</p>

<pre><code>  
defmodule Foo.Bar do
  
end

defmodule Foo do
    
alias Foo.Bar, as: Bar
  
end
  
</code></pre>

<p>위의 코드는 정확히 다음 코드와 동일하다.</p>

<pre><code>  
defmodule Elixir.Foo do
    
defmodule Elixir.Foo.Bar do
    
end
    
alias Elixir.Foo.Bar, as: Bar
  
end
  
</code></pre>

<blockquote>
<p>elixir에서는 어떤 방식으로든 모든 모듈이름이 atom으로 번역되기 때문에, Foo.Bar 모듈을 정의하기 전에 Foo 모듈을 정의할 필요는 없다. 어떤 모듈도 정의하지 않고 체인내에서 제멋대로 모듈을 중첩시킬 수 있다.(예를 들면, Foo 모듈과 Foo.Bar 모듈을 먼저 정의하지 않고 Foo.Bar.Baz 모듈을 정의하는 등의)</p>
</blockquote>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/alias-require-and-import.html">Elixir alias, require and import</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-17T00:00:00Z">
            17 Jun 2015
        </time>
    </footer>
</article>

	
	   
<article class="post posts">
    <header class="post-header">
        <h2 class="post-title"><a href="/2015/06/16/elixir-processes-1121/">Elixir Processes (#11/21)</a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            

<blockquote>
<p>본 문서는 elixir-lang.org의 <a href="http://elixir-lang.org/getting-started/introduction.html">Getting Started</a>문서의 한글 번역본입니다.</p>

<p>자세한 내용은 원문을 참조해 주세요.</p>
</blockquote>

<p>elixir에서, 모든 코드는 프로세스 안에서 실행된다. 프로세스는 서로 분리되어 있고, 서로 동시에(concurrent) 실행되며, 메세지를 건네는 것을 통해 통신한다.</p>

<p>프로세스는 elixir의 동시성 뿐만 아니라, 분산 된 구조와 결함 내구성(fault-tolerant) 역시 제공한다.</p>

<p>elixir의 프로세스를 OS(운영체제)의 프로세스와 혼동하면 안된다. elixir의 프로세스는 메모리와 CPU에 있어 극단적으로 경량화되어 있다(다른 프로그래밍 언어의 쓰레드와 다르게). 이러한 이유로, 수백 수천의 프로세스가 동시에 수행되는 것이 일반적이다.</p>

<p>이번 챕터에서 우리는, 새로운 프로세스를 생성(spawning)하는 기본 구조뿐만 아니라 프로세스간에 메세지를 주고 받는 것도 배울 것이다.</p>

<h2 id="spawn">spawn</h2>

<p>프로세스를 생성하는 기본 매커니즘은 자동으로 포함된(auto-imported) spawn/1 함수를 사용하는 것이다.</p>

<pre><code>  
iex&gt; spawn fn -&gt; 1 + 2 end
  
#PID&lt;0.43.0&gt;
  
</code></pre>

<p>spawn/1 함수는 다른 프로세스에서 실행될 함수를 취한다.</p>

<p>spawn/1 함수가 PID(프로세스 식별자)를 반환함을 주목하자. PID가 반환된 시점에서 프로세스는, 죽어 있는 것과 같다. 생성된 프로세스는 주어진 함수를 실행하고 완료되면 곧 바로 종료된다.</p>

<pre><code>  
iex&gt; pid = spawn fn -&gt; 1 + 2 end
  
#PID&lt;0.44.0&gt;
  
iex&gt; Process.alive?(pid)
  
false
  
</code></pre>

<p>self/0 함수를 통해 현재 프로세스(쉘의&#8230;)의 PID를 구할 수 있다.</p>

<pre><code>  
iex&gt; self()
  
#PID&lt;0.41.0&gt;
  
iex&gt; Process.alive?(self())
  
true
  
</code></pre>

<p>프로세스는 메세지를 주고 받을 수 있을 때 더 흥미롭다.</p>

<h2 id="send-and-receive">send and receive</h2>

<p>우리는 프로세스에게 send/2 함수를 통해 메세지를 보내고 receive/1 함수를 통해 메세지를 수신할 수 있다.</p>

<pre><code>  
iex&gt; send self(), {:hello, &quot;world&quot;}
  
{:hello, &quot;world&quot;}
  
iex&gt; receive do
  
&amp;#8230;&gt; {:hello, msg} -&gt; msg
  
&amp;#8230;&gt; {:world, msg} -&gt; &quot;won't match&quot;
  
&amp;#8230;&gt; end
  
&quot;world&quot;
  
</code></pre>

<p>메세지가 프로세스에 보내지면, 그 메세지는 프로세스의 메일박스에 전달된다. receive/1 함수는 프로세스의 메일박스에서 주어진 패턴과 일치하는 메세지를 검색해 반환한다. receive/1 함수는 case/2 와 마찬가지로 많은 절과 가드를 지원한다.</p>

<p>패턴과 일치하는 어떤 메세지도 없다면, 현재 프로세스는 일치하는 메세지가 올 때까지 대기한다. 타임아웃도 명시할 수 있다.</p>

<pre><code>  
iex&gt; receive do
  
&amp;#8230;&gt; {:hello, msg} -&gt; msg
  
&amp;#8230;&gt; after
  
&amp;#8230;&gt; 1_000 -&gt; &quot;nothing after 1s&quot;
  
&amp;#8230;&gt; end
  
&quot;nothing after 1s&quot;
  
</code></pre>

<p>메일박스에 기대하는 메세지가 이미 있다면 타임아웃에 0을 지정할 수 있다.</p>

<p>프로세스 간에 메세지를 주고 받는 예제를 살펴보자.</p>

<pre><code>  
iex&gt; parent = self()
  
#PID&lt;0.41.0&gt;
  
iex&gt; spawn fn -&gt; send(parent, {:hello, self()}) end
  
#PID&lt;0.48.0&gt;
  
iex&gt; receive do
  
&amp;#8230;&gt; {:hello, pid} -&gt; &quot;Got hello from #{inspect pid}&quot;
  
&amp;#8230;&gt; end
  
&quot;Got hello from #PID&lt;0.48.0&gt;&quot;
  
</code></pre>

<p>쉘에서, flush/0 함수를 유용하게 사용할 수 있다. 메일박스의 모든 메세지를 꺼내 출력해 준다.</p>

<pre><code>  
iex&gt; send self(), :hello
  
:hello
  
iex&gt; flush()
  
:hello
  
:ok
  
</code></pre>

<h2 id="links">Links</h2>

<p>exlixr에서 프로세스를 생성하는 일반적인 방법은 사실 spawn_link/1 함수를 사용하는 것이다. spawn_link/1 예제를 보기 전에, 프로세스가 실패하면 무슨 일이 생기는지 확인해 보자.</p>

<pre><code>  
iex&gt; spawn fn -&gt; raise &quot;oops&quot; end
  
#PID&lt;0.58.0&gt;

[error] Error in process &lt;0.58.0&gt; with exit value: &amp;#8230;
  
</code></pre>

<p>생성된 프로세스는 여전히 동작중이지만, 에러가 출력된다. 이유는 프로세스가 격리되어 있기 때문이다. 하나의 프로세스가 실패했을 때 다른 프로세스에 전파하고자 한다면, 우리는 그들 프로세스를 연결시켜야 한다. spawn_link/1함수가 이를 가능하게 한다.</p>

<pre><code>  
iex&gt; spawn_link fn -&gt; raise &quot;oops&quot; end
  
#PID&lt;0.41.0&gt;

** (EXIT from #PID&lt;0.41.0&gt;) an exception was raised:
      
** (RuntimeError) oops
          
:erlang.apply/2
  
</code></pre>

<p>쉘에서 실패했을 때, 쉘은 자동적으로 실패를 감지(traps)해서 근사한 형태로 출력할 뿐이다. 우리 코드에서 실제로 무슨 일이 일어났는지 이해하려면, spawn_link/1 함수를 파일에서 사용하고 실행해 봐야 한다.</p>

<pre><code>  
\# spawn.exs
  
spawn_link fn -&gt; raise &quot;oops&quot; end

receive do
    
:hello -&gt; &quot;let's wait until the process fails&quot;
  
end
  
</code></pre>

<p>이번에는 프로세스가 실패하면 부모 프로세스의 중지(down)도 유발한다. Process.link/1 함수를 통해 수동적으로 연결을 만들 수도 있는데, 프로세스가 제공하는 다른 기능들을 더 살펴보려면 Process 모듈을 살펴보도록 한다.</p>

<p>프로세스와 링크는 결함 내구성(fault-talerant) 시스템을 만드는데 중요한 역할을 한다. elixir 응용프로그램에서는, 프로세스의 종료와 새로운 프로세스의 시작을 감지하기 위해서 슈퍼바이저와 프로세스를 링크하곤 한다. 이것이 가능한 이유는 프로세스가 기본적으로 어떤 것도 공유하지 않고 서로 격리되어 있기 때문이다. 프로세스가 격리되어 있기 때문에 다른 프로세스에 크래시와 결함 상태를 전파할 수 있는 방법이 없다.</p>

<p>다른 언어에서는 우리가 직접 예외를 잡아서 처리하도록 하고 있지만, elixir에서는 슈퍼바이저가 우리 시스템을 적합하게 재시작할 것을 기대하므로 프로세스가 실패하도록 내버려 두어도 된다. &#8220;빨리 실패해라 &#8211; Failing fast&#8221;가 elixir 소프트웨어를 작성할 때 우리의 일반적인 철학이다!</p>

<p>다음 챕터로 넘어가기 전에, elixir에서 프로세스를 만드는 일반적인 유즈 케이스 중에 하나를 더 알아보자.</p>

<h2 id="tasks">Tasks</h2>

<p>이전 예제에서 프로세스가 크래쉬되었을 때 우리는 약간의 정보를 갖는 에러 메세지를 통지 받았다.</p>

<pre><code>  
iex&gt; spawn fn -&gt; raise &quot;oops&quot; end
  
#PID&lt;0.58.0&gt;

[error] Error in process &lt;0.58.0&gt; with exit value: &amp;#8230;
  
</code></pre>

<p>spawn/1 함수와 spawn_link/1 함수에서는, 에러메세지가 VM에 직접 생성되는데다 부족한 정보만을 포함한다. 실전에서는, 개발자가 Task 모듈의 Task.start/1 함수와 Task.start_link/1 함수를 사용해서 좀 더 명시적으로 사용할 수 있다.</p>

<pre><code>  
iex(1)&gt; Task.start fn -&gt; raise &quot;oops&quot; end
  
{:ok, #PID&lt;0.55.0&gt;}

15:22:33.046 [error] Task #PID&lt;0.55.0&gt; started from #PID&lt;0.53.0&gt; terminating
  
Function: #Function&lt;20.90072148/0 in :erl_eval.expr/5&gt;
      
Args: []
  
** (exit) an exception was raised:
      
** (RuntimeError) oops
          
(elixir) lib/task/supervised.ex:74: Task.Supervised.do_apply/2
          
(stdlib) proc\_lib.erl:239: :proc\_lib.init\_p\_do_apply/3
  
</code></pre>

<p>좀 더 나은 에러 로깅을 하는 대신 몇 개의 차이가 있다: start/1 함수와 start_link/1 함수는 pid만 반환하지 않고 {:ok, pid} 튜플을 반환한다. 이것이 태스크가 슈퍼비전 트리에서 사용되도록 해주는 이유이다. 게다가, 태스크는 분산을 쉽게 해주는 Task.async/1과 Task.await/1과 같은 편리한 함수를 제공해 준다.</p>

<p>우리는 이러한 기능들을 Mix and OTP guide에서 자세히 살펴보도록 하고, 지금은 태스크가 로깅에 좀 더 좋다는 것만 기억하도록 하자.</p>

<h2 id="state">State</h2>

<p>우리는 아직까지 상태(state)에 관해서는 말하지 않았다. 우리가 상태를 요하는 응용프로그램(예를 들어 응용프로그램 설정을 유지해야 하는)을 만들고 있다면, 파일을 파싱해서 메모리에 유지해야 하는데, 이 값을 어디에 저장할 것인가?</p>

<p>프로세스가 이 질문의 가장 일반적인 대답이다. 우리는 무한루프를 갖는 프로세스를 작성할 수 있고, 이 루프에서 상태를 유지하고, 메세지를 주고 받을 수 있다.</p>

<p>예를 들어, 키-값 쌍을 저장하는 프로세스를 생성하는 &#8220;kv.exs&#8221; 파일명을 갖는 모듈을 작성해 본다고 하자.</p>

<pre><code>  
defmodule KV do
    
def start_link do
      
Task.start_link(fn -&gt; loop(%{}) end)
    
end

defp loop(map) do
      
receive do
        
{:get, key, caller} -&gt;
          
send caller, Map.get(map, key)
          
loop(map)
        
{:put, key, value} -&gt;
          
loop(Map.put(map, key, value))
      
end
    
end
  
end
  
</code></pre>

<p>start_link 함수는 기본적으로 빈 맵과 함께 loop/1 함수를 실행하는 새로운 프로세스를 생성하는 것에 주목한다. loop/1 함수는 메세지를 기다렸다가 적합한 액션을 수행한다. :get 메세지의 경우, caller에게 메세지를 보내고 loop/1 함수를 다시 호출(tail call 최적화 &#8211; 꼬리 재귀, 스택 사용하지 않음)하여 메세지 수신을 다시 시작한다. :put 메세지의 경우 맵의 새로운 버전(메세지에 포함된 key, value를 저장한)을 loop/1 함수에 전달한다.</p>

<p>iex kv.exs를 수행해서 실습해보도록 하자.</p>

<pre><code>  
iex&gt; {:ok, pid} = KV.start_link
  
#PID&lt;0.62.0&gt;
  
iex&gt; send pid, {:get, :hello, self()}
  
{:get, :hello, #PID&lt;0.41.0&gt;}
  
iex&gt; flush
  
nil
  
</code></pre>

<p>처음에는, 프로세스의 맵에는 어떤 키도 없기 때문에, :get 메세지를 보내고 flushing을 해 보아도 프로세스의 inbox는 nil값만 반환하게 된다. :put 메세지를 보내고 다시 시도해 보자.</p>

<pre><code>  
iex&gt; send pid, {:put, :hello, :world}
  
#PID&lt;0.62.0&gt;
  
iex&gt; send pid, {:get, :hello, self()}
  
{:get, :hello, #PID&lt;0.41.0&gt;}
  
iex&gt; flush
  
:world
  
</code></pre>

<p>프로세스가 어떻게 상태를 유지하고 우리가 어떻게 프로세스에 메세지를 보내는 것으로 값을 조회하고 수정하는지에 주목한다. 사실, 위의 예제에서 사용된 pid를 아는 어떤 프로세스도 메세지를 보내고 상태를 처리할 수 있다.</p>

<p>pid에 이름을 등록해서, 이름을 아는 어떤 프로세스도 메세지를 보내게 할 수도 있다.</p>

<pre><code>  
iex&gt; Process.register(pid, :kv)
  
true
  
iex&gt; send :kv, {:get, :hello, self()}
  
{:get, :hello, #PID&lt;0.41.0&gt;}
  
iex&gt; flush
  
:world
  
</code></pre>

<p>elixir 응용프로그램에서 프로세스에 이름을 등록하는 것은 매우 흔한 패턴이다. 하지만 우리는 위와 같은 수동적인 방법을 사용하길 원하지 않기 때문에, Agent 모듈을 사용해서 다음과 같이 사용하도록 한다.</p>

<pre><code>  
iex&gt; {:ok, pid} = Agent.start_link(fn -&gt; %{} end)
  
{:ok, #PID&lt;0.72.0&gt;}
  
iex&gt; Agent.update(pid, fn map -&gt; Map.put(map, :hello, :world) end)
  
:ok
  
iex&gt; Agent.get(pid, fn map -&gt; Map.get(map, :hello) end)
  
:world
  
</code></pre>

<p>:name 옵션은 Agent.start_link/2함수에 전달할 수 있고 자동적으로 등록된다(PID의 이름으로). Agent이외에도 elixir는 프로세스에 의해 구동되는 generic server(GenServer라고 불리는), generic event manager와 event handler(GenEvent라고 불리는), 태스크 등등을 만드는 API를 제공한다. 그런 것들 모두 슈퍼비전 트리에 속하며 처음부터 끝까지 elixir 응용프로그램을 완성하는데 사용되는 Mix and OTP guide에서 더 자세히 알아볼 수 있다.</p>

<h2 id="참고">참고</h2>

<ul>
<li><a href="http://elixir-lang.org/getting-started/processes.html#spawn">Elixir Processes</a></li>
</ul>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
        
        
            
        
        on
            
                <a href="https://jeidee.github.iotags/tutorial/">#tutorial</a>,
            
        
        <time class="post-date" datetime="2015-06-16T00:00:00Z">
            16 Jun 2015
        </time>
    </footer>
</article>

	

	<nav class="pagination" role="navigation">
	
	<span class="page-number">Page 1 of 2</span>
	
	    <a class="older-posts" href="/tags/tutorial/page/2/">Older Posts &rarr;</a>
	
</nav>

</main>



    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">Erlang &amp; Go</a> </section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://jeidee.github.iojs/jquery.js"></script>
    <script type="text/javascript" src="https://jeidee.github.iojs/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://jeidee.github.iojs/index.js"></script>

</body>
</html>

