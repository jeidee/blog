<!DOCTYPE html>
<html lang="ko-kr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Erlang &amp; Go  | erlang 어플리케이션 중단 없이 변경된 모듈만 리로드하기</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.51" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="erlang 어플리케이션 중단 없이 변경된 모듈만 리로드하기" />
<meta property="og:description" content="erlang 어플리케이션이 작동 중인 상황에서 중단 없이 변경된 모듈만 리로드 하고 싶은 경우가 있다.
단순히 .beam 파일만 교체하는 것으로 해결되지는 않으며,
변경된 .beam 파일로 교체(copy)한 후 실행 중인 어플리케이션에 콘솔로 접속한 후 다음과 같이 변경된 모듈을 명시적으로 리로드해야 한다.
&gt; code:purge(M), code:load_file(M).  code:purge/1 함수는 정해진 모듈을 메모리에서 제거하는데, 해당 모듈을 사용하는 프로세스가 있을 경우 먼저 해당 프로세스들을 kill하게 된다.
프로세스를 kill할 수 없는 경우 code:purge/1는 false를 리턴한다.
보통 서버 모듈(gen_server를 구현했거나 자체 루프를 가지고 프로세스 형태로 존재하는)의 경우 code:purge/1함수를 호출하면 false를 반환할 것이다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jeidee.github.io/2016/04/22/erlang-ec96b4ed948ceba6acecbc80ec9db4ec8598-eca491eb8ba8-ec9786ec9db4-ebb380eab2bdeb909c-ebaaa8eb9388eba78c-eba6aceba19ceb939ced9598/" /><meta property="article:published_time" content="2016-04-22T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2016-04-22T00:00:00&#43;00:00"/>

<meta itemprop="name" content="erlang 어플리케이션 중단 없이 변경된 모듈만 리로드하기">
<meta itemprop="description" content="erlang 어플리케이션이 작동 중인 상황에서 중단 없이 변경된 모듈만 리로드 하고 싶은 경우가 있다.
단순히 .beam 파일만 교체하는 것으로 해결되지는 않으며,
변경된 .beam 파일로 교체(copy)한 후 실행 중인 어플리케이션에 콘솔로 접속한 후 다음과 같이 변경된 모듈을 명시적으로 리로드해야 한다.
&gt; code:purge(M), code:load_file(M).  code:purge/1 함수는 정해진 모듈을 메모리에서 제거하는데, 해당 모듈을 사용하는 프로세스가 있을 경우 먼저 해당 프로세스들을 kill하게 된다.
프로세스를 kill할 수 없는 경우 code:purge/1는 false를 리턴한다.
보통 서버 모듈(gen_server를 구현했거나 자체 루프를 가지고 프로세스 형태로 존재하는)의 경우 code:purge/1함수를 호출하면 false를 반환할 것이다.">


<meta itemprop="datePublished" content="2016-04-22T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2016-04-22T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="196">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="erlang 어플리케이션 중단 없이 변경된 모듈만 리로드하기"/>
<meta name="twitter:description" content="erlang 어플리케이션이 작동 중인 상황에서 중단 없이 변경된 모듈만 리로드 하고 싶은 경우가 있다.
단순히 .beam 파일만 교체하는 것으로 해결되지는 않으며,
변경된 .beam 파일로 교체(copy)한 후 실행 중인 어플리케이션에 콘솔로 접속한 후 다음과 같이 변경된 모듈을 명시적으로 리로드해야 한다.
&gt; code:purge(M), code:load_file(M).  code:purge/1 함수는 정해진 모듈을 메모리에서 제거하는데, 해당 모듈을 사용하는 프로세스가 있을 경우 먼저 해당 프로세스들을 kill하게 된다.
프로세스를 kill할 수 없는 경우 code:purge/1는 false를 리턴한다.
보통 서버 모듈(gen_server를 구현했거나 자체 루프를 가지고 프로세스 형태로 존재하는)의 경우 code:purge/1함수를 호출하면 false를 반환할 것이다."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://jeidee.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Erlang &amp; Go
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">erlang 어플리케이션 중단 없이 변경된 모듈만 리로드하기</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2016-04-22T00:00:00Z">April 22, 2016</time>      
      
      
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<p>erlang 어플리케이션이 작동 중인 상황에서 중단 없이 변경된 모듈만 리로드 하고 싶은 경우가 있다.</p>

<p>단순히 .beam 파일만 교체하는 것으로 해결되지는 않으며,</p>

<p>변경된 .beam 파일로 교체(copy)한 후 실행 중인 어플리케이션에 콘솔로 접속한 후 다음과 같이 변경된 모듈을 명시적으로 리로드해야 한다.</p>

<pre><code class="language-erlang">  
&gt; code:purge(M), code:load_file(M).
  
</code></pre>

<p>code:purge/1 함수는 정해진 모듈을 메모리에서 제거하는데, 해당 모듈을 사용하는 프로세스가 있을 경우 먼저 해당 프로세스들을 kill하게 된다.</p>

<p>프로세스를 kill할 수 없는 경우 code:purge/1는 false를 리턴한다.</p>

<p>보통 서버 모듈(gen_server를 구현했거나 자체 루프를 가지고 프로세스 형태로 존재하는)의 경우 code:purge/1함수를 호출하면 false를 반환할 것이다.</p>

<p>즉, 현재 동작 중인 서버 프로세스는 교체할 수 없다. OTP 프레임웍을 구현한 서버 모듈의 경우 code_change/3 behaviour를 구현하는 것으로 목적을 달성할 수 있다.</p>

<p>다음 코드는 .beam 파일의 버전을 확인해서 변경된 모듈을 리스트로 구하는 코드이다.</p>

<pre><code class="language-erlang">  
all_changed() -&gt;
      
[M || {M, Fn} &lt;- code:all\_loaded(), is\_list(Fn), is_changed(M)].

is_changed(M) -&gt;
      
try
          
module\_vsn(M:module\_info()) =/= module\_vsn(code:get\_object_code(M))
      
catch \_:\_ -&gt;
          
false
      
end.

module\_vsn({M, Beam, \_Fn}) -&gt;
      
{ok, {M, Vsn}} = beam_lib:version(Beam),
      
Vsn;
  
module\_vsn(L) when is\_list(L) -&gt;
      
{_, Attrs} = lists:keyfind(attributes, 1, L),
      
{_, Vsn} = lists:keyfind(vsn, 1, Attrs),
      
Vsn.
  
</code></pre>

<p>모듈의 버전은 다음 매크로를 통해 관리할 수 있다.</p>

<pre><code class="language-erlang">  
-vsn(&quot;1.0&quot;).
  
</code></pre>

<p>변경된 모듈의 리스트를 받아 리로드하는 기능은 다음과 같이 구현한다.</p>

<pre><code class="language-erlang">  
reload_modules(Modules) -&gt;
      
[begin code:purge(M), code:load_file(M) end || M &lt;- Modules].
  
</code></pre>

<h2 id="참고">참고</h2>

<ul>
<li><a href="https://github.com/mochi/mochiweb/blob/1.4.0/src/reloader.erl">mochiweb reloader.erl</a></li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6">
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-erlnote-wordpress-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://jeidee.github.io/" >
    &copy; 2018 Erlang &amp; Go
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
